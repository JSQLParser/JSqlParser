/*
 * #%L
 * JSQLParser library
 * %%
 * Copyright (C) 2004 - 2021 JSQLParser
 * %%
 * Dual licensed under GNU LGPL 2.1 or Apache License 2.0
 * #L%
 */

options {
    IGNORE_CASE = true;
    STATIC = false;
    DEBUG_PARSER = false;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
    CACHE_TOKENS = false;
    SINGLE_TREE_FILE = false;
//  FORCE_LA_CHECK = true;
    UNICODE_INPUT = true;
    JAVA_TEMPLATE_TYPE = "modern";
//  JDK_VERSION = "1.8";
    TOKEN_EXTENDS = "BaseToken";
    COMMON_TOKEN_ACTION = true;
    NODE_DEFAULT_VOID = true;
    TRACK_TOKENS = true;
    VISITOR = true;
    GRAMMAR_ENCODING = "UTF-8";
    KEEP_LINE_COLUMN = true;
//  USER_CHAR_STREAM = false;
}

PARSER_BEGIN(CCJSqlParser)

package net.sf.jsqlparser.parser;

import java.lang.reflect.Field;
import java.lang.Integer;

import net.sf.jsqlparser.parser.feature.*;
import net.sf.jsqlparser.expression.*;
import net.sf.jsqlparser.expression.operators.arithmetic.*;
import net.sf.jsqlparser.expression.operators.conditional.*;
import net.sf.jsqlparser.expression.operators.relational.*;
import net.sf.jsqlparser.schema.*;
import net.sf.jsqlparser.statement.*;
import net.sf.jsqlparser.statement.analyze.*;
import net.sf.jsqlparser.statement.alter.*;
import net.sf.jsqlparser.statement.alter.sequence.*;
import net.sf.jsqlparser.statement.comment.*;
import net.sf.jsqlparser.statement.create.function.*;
import net.sf.jsqlparser.statement.create.index.*;
import net.sf.jsqlparser.statement.create.policy.*;
import net.sf.jsqlparser.statement.create.procedure.*;
import net.sf.jsqlparser.statement.create.schema.*;
import net.sf.jsqlparser.statement.create.synonym.*;
import net.sf.jsqlparser.statement.create.sequence.*;
import net.sf.jsqlparser.statement.create.table.*;
import net.sf.jsqlparser.statement.create.view.*;
import net.sf.jsqlparser.statement.delete.*;
import net.sf.jsqlparser.statement.drop.*;
import net.sf.jsqlparser.statement.insert.*;
import net.sf.jsqlparser.statement.execute.*;
import net.sf.jsqlparser.statement.piped.*;
import net.sf.jsqlparser.statement.select.*;
import net.sf.jsqlparser.statement.refresh.*;
import net.sf.jsqlparser.statement.show.*;
import net.sf.jsqlparser.statement.truncate.*;
import net.sf.jsqlparser.statement.update.*;
import net.sf.jsqlparser.statement.upsert.*;
import net.sf.jsqlparser.statement.merge.*;
import net.sf.jsqlparser.statement.grant.*;
import net.sf.jsqlparser.statement.imprt.*;
import net.sf.jsqlparser.statement.export.*;
import net.sf.jsqlparser.statement.lock.*;
import java.util.*;
import java.util.AbstractMap.SimpleEntry;
import net.sf.jsqlparser.statement.select.SetOperationList.SetOperationType;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * The parser generated by JavaCC
 */
public class CCJSqlParser extends AbstractJSqlParser<CCJSqlParser> {
    public final static Logger LOGGER = Logger.getLogger(CCJSqlParser.class.getName());
    public int bracketsCounter = 0;
    public int caseCounter = 0;
    public boolean interrupted = false;

    public CCJSqlParser withConfiguration(FeatureConfiguration configuration) {
        token_source.configuration = configuration;
        return this;
    }

    public FeatureConfiguration getConfiguration() {
        return token_source.configuration;
    }

    public CCJSqlParser me () {
    	return this;
    }

    private void linkAST(ASTNodeAccess access, Node node) {
        access.setASTNode(node);
        node.jjtSetValue(access);
    }

    public Node getASTRoot() {
        return jjtree.rootNode();
    }

    private static class ObjectNames {

        private final List<String> names;
        private final List<String> delimiters;

        public ObjectNames(List<String> names, List<String> delimiters) {
            this.names = names;
            this.delimiters = delimiters;
        }

        public List<String> getNames() {
            return names;
        }

        public List<String> getDelimiters() {
            return delimiters;
        }
    }

    private static void appendWhitespaceFromTokenGap(StringBuilder buffer, Token prev, Token curr) {
        if (prev == null) return;

        int lineDiff = curr.beginLine - prev.endLine;
        if (lineDiff > 0) {
            for (int i = 0; i < lineDiff; i++) buffer.append('\n');
            for (int i = 1; i < curr.beginColumn; i++) buffer.append(' ');
        } else {
            int spaceCount = curr.beginColumn - prev.endColumn - 1;
            for (int i = 0; i < spaceCount; i++) buffer.append(' ');
        }
    }

    private static void appendTokenImageAndTrackDelimiter(StringBuilder buffer, Deque<Character> windowQueue,
                                                          int delimiterLength, String image, String tag) {
        for (char ch : image.toCharArray()) {
            buffer.append(ch);
            windowQueue.addLast(ch);
            if (windowQueue.size() > delimiterLength) {
                windowQueue.removeFirst();
            }
        }
    }

    private static boolean endsWithDelimiter(Deque<Character> windowQueue, String delimiter) {
        if (windowQueue.size() != delimiter.length()) return false;

        int i = 0;
        for (char ch : windowQueue) {
            if (ch != delimiter.charAt(i++)) return false;
        }
        return true;
    }

}

PARSER_END(CCJSqlParser)

TOKEN_MGR_DECLS : {
    public FeatureConfiguration configuration = new FeatureConfiguration();

    // Identify the index of the quoting/escaping tokens
    public int charLiteralIndex = -1;
    public int squaredBracketOpenIndex = -1;
    {
        for (int i=0;i<CCJSqlParserConstants.tokenImage.length;i++) {
          if ( CCJSqlParserConstants.tokenImage[i].equals("<S_CHAR_LITERAL>") ) {
              charLiteralIndex = i;
              break;
          }
        }
        for (int i=0;i<CCJSqlParserConstants.tokenImage.length;i++) {
            if (CCJSqlParserConstants.tokenImage[i].equals("\"[\"")) {
                squaredBracketOpenIndex = i;
                break;
            }
        }
    }

    // Finds first occurrence of "\\'"
    public static int indexOfSequence(String s, String target) {
        int len = s.length();
        for (int i = 0; i < len - 1; i++) {
            if (s.charAt(i) == '\\' && s.charAt(i + 1) == '\'') {
                return i;
            }
        }
        return -1;
    }

    // Finds last occurrence of "\\''"
    public static int lastIndexOfSequence(String s, String target) {
        int len = s.length();
        for (int i = len - 3; i >= 0; i--) {
            if (s.charAt(i) == '\\' && s.charAt(i + 1) == '\'' && s.charAt(i + 2) == '\'') {
                return i;
            }
        }
        return -1;
    }

    public void CommonTokenAction(Token t)
	{
		t.absoluteBegin = getCurrentTokenAbsolutePosition();
		t.absoluteEnd = t.absoluteBegin + t.image.length();
	}

	public int getCurrentTokenAbsolutePosition()
	{
		if (input_stream instanceof SimpleCharStream)
			return ((SimpleCharStream)input_stream).getAbsoluteTokenBegin();
		return -1;
	}
}

SKIP:
{
    <WHITESPACE: " " | "\t" | "\r" | "\n">
}

// http://www.h2database.com/html/advanced.html#keywords

TOKEN: /* SQL Keywords. prefixed with K_ to avoid name clashes */
{
    <K_AT_SIGN: "@">
|   <K_AT_V: "@V">
|   <K_ABSENT: "ABSENT">
|   <K_ACTION: "ACTION">
|   <K_ACTIVE: "ACTIVE">
|   <K_ADD:"ADD">
|   <K_ADVANCE:"ADVANCE">
|   <K_ADVISE:"ADVISE">
|   <K_AGAINST:"AGAINST">
|   <K_AGGREGATE: "AGGREGATE">
|   <K_ALGORITHM: "ALGORITHM">
|   <K_ALIGN:"ALIGN">
|   <K_ALL:"ALL">
|   <K_ALTER:"ALTER">
|   <K_ALWAYS:"ALWAYS">
|   <K_ANALYZE:"ANALYZE">
|   <K_AND:"AND">
|   <K_ANY:"ANY">
|   <K_APPEND_ONLY:"APPEND_ONLY">
|   <K_APPLY:"APPLY">
|   <K_APPROXIMATE:"APPROXIMATE">
|   <K_ARCHIVE: "ARCHIVE">
|   <K_ARRAY_LITERAL: "ARRAY" >
|   <K_AS: "AS">
|   <K_ASYMMETRIC: "ASYMMETRIC">
|   <K_AT: "AT">
|   <K_ASC:"ASC">
|   <K_AUTHORIZATION:"AUTHORIZATION">
|   <K_AUTO:"AUTO">
|   <K_AUTO_INCREMENT:"AUTO_INCREMENT">
|   <K_AZURE:"AZURE">
|   <K_BASE64:"BASE64">
|   <K_BEFORE: "BEFORE">
|   <K_BEGIN:"BEGIN">
|   <K_BERNOULLI: "BERNOULLI">
|   <K_BETWEEN:"BETWEEN">
|   <K_BINARY: "BINARY">
|   <K_BIT:"BIT">
|   <K_BLOBSTORAGE:"BLOBSTORAGE">
|   <K_BLOCK: "BLOCK">
|   <K_BOOLEAN:"BOOLEAN">
|   <K_BOTH:"BOTH">
|   <K_BRANCH:"BRANCH">
|   <K_BROWSE:"BROWSE">
|   <K_BY:"BY">
|   <K_BYTES: "BYTES">
|   <K_CACHE: "CACHE">
|   <K_BUFFERS: "BUFFERS">
|   <K_BYTE: "BYTE">
|   <K_CALL : "CALL">
|   <K_CASCADE: "CASCADE">
|   <K_CASE:"CASE">
|   <K_CASEWHEN:"CASEWHEN">  /* H2 casewhen function */
|   <K_CAST: "CAST">
|   <K_CERTIFICATE: "CERTIFICATE">
|   <K_CHARACTER:"CHARACTER">
|   <K_CHANGE:"CHANGE">
|   <K_CHANGES:"CHANGES">
|   <K_CHECK:"CHECK">
|   <K_CHECKPOINT:"CHECKPOINT">
|   <K_CHAR:"CHAR">
|   <K_CLOSE:"CLOSE">
|   <K_CLOUD:"CLOUD">
|   <K_COALESCE:"COALESCE">
|   <K_COLLATE:"COLLATE">
|   <K_COLUMN:"COLUMN">
|   <K_COLUMNS:"COLUMNS">
|   <K_COMMA: ",">
|   <K_COMMIT:"COMMIT">
|   <K_COMMENT:"COMMENT">
|   <K_COMMENTS:"COMMENTS">
|   <K_CONFLICT:"CONFLICT">
|   <K_CONNECT:"CONNECT">
|   <K_CONNECT_BY_ROOT: "CONNECT_BY_ROOT">
|   <K_CONSTRAINT:"CONSTRAINT">
|   <K_CONSTRAINTS:"CONSTRAINTS">
|   <K_CONVERT:"CONVERT">
|   <K_CORRESPONDING:"CORRESPONDING">
|   <K_COSTS: "COSTS">
|   <K_COUNT: "COUNT">
|   <K_CREATE:"CREATE">
|   <K_CREATED:"CREATED">
|   <K_CROSS:"CROSS">
|   <K_CSV:"CSV">
|   <K_CURRENT: "CURRENT">
|   <K_CYCLE:"CYCLE">
|   <K_DATABASE:"DATABASE">
|   <K_DATA:"DATA">
|   <K_DECLARE: "DECLARE">
|   <K_DATETIMELITERAL : "DATE" | "DATETIME" | "TIME" | "TIMESTAMP" | "TIMESTAMPTZ" >
|   <K_DATE_LITERAL : "YEAR" | "MONTH" | "DAY" | "HOUR" | "MINUTE" | "SECOND" >
|   <K_DBA_RECYCLEBIN: "DBA_RECYCLEBIN">
|   <K_DEFAULT : "DEFAULT">
|   <K_DEFAULTS: "DEFAULTS">
|   <K_DEFERRABLE : "DEFERRABLE">
|   <K_DELAYED : "DELAYED">
|   <K_DELETE:"DELETE">
|   <K_DELIMIT : "DELIMIT">
|   <K_DELIMITER : "DELIMITER">
|   <K_DESC:"DESC">
|   <K_DESCRIBE:"DESCRIBE">
|   <K_DISABLE : "DISABLE">
|   <K_DISCARD : "DISCARD">
|   <K_DISCONNECT:"DISCONNECT">
|   <K_DISTINCT:"DISTINCT">
|   <K_DISTINCTROW:"DISTINCTROW">
|   <K_DIV:"DIV">
|   <K_DDL:"DDL">
|   <K_DML:"DML">
|   <K_DO:"DO">
|   <K_DOMAIN:"DOMAIN">
|   <K_DRIVER:"DRIVER">
|   <K_DROP:"DROP">
|   <K_DUMP:"DUMP">
|   <K_DUPLICATE: "DUPLICATE">
|   <K_ELEMENTS: "ELEMENTS">
|   <K_ELSE:"ELSE">
|   <K_EMIT: "EMIT">
|   <K_ENABLE: "ENABLE">
|   <K_ENCODING: "ENCODING">
|   <K_ENCRYPTION: "ENCRYPTION">
|   <K_END: "END">
|   <K_ENFORCED: "ENFORCED">
|   <K_ENGINE: "ENGINE">
|   <K_ERROR: "ERROR">
|   <K_ERRORS: "ERRORS">
|   <K_ESCAPE: "ESCAPE">
|   <K_EXA: "EXA">
|   <K_EXCEPT: "EXCEPT">
|   <K_EXCHANGE: "EXCHANGE">
|   <K_EXCLUDE: "EXCLUDE">
|   <K_EXCLUDES: "EXCLUDES"> /* Salesforce SOQL */
|   <K_EXCLUDING: "EXCLUDING">
|   <K_EXCLUSIVE: "EXCLUSIVE">
|   <K_EXEC: "EXEC">
|   <K_EXECUTE: "EXECUTE">
|   <K_EXISTS:"EXISTS">
|   <K_EXPLAIN:"EXPLAIN">
|   <K_EXPLICIT:"EXPLICIT">
|   <K_EXTEND:"EXTEND">
|   <K_EXTENDED:"EXTENDED">
|   <K_EXTRACT:"EXTRACT">
|   <K_EXPORT:"EXPORT">
|   <K_FBV:"FBV">
|   <K_FETCH:"FETCH">
|   <K_ISOLATION:("UR" | "RS" | "RR" | "CS")>
|   <K_FILE: "FILE">
|   <K_FILTER: "FILTER">
|   <K_FINAL: "FINAL">
|   <K_FIRST: "FIRST">
|   <K_FALSE: "FALSE">
|   <K_FLUSH: "FLUSH">
|   <K_FOLLOWING: "FOLLOWING">
|   <K_FOR:"FOR">
|   <K_FORCE : "FORCE">
|   <K_FOREIGN:"FOREIGN">
|   <K_FORMAT:"FORMAT">
|   <K_FROM:"FROM">
|   <K_FULL:"FULL">
|   <K_FULLTEXT:"FULLTEXT">
|   <K_FUNCTION:"FUNCTION">
|   <K_GLOBAL:"GLOBAL">
|   <K_GRANT:"GRANT">
|   <K_GROUP:"GROUP">
|   <K_GROUPING:"GROUPING">
|   <K_GROUP_CONCAT:"GROUP_CONCAT">
|   <K_GUARD:"GUARD">
|   <K_HAVING:"HAVING">
|   <K_HASH:"HASH">
|   <K_HIGH : "HIGH">
|   <K_HIGH_PRIORITY : "HIGH_PRIORITY">
|   <K_HISTORY : "HISTORY">
|   <K_HOPPING:"HOPPING">
|   <K_IDENTIFIED:"IDENTIFIED">
|   <K_IDENTITY:"IDENTITY">
|   <K_IF:"IF">
|   <K_IIF:"IIF">
|   <K_IGNORE : "IGNORE">
|   <K_ILIKE:"ILIKE">
|   <K_IMPORT:"IMPORT">
|   <K_IN:"IN">
|   <K_INCLUDE:"INCLUDE">
|   <K_INCLUDES:"INCLUDES"> /* Salesforce SOQL */
|   <K_INCLUDE_NULL_VALUES:"INCLUDE_NULL_VALUES">
|   <K_INCLUDING:"INCLUDING">
|   <K_INCREMENT:"INCREMENT">
|   <K_INDEX: "INDEX">
|   <K_INFORMATION: "INFORMATION">
|   <K_INNER:"INNER">
|   <K_STATEMENT:"STATEMENT">
|   <K_STRAIGHT:"STRAIGHT_JOIN">
|   <K_INSERT:"INSERT">
|   <K_INTERLEAVE: "INTERLEAVE">
|   <K_INTERPRET: "INTERPRET">
|   <K_INTERSECT:"INTERSECT">
|   <K_INTERVAL:"INTERVAL">
|   <K_INTO:"INTO">
|   <K_INVALIDATE:"INVALIDATE">
|   <K_INVERSE:"INVERSE">
|   <K_INVISIBLE:"INVISIBLE">
|   <K_IS:"IS">
|   <K_ISNULL:"ISNULL">
|   <K_JDBC:"JDBC">
|   <K_JOIN:"JOIN">
|   <K_JSON:"JSON">
|   <K_JSON_OBJECT: "JSON_OBJECT">
|   <K_JSON_OBJECTAGG: "JSON_OBJECTAGG">
|   <K_JSON_ARRAY: "JSON_ARRAY">
|   <K_JSON_ARRAYAGG: "JSON_ARRAYAGG">
|   <K_KEEP:"KEEP">
|   <K_KEY_BLOCK_SIZE: "KEY_BLOCK_SIZE">
|   <K_KEY:"KEY">
|   <K_KEYS:"KEYS">
|   <K_KILL:"KILL">
|   <K_FN:"FN">
|   <K_LAST: "LAST">
|   <K_LATERAL:"LATERAL">
|   <K_LEADING:"LEADING">
|   <K_LEFT:"LEFT">
|   <K_LESS:"LESS">
|   <K_LEVEL:"LEVEL">
|   <K_LIKE:"LIKE">
|   <K_LIMIT:"LIMIT">
|   <K_LOCAL:"LOCAL">
|   <K_LOCK:"LOCK">
|   <K_LOCKED:"LOCKED">
|   <K_LINK:"LINK">
|   <K_LOG:"LOG">
|   <K_LOOP:"LOOP">
|   <K_LOW : "LOW">
|   <K_LOW_PRIORITY : "LOW_PRIORITY">
|   <K_LTRIM : "LTRIM">
|   <K_MATCH: "MATCH">
|   <K_MATCH_ANY: "MATCH_ANY">
|   <K_MATCH_ALL: "MATCH_ALL">
|   <K_MATCH_PHRASE: "MATCH_PHRASE">
|   <K_MATCH_PHRASE_PREFIX: "MATCH_PHRASE_PREFIX">
|   <K_MATCH_REGEXP: "MATCH_REGEXP">
|   <K_MATCHED: "MATCHED">
|   <K_MATERIALIZED:"MATERIALIZED">
|   <K_MAX: "MAX">
|   <K_MAXVALUE: "MAXVALUE">
|   <K_MEMBER: "MEMBER">
|   <K_MERGE: "MERGE">
|   <K_MIN:"MIN">
|   <K_MINUS:"MINUS">
|   <K_MINVALUE:"MINVALUE">
|   <K_MODE: "MODE">
|   <K_MODIFY: "MODIFY">
|   <K_MOVEMENT: "MOVEMENT">
|   <K_NAMES:"NAMES">
|   <K_NATURAL:"NATURAL">
|   <K_NAME:"NAME">
|   <K_NEVER:"NEVER">
|   <K_NEXT:"NEXT">
|   <K_NEXTVAL: (  (("NEXTVAL")((" ")+("FOR"))?)  |  ( ("NEXT")(" ")+("VALUE") (" ")+("FOR") )  )>
|   <K_NO:"NO">
|   <K_NOCACHE:"NOCACHE">
|   <K_NOCYCLE:"NOCYCLE">
|   <K_NOKEEP:"NOKEEP">
|   <K_NOLOCK:"NOLOCK">
|   <K_NOMAXVALUE:"NOMAXVALUE">
|   <K_NOMINVALUE:"NOMINVALUE">
|   <K_NONE:"NONE">
|   <K_NOORDER:"NOORDER">
|   <K_NOT:"NOT">
|   <K_NOTHING:"NOTHING">
|   <K_NOTNULL:"NOTNULL">
|   <K_NOVALIDATE : "NOVALIDATE">
|   <K_NULL:"NULL">
|   <K_NULLS: "NULLS">
|   <K_NOWAIT: "NOWAIT">
|   <K_OF:"OF">
|   <K_OFF:"OFF">
|   <K_OFFSET:"OFFSET">
|   <K_ON:"ON">
|   <K_ONLY:"ONLY">
|   <K_OPEN:"OPEN">
|   <K_OR:"OR">
|   <K_ORA: "ORA">
|   <K_ORACLE_NAMED_PARAMETER_ASSIGNMENT: "=>">
|   <K_ORDER:"ORDER">
|   <K_ORDINALITY:"ORDINALITY">
|   <K_OUTER:"OUTER">
|   <K_OUTPUT:"OUTPUT">
|   <K_OVER:"OVER">
|   <K_OVERFLOW:"OVERFLOW">
|   <K_OVERLAPS:"OVERLAPS">
|   <K_OVERRIDING:"OVERRIDING">
|   <K_OVERWRITE:"OVERWRITE">
|   <K_OPTIMIZE: "OPTIMIZE" >
|   <K_PADDING:"PADDING">
|   <K_PARALLEL:"PARALLEL">
|   <K_PARENT:"PARENT">
|   <K_PARSER: "PARSER">
|   <K_PARTITION:"PARTITION">
|   <K_PARTITIONING:"PARTITIONING">
|   <K_PATH:"PATH">
|   <K_PERCENT:"PERCENT">
|   <K_PIVOT:"PIVOT">
|   <K_PLACING:"PLACING">
|   <K_PLAN:"PLAN">
|   <K_PLUS:"PLUS">
|   <K_PREFERRING: "PREFERRING">
|   <K_PRECEDING: "PRECEDING">
|   <K_PRIMARY:"PRIMARY">
|   <K_PRIOR:"PRIOR">
|   <K_PROCEDURE:"PROCEDURE">
|   <K_PUBLIC:"PUBLIC">
|   <K_POLICY:"POLICY">
|   <K_PURGE:"PURGE">
|   <K_QUALIFY: "QUALIFY">
|   <K_QUERY:"QUERY">
|   <K_QUICK : "QUICK">
|   <K_QUIESCE: "QUIESCE">
|   <K_RANGE: "RANGE">
|   <K_RAW: "RAW">
|   <K_READ: "READ" >
|   <K_REBUILD: "REBUILD">
|   <K_RECYCLEBIN: "RECYCLEBIN">
|   <K_RECURSIVE:"RECURSIVE">
|   <K_REFERENCES:"REFERENCES">
|   <K_REFRESH:"REFRESH">
|   <K_REGEXP: "REGEXP">
|   <K_REJECT: "REJECT">
|   <K_RESPECT: "RESPECT">
|   <K_RLIKE: "RLIKE">
|   <K_REGEXP_LIKE: "REGEXP_LIKE">
|   <K_REGISTER: "REGISTER">
|   <K_REMOTE: "REMOTE">
|   <K_REMOVE: "REMOVE">
|   <K_RENAME:"RENAME">
|   <K_REORGANIZE: "REORGANIZE">
|   <K_REPAIR: "REPAIR">
|   <K_REPEATABLE: "REPEATABLE">
|   <K_REPLACE:"REPLACE">
|   <K_RESET:"RESET">
|   <K_RESTART:"RESTART">
|   <K_RESUMABLE: "RESUMABLE">
|   <K_RESUME: "RESUME">
|   <K_RESTRICT: "RESTRICT">
|   <K_RESTRICTED: "RESTRICTED">
|   <K_RETURN: "RETURN">
|   <K_RETURNS: "RETURNS">
|   <K_RETURNING: "RETURNING">
|   <K_RIGHT:"RIGHT">
|   <K_ROLLBACK:"ROLLBACK">
|   <K_ROLLUP:"ROLLUP">
|   <K_ROOT:"ROOT">
|   <K_ROW: "ROW">
|   <K_ROWS: "ROWS">
|   <K_RTRIM: "RTRIM">
|   <K_SAFE_CAST: "SAFE_CAST">
|   <K_SAFE_CONVERT: "SAFE_CONVERT">
|   <K_SAMPLE: "SAMPLE">
|   <K_SAVEPOINT: "SAVEPOINT">
|   <K_SCHEMA: "SCHEMA">
|   <K_SCRIPT: "SCRIPT">
|   <K_SECURE: "SECURE">
|   <K_SECURITY:"SECURITY">
|   <K_SEED: "SEED">
|   <K_SELECT: ("SELECT" | "SEL")>
|   <K_SEMI : "SEMI">
|   <K_SEQUENCE: "SEQUENCE">
|   <K_SEPARATOR:"SEPARATOR">
|   <K_SESSION:"SESSION">
|   <K_SET:"SET">
|   <K_SETS:"SETS">
|   <K_SHOW : "SHOW">
|   <K_SHUTDOWN : "SHUTDOWN">
|   <K_SHARE : "SHARE">
|   <K_SIBLINGS:"SIBLINGS">
|   <K_SIMILAR:"SIMILAR">
|   <K_SIZE:"SIZE">
|   <K_SKIP: "SKIP">
|   <K_SOME:"SOME">
|   <K_SPATIAL:"SPATIAL">
|   <K_START:"START">
|   <K_STORED: "STORED">
|   <K_STREAM: "STREAM">
|   <K_STRICT: "STRICT">
|   <K_STRING: "STRING">
|   <K_STRUCT: "STRUCT">
|   <K_SUMMARIZE: "SUMMARIZE">
|   <K_SUSPEND:"SUSPEND">
|   <K_SWITCH: "SWITCH">
|   <K_SYMMETRIC:"SYMMETRIC">
|   <K_SYNONYM:"SYNONYM">
|   <K_SYSTEM:"SYSTEM">
|   <K_SYSTEM_TIME:"SYSTEM_TIME">
|   <K_SYSTEM_TIMESTAMP:"SYSTEM_TIMESTAMP">
|   <K_SYSTEM_VERSION:"SYSTEM_VERSION">
|   <K_TABLE:"TABLE">
|   <K_TABLES:"TABLES">
|   <K_TABLESAMPLE: "TABLESAMPLE">
|   <K_TABLESPACE: "TABLESPACE">
|   <K_TRIGGER: "TRIGGER">
|   <K_THEN:"THEN">
|   <K_TEMP:"TEMP">
|   <K_TEXT_LITERAL: "TEXT" | "TINYTEXT" | "MEDIUMTEXT" | "LONGTEXT" >
|   <K_TEMPORARY:"TEMPORARY">
|   <K_THAN:"THAN">
|   <K_TIME_KEY_EXPR : (
                         ("CURRENT" ( "_" | (" ")+ ) "TIMESTAMP")
                         | ("CURRENT" ( "_" | (" ")+ ) "TIME")
                         | ("CURRENT" ( "_" | (" ")+ ) "DATE")
                         | ("CURRENT" ( "_" | (" ")+ ) "TIMEZONE")
                       ) ( "()" )?>
|   <K_TIMEOUT:"TIMEOUT">
|   <K_TRIM:"TRIM">
|   <K_TO:"TO">
|   <K_TOP:"TOP">
|   <K_TRAILING:"TRAILING">
|   <K_TRUNCATE:"TRUNCATE">
|   <K_TRUE:"TRUE">
|   <K_TRY_CAST: "TRY_CAST">
|   <K_TRY_CONVERT: "TRY_CONVERT">
|   <K_TUMBLING:"TUMBLING">
|   <K_TYPE:"TYPE">
|   <K_UNBOUNDED: "UNBOUNDED">
|   <K_UNION:"UNION">
|   <K_UNIQUE:"UNIQUE">
|   <K_UNKNOWN:"UNKNOWN">
|   <K_UNLIMITED: "UNLIMITED">
|   <K_UNLOGGED: "UNLOGGED">
|   <K_UNPIVOT:"UNPIVOT">
|   <K_UPDATE:"UPDATE">
|   <K_UPSERT:"UPSERT">
|   <K_UNQIESCE:"UNQIESCE">
|   <K_USE:"USE">
|   <K_USER:"USER">
|   <K_SQL_CALC_FOUND_ROWS: "SQL_CALC_FOUND_ROWS">
|   <K_SQL_NO_CACHE: "SQL_NO_CACHE">
|   <K_SQL_CACHE: "SQL_CACHE">
|   <K_USING:"USING">
|   <K_SIGNED:"SIGNED">
|   <K_STRING_FUNCTION_NAME: ("SUBSTR" | "SUBSTRING" | "TRIM" | "POSITION" | "OVERLAY")>
|   <K_UNSIGNED:"UNSIGNED">
|   <K_VALIDATE : "VALIDATE">
|   <K_VALIDATION: "VALIDATION">
|   <K_VALUE:"VALUE">
|   <K_VALUES:"VALUES">
|   <K_VERBOSE: "VERBOSE">
|   <K_VERIFY: "VERIFY">
|   <K_VERSION: "VERSION">
|   <K_VIEW:"VIEW">
|   <K_VISIBLE: "VISIBLE">
|   <K_VOLATILE:"VOLATILE">
|   <K_CONCURRENTLY:"CONCURRENTLY">
|   <K_WAIT : "WAIT">
|   <K_WHEN:"WHEN">
|   <K_WHERE:"WHERE">
|   <K_WINDOW:"WINDOW">
|   <K_WITH:"WITH">
|   <K_WITH_TIES:"WITH TIES">
|   <K_WITHIN:"WITHIN">
|   <K_WITHOUT:"WITHOUT">
|   <K_WITHOUT_ARRAY_WRAPPER:"WITHOUT_ARRAY_WRAPPER">
|   <K_WORK:"WORK">
|   <K_XML:"XML">
|   <K_XOR:"XOR">
|   <K_XMLSERIALIZE:"XMLSERIALIZE">
|   <K_XMLAGG:"XMLAGG">
|   <K_XMLDATA:"XMLDATA">
|   <K_XMLSCHEMA:"XMLSCHEMA">
|   <K_XMLTEXT:"XMLTEXT">
|   <K_XSINIL:"XSINIL">
|   <K_YAML:"YAML">
|   <K_YES:"YES">
|   <K_ZONE:"ZONE">

|   <OPENING_BRACKET: "(">
|   <CLOSING_BRACKET: ")">
|   <OPENING_CURLY_BRACKET: "{">
|   <CLOSING_CURLY_BRACKET: "}">
|   <DOUBLE_COLON: ":">
|   <K_SIMILAR_TO: ( <K_SIMILAR> (" ")+ <K_TO> ) >
}

TOKEN : /* Statement Separators */
{
    <ST_SEMICOLON : ( ";" | ("\n\n\n") | "\n/\n" | "\ngo\n" ) >
}

TOKEN : /* Operators */
{
    <OP_GREATERTHANEQUALS: ">" (<WHITESPACE>)* "=">
|   <OP_COSINESIMILARITY: "<=>">
|   <OP_MINORTHANEQUALS: "<" (<WHITESPACE>)* "=">
|   <OP_NOTEQUALSSTANDARD: "<" (<WHITESPACE>)* ">">
|   <OP_NOTEQUALSBANG: "!" (<WHITESPACE>)* "=">
|   <OP_NOTEQUALSHAT: "^" (<WHITESPACE>)* "=">
|   <OP_CONCAT: "|" (<WHITESPACE>)* "|">
| 	<OP_DOUBLEAND: "&&">
| 	<OP_CONTAINS: "&>">
| 	<OP_CONTAINEDBY: "<&">
}

TOKEN : /* Date/Time with time zones */
{
    <DT_ZONE: <K_DATETIMELITERAL> (<WHITESPACE>)* ("(" <S_LONG> ")")? (<WHITESPACE>)* (<K_WITH> | <K_WITHOUT>) ((<WHITESPACE>)+ <K_LOCAL>)? (<WHITESPACE>)+ "TIME" (<WHITESPACE>)+ <K_ZONE>>
}

TOKEN : /* Data Types */
{
    <DATA_TYPE: ( <TYPE_BIT> | <TYPE_BLOB> | <TYPE_BOOLEAN> |  <TYPE_ENUM>
                     | <TYPE_REAL> | <TYPE_DOUBLE> | <TYPE_UUID> | <TYPE_MAP>| <TYPE_TINYINT> | <TYPE_SMALLINT>
                     | <TYPE_INTEGER> | <TYPE_BIGINT> | <TYPE_HUGEINT> | <TYPE_UTINYINT> | <TYPE_USMALLINT>
                     | <TYPE_UINTEGER> | <TYPE_UBIGINT> | <TYPE_UHUGEINT> | <TYPE_DECIMAL>
                     | <TYPE_VARCHAR> | <TYPE_TIME> | <TYPE_TIMESTAMP>
              ) >

    | <#TYPE_BIT:  "BISTRING">
    | <#TYPE_BLOB: "BLOB" | "BYTEA" | <K_BINARY> | "VARBINARY" | <K_BYTES> >
    | <#TYPE_BOOLEAN: <K_BOOLEAN> | "BOOL" >
    | <#TYPE_ENUM: "ENUM" >
    | <#TYPE_MAP: "MAP" >
    | <#TYPE_DECIMAL: "DECIMAL" | "NUMBER" | "NUMERIC" >
    | <#TYPE_TINYINT: "TINYINT" | "INT1" >
    | <#TYPE_SMALLINT: "SMALLINT" | "INT2" | "SHORT" >
    | <#TYPE_INTEGER: ( "INTEGER" | "INT" | "INT4" | <K_SIGNED> | <K_UNSIGNED> ) >
    | <#TYPE_BIGINT: "BIGINT" | "INT8" | "LONG" >
    | <#TYPE_HUGEINT: "HUGEINT" >
    | <#TYPE_UTINYINT: "UTINYINT" >
    | <#TYPE_USMALLINT: "USMALLINT" >
    | <#TYPE_UINTEGER: "UINTEGER" >
    | <#TYPE_UBIGINT: "UBIGINT" >
    | <#TYPE_UHUGEINT: "UHUGEINT" >
    | <#TYPE_REAL: "REAL" | "FLOAT4" | "FLOAT">
    | <#TYPE_DOUBLE: "DOUBLE" | "PRECISION"  | "FLOAT8" | "FLOAT64">
    | <#TYPE_VARCHAR: "NVARCHAR" | "VARCHAR" | "NCHAR" | <K_CHAR> | "BPCHAR" | "TEXT" | "STRING" | <K_CHARACTER> | "VARYING">
    | <#TYPE_TIME: "TIMETZ" >
    | <#TYPE_TIMESTAMP: "TIMESTAMP_NS" | "TIMESTAMP_MS" | "TIMESTAMP_S"  >

    | <#TYPE_UUID: "UUID">
}

TOKEN : /* Numeric Constants */
{
   < S_DOUBLE: ((<S_LONG>)? "." <S_LONG> ( ["e","E"] (["+", "-"])? <S_LONG>)?
            |
            <S_LONG> "." (["e","E"] (["+", "-"])? <S_LONG>)?
            |
            <S_LONG> ["e","E"] (["+", "-"])? <S_LONG>
            )>
  |     < S_LONG: ( <DIGIT> )+ >
  |     < #DIGIT: ["0" - "9"] >
  |     < S_HEX: ("X" ("'" ( <HEX_VALUE> )* "'" (" ")*)+ | "0x" ( <HEX_VALUE> )+ ) >
  |     < #HEX_VALUE: ["0"-"9","A"-"F", " "]  >
}

SPECIAL_TOKEN:
{
   < LINE_COMMENT: ("--" | "//") (~["\r","\n"])*>
|  < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN:
{
<S_PARAMETER: ["$"] (["0"-"9"])+ >
|
<S_IDENTIFIER: <LETTER> (<PART_LETTER>)*>
|   <#LETTER: <UnicodeIdentifierStart>
                | <Nd> | [ "$" , "#", "_" ] // Not SQL:2016 compliant!
                >
|   <#PART_LETTER: <UnicodeIdentifierStart> | <UnicodeIdentifierExtend> | [ "$" , "#", "_" , "@"  ] >
| <S_AT_IDENTIFIER: <K_AT_SIGN> (<K_AT_SIGN>)? <S_IDENTIFIER> >

// Unicode characters and categories are defined here: https://www.unicode.org/Public/UNIDATA/UnicodeData.txt
// SQL:2016 states:
// An <identifier start> is any character in the Unicode General Category classes “Lu”, “Ll”, “Lt”, “Lm”, “Lo”, or “Nl”.
// An <identifier extend> is U+00B7, “Middle Dot”, or any character in the Unicode General Category classes “Mn”, “Mc”, “Nd”, “Pc”, or “Cf”.

// unicode_identifier_start
| <#UnicodeIdentifierStart: ("\u00B7" | <Ll> | <Lm> | <Lo> | <Lt> | <Lu> | <Nl> |<CJK>) >
| <#Ll: ["a"-"z","µ","ß"-"ö","ø"-"ÿ","ā","ă","ą","ć","ĉ","ċ","č","ď","đ","ē","ĕ","ė","ę","ě","ĝ","ğ","ġ","ģ","ĥ","ħ","ĩ","ī","ĭ","į","ı","ĳ","ĵ","ķ"-"ĸ","ĺ","ļ","ľ","ŀ","ł","ń","ņ","ň"-"ŉ","ŋ","ō","ŏ","ő","œ","ŕ","ŗ","ř","ś","ŝ","ş","š","ţ","ť","ŧ","ũ","ū","ŭ","ů","ű","ų","ŵ","ŷ","ź","ż","ž"-"ƀ","ƃ","ƅ","ƈ","ƌ"-"ƍ","ƒ","ƕ","ƙ"-"ƛ","ƞ","ơ","ƣ","ƥ","ƨ","ƪ"-"ƫ","ƭ","ư","ƴ","ƶ","ƹ"-"ƺ","ƽ"-"ƿ","ǆ","ǉ","ǌ","ǎ","ǐ","ǒ","ǔ","ǖ","ǘ","ǚ","ǜ"-"ǝ","ǟ","ǡ","ǣ","ǥ","ǧ","ǩ","ǫ","ǭ","ǯ"-"ǰ","ǳ","ǵ","ǹ","ǻ","ǽ","ǿ","ȁ","ȃ","ȅ","ȇ","ȉ","ȋ","ȍ","ȏ","ȑ","ȓ","ȕ","ȗ","ș","ț","ȝ","ȟ","ȡ","ȣ","ȥ","ȧ","ȩ","ȫ","ȭ","ȯ","ȱ","ȳ"-"ȹ","ȼ","ȿ"-"ɀ","ɂ","ɇ","ɉ","ɋ","ɍ","ɏ"-"ʓ","ʕ"-"ʯ","ͱ","ͳ","ͷ","ͻ"-"ͽ","ΐ","ά"-"ώ","ϐ"-"ϑ","ϕ"-"ϗ","ϙ","ϛ","ϝ","ϟ","ϡ","ϣ","ϥ","ϧ","ϩ","ϫ","ϭ","ϯ"-"ϳ","ϵ","ϸ","ϻ"-"ϼ","а"-"џ","ѡ","ѣ","ѥ","ѧ","ѩ","ѫ","ѭ","ѯ","ѱ","ѳ","ѵ","ѷ","ѹ","ѻ","ѽ","ѿ","ҁ","ҋ","ҍ","ҏ","ґ","ғ","ҕ","җ","ҙ","қ","ҝ","ҟ","ҡ","ң","ҥ","ҧ","ҩ","ҫ","ҭ","ү","ұ","ҳ","ҵ","ҷ","ҹ","һ","ҽ","ҿ","ӂ","ӄ","ӆ","ӈ","ӊ","ӌ","ӎ"-"ӏ","ӑ","ӓ","ӕ","ӗ","ә","ӛ","ӝ","ӟ","ӡ","ӣ","ӥ","ӧ","ө","ӫ","ӭ","ӯ","ӱ","ӳ","ӵ","ӷ","ӹ","ӻ","ӽ","ӿ","ԁ","ԃ","ԅ","ԇ","ԉ","ԋ","ԍ","ԏ","ԑ","ԓ","ԕ","ԗ","ԙ","ԛ","ԝ","ԟ","ԡ","ԣ","ԥ","ԧ","ԩ","ԫ","ԭ","ԯ","ՠ"-"ֈ","ა"-"ჺ","ჽ"-"ჿ","ᏸ"-"ᏽ","ᲀ"-"ᲈ","ᴀ"-"ᴫ","ᵫ"-"ᵷ","ᵹ"-"ᶚ","ḁ","ḃ","ḅ","ḇ","ḉ","ḋ","ḍ","ḏ","ḑ","ḓ","ḕ","ḗ","ḙ","ḛ","ḝ","ḟ","ḡ","ḣ","ḥ","ḧ","ḩ","ḫ","ḭ","ḯ","ḱ","ḳ","ḵ","ḷ","ḹ","ḻ","ḽ","ḿ","ṁ","ṃ","ṅ","ṇ","ṉ","ṋ","ṍ","ṏ","ṑ","ṓ","ṕ","ṗ","ṙ","ṛ","ṝ","ṟ","ṡ","ṣ","ṥ","ṧ","ṩ","ṫ","ṭ","ṯ","ṱ","ṳ","ṵ","ṷ","ṹ","ṻ","ṽ","ṿ","ẁ","ẃ","ẅ","ẇ","ẉ","ẋ","ẍ","ẏ","ẑ","ẓ","ẕ"-"ẝ","ẟ","ạ","ả","ấ","ầ","ẩ","ẫ","ậ","ắ","ằ","ẳ","ẵ","ặ","ẹ","ẻ","ẽ","ế","ề","ể","ễ","ệ","ỉ","ị","ọ","ỏ","ố","ồ","ổ","ỗ","ộ","ớ","ờ","ở","ỡ","ợ","ụ","ủ","ứ","ừ","ử","ữ","ự","ỳ","ỵ","ỷ","ỹ","ỻ","ỽ","ỿ"-"ἇ","ἐ"-"ἕ","ἠ"-"ἧ","ἰ"-"ἷ","ὀ"-"ὅ","ὐ"-"ὗ","ὠ"-"ὧ","ὰ"-"ώ","ᾀ"-"ᾇ","ᾐ"-"ᾗ","ᾠ"-"ᾧ","ᾰ"-"ᾴ","ᾶ"-"ᾷ","ι","ῂ"-"ῄ","ῆ"-"ῇ","ῐ"-"ΐ","ῖ"-"ῗ","ῠ"-"ῧ","ῲ"-"ῴ","ῶ"-"ῷ","ℊ","ℎ"-"ℏ","ℓ","ℯ","ℴ","ℹ","ℼ"-"ℽ","ⅆ"-"ⅉ","ⅎ","ↄ","ⰰ"-"ⱟ","ⱡ","ⱥ"-"ⱦ","ⱨ","ⱪ","ⱬ","ⱱ","ⱳ"-"ⱴ","ⱶ"-"ⱻ","ⲁ","ⲃ","ⲅ","ⲇ","ⲉ","ⲋ","ⲍ","ⲏ","ⲑ","ⲓ","ⲕ","ⲗ","ⲙ","ⲛ","ⲝ","ⲟ","ⲡ","ⲣ","ⲥ","ⲧ","ⲩ","ⲫ","ⲭ","ⲯ","ⲱ","ⲳ","ⲵ","ⲷ","ⲹ","ⲻ","ⲽ","ⲿ","ⳁ","ⳃ","ⳅ","ⳇ","ⳉ","ⳋ","ⳍ","ⳏ","ⳑ","ⳓ","ⳕ","ⳗ","ⳙ","ⳛ","ⳝ","ⳟ","ⳡ","ⳣ"-"ⳤ","ⳬ","ⳮ","ⳳ","ⴀ"-"ⴥ","ⴧ","ⴭ","ꙁ","ꙃ","ꙅ","ꙇ","ꙉ","ꙋ","ꙍ","ꙏ","ꙑ","ꙓ","ꙕ","ꙗ","ꙙ","ꙛ","ꙝ","ꙟ","ꙡ","ꙣ","ꙥ","ꙧ","ꙩ","ꙫ","ꙭ","ꚁ","ꚃ","ꚅ","ꚇ","ꚉ","ꚋ","ꚍ","ꚏ","ꚑ","ꚓ","ꚕ","ꚗ","ꚙ","ꚛ","ꜣ","ꜥ","ꜧ","ꜩ","ꜫ","ꜭ","ꜯ"-"ꜱ","ꜳ","ꜵ","ꜷ","ꜹ","ꜻ","ꜽ","ꜿ","ꝁ","ꝃ","ꝅ","ꝇ","ꝉ","ꝋ","ꝍ","ꝏ","ꝑ","ꝓ","ꝕ","ꝗ","ꝙ","ꝛ","ꝝ","ꝟ","ꝡ","ꝣ","ꝥ","ꝧ","ꝩ","ꝫ","ꝭ","ꝯ","ꝱ"-"ꝸ","ꝺ","ꝼ","ꝿ","ꞁ","ꞃ","ꞅ","ꞇ","ꞌ","ꞎ","ꞑ","ꞓ"-"ꞕ","ꞗ","ꞙ","ꞛ","ꞝ","ꞟ","ꞡ","ꞣ","ꞥ","ꞧ","ꞩ","ꞯ","ꞵ","ꞷ","ꞹ","ꞻ","ꞽ","ꞿ","ꟁ","ꟃ","ꟈ","ꟊ","ꟑ","ꟓ","ꟕ","ꟗ","ꟙ","ꟶ","ꟺ","ꬰ"-"ꭚ","ꭠ"-"ꭨ","ꭰ"-"ꮿ","ﬀ"-"ﬆ","ﬓ"-"ﬗ","ａ"-"ｚ"]>
| <#Lm: ["ʰ"-"ˁ","ˆ"-"ˑ","ˠ"-"ˤ","ˬ","ˮ","ʹ","ͺ","ՙ","ـ","ۥ"-"ۦ","ߴ"-"ߵ","ߺ","ࠚ","ࠤ","ࠨ","ࣉ","ॱ","ๆ","ໆ","ჼ","ៗ","ᡃ","ᪧ","ᱸ"-"ᱽ","ᴬ"-"ᵪ","ᵸ","ᶛ"-"ᶿ","ⁱ","ⁿ","ₐ"-"ₜ","ⱼ"-"ⱽ","ⵯ","ⸯ","々","〱"-"〵","〻","ゝ"-"ゞ","ー"-"ヾ","ꀕ","ꓸ"-"ꓽ","ꘌ","ꙿ","ꚜ"-"ꚝ","ꜗ"-"ꜟ","ꝰ","ꞈ","ꟲ"-"ꟴ","ꟸ"-"ꟹ","ꧏ","ꧦ","ꩰ","ꫝ","ꫳ"-"ꫴ","ꭜ"-"ꭟ","ꭩ","ｰ","ﾞ"-"ﾟ"]>
| <#Lo: ["ª","º","ƻ","ǀ"-"ǃ","ʔ","א"-"ת","ׯ"-"ײ","ؠ"-"ؿ","ف"-"ي","ٮ"-"ٯ","ٱ"-"ۓ","ە","ۮ"-"ۯ","ۺ"-"ۼ","ۿ","ܐ","ܒ"-"ܯ","ݍ"-"ޥ","ޱ","ߊ"-"ߪ","ࠀ"-"ࠕ","ࡀ"-"ࡘ","ࡠ"-"ࡪ","ࡰ"-"ࢇ","ࢉ"-"ࢎ","ࢠ"-"ࣈ","ऄ"-"ह","ऽ","ॐ","क़"-"ॡ","ॲ"-"ঀ","অ"-"ঌ","এ"-"ঐ","ও"-"ন","প"-"র","ল","শ"-"হ","ঽ","ৎ","ড়"-"ঢ়","য়"-"ৡ","ৰ"-"ৱ","ৼ","ਅ"-"ਊ","ਏ"-"ਐ","ਓ"-"ਨ","ਪ"-"ਰ","ਲ"-"ਲ਼","ਵ"-"ਸ਼","ਸ"-"ਹ","ਖ਼"-"ੜ","ਫ਼","ੲ"-"ੴ","અ"-"ઍ","એ"-"ઑ","ઓ"-"ન","પ"-"ર","લ"-"ળ","વ"-"હ","ઽ","ૐ","ૠ"-"ૡ","ૹ","ଅ"-"ଌ","ଏ"-"ଐ","ଓ"-"ନ","ପ"-"ର","ଲ"-"ଳ","ଵ"-"ହ","ଽ","ଡ଼"-"ଢ଼","ୟ"-"ୡ","ୱ","ஃ","அ"-"ஊ","எ"-"ஐ","ஒ"-"க","ங"-"ச","ஜ","ஞ"-"ட","ண"-"த","ந"-"ப","ம"-"ஹ","ௐ","అ"-"ఌ","ఎ"-"ఐ","ఒ"-"న","ప"-"హ","ఽ","ౘ"-"ౚ","ౝ","ౠ"-"ౡ","ಀ","ಅ"-"ಌ","ಎ"-"ಐ","ಒ"-"ನ","ಪ"-"ಳ","ವ"-"ಹ","ಽ","ೝ"-"ೞ","ೠ"-"ೡ","ೱ"-"ೲ","ഄ"-"ഌ","എ"-"ഐ","ഒ"-"ഺ","ഽ","ൎ","ൔ"-"ൖ","ൟ"-"ൡ","ൺ"-"ൿ","අ"-"ඖ","ක"-"න","ඳ"-"ර","ල","ව"-"ෆ","ก"-"ะ","า"-"ำ","เ"-"ๅ","ກ"-"ຂ","ຄ","ຆ"-"ຊ","ຌ"-"ຣ","ລ","ວ"-"ະ","າ"-"ຳ","ຽ","ເ"-"ໄ","ໜ"-"ໟ","ༀ","ཀ"-"ཇ","ཉ"-"ཬ","ྈ"-"ྌ","က"-"ဪ","ဿ","ၐ"-"ၕ","ၚ"-"ၝ","ၡ","ၥ"-"ၦ","ၮ"-"ၰ","ၵ"-"ႁ","ႎ","ᄀ"-"ቈ","ቊ"-"ቍ","ቐ"-"ቖ","ቘ","ቚ"-"ቝ","በ"-"ኈ","ኊ"-"ኍ","ነ"-"ኰ","ኲ"-"ኵ","ኸ"-"ኾ","ዀ","ዂ"-"ዅ","ወ"-"ዖ","ዘ"-"ጐ","ጒ"-"ጕ","ጘ"-"ፚ","ᎀ"-"ᎏ","ᐁ"-"ᙬ","ᙯ"-"ᙿ","ᚁ"-"ᚚ","ᚠ"-"ᛪ","ᛱ"-"ᛸ","ᜀ"-"ᜑ","ᜟ"-"ᜱ","ᝀ"-"ᝑ","ᝠ"-"ᝬ","ᝮ"-"ᝰ","ក"-"ឳ","ៜ","ᠠ"-"ᡂ","ᡄ"-"ᡸ","ᢀ"-"ᢄ","ᢇ"-"ᢨ","ᢪ","ᢰ"-"ᣵ","ᤀ"-"ᤞ","ᥐ"-"ᥭ","ᥰ"-"ᥴ","ᦀ"-"ᦫ","ᦰ"-"ᧉ","ᨀ"-"ᨖ","ᨠ"-"ᩔ","ᬅ"-"ᬳ","ᭅ"-"ᭌ","ᮃ"-"ᮠ","ᮮ"-"ᮯ","ᮺ"-"ᯥ","ᰀ"-"ᰣ","ᱍ"-"ᱏ","ᱚ"-"ᱷ","ᳩ"-"ᳬ","ᳮ"-"ᳳ","ᳵ"-"ᳶ","ᳺ","ℵ"-"ℸ","ⴰ"-"ⵧ","ⶀ"-"ⶖ","ⶠ"-"ⶦ","ⶨ"-"ⶮ","ⶰ"-"ⶶ","ⶸ"-"ⶾ","ⷀ"-"ⷆ","ⷈ"-"ⷎ","ⷐ"-"ⷖ","ⷘ"-"ⷞ","〆","〼","ぁ"-"ゖ","ゟ","ァ"-"ヺ","ヿ","ㄅ"-"ㄯ","ㄱ"-"ㆎ","ㆠ"-"ㆿ","ㇰ"-"ㇿ","䶿","鿿"-"ꀔ","ꀖ"-"ꒌ","ꓐ"-"ꓷ","ꔀ"-"ꘋ","ꘐ"-"ꘟ","ꘪ"-"ꘫ","ꙮ","ꚠ"-"ꛥ","ꞏ","ꟷ","ꟻ"-"ꠁ","ꠃ"-"ꠅ","ꠇ"-"ꠊ","ꠌ"-"ꠢ","ꡀ"-"ꡳ","ꢂ"-"ꢳ","ꣲ"-"ꣷ","ꣻ","ꣽ"-"ꣾ","ꤊ"-"ꤥ","ꤰ"-"ꥆ","ꥠ"-"ꥼ","ꦄ"-"ꦲ","ꧠ"-"ꧤ","ꧧ"-"ꧯ","ꧺ"-"ꧾ","ꨀ"-"ꨨ","ꩀ"-"ꩂ","ꩄ"-"ꩋ","ꩠ"-"ꩯ","ꩱ"-"ꩶ","ꩺ","ꩾ"-"ꪯ","ꪱ","ꪵ"-"ꪶ","ꪹ"-"ꪽ","ꫀ","ꫂ","ꫛ"-"ꫜ","ꫠ"-"ꫪ","ꫲ","ꬁ"-"ꬆ","ꬉ"-"ꬎ","ꬑ"-"ꬖ","ꬠ"-"ꬦ","ꬨ"-"ꬮ","ꯀ"-"ꯢ","힣","ힰ"-"ퟆ","ퟋ"-"ퟻ","豈"-"舘","並"-"龎","יִ","ײַ"-"ﬨ","שׁ"-"זּ","טּ"-"לּ","מּ","נּ"-"סּ","ףּ"-"פּ","צּ"-"ﮱ","ﯓ"-"ﴽ","ﵐ"-"ﶏ","ﶒ"-"ﷇ","ﷰ"-"ﷻ","ﹰ"-"ﹴ","ﹶ"-"ﻼ","ｦ"-"ｯ","ｱ"-"ﾝ","ﾠ"-"ﾾ","ￂ"-"ￇ","ￊ"-"ￏ","ￒ"-"ￗ","ￚ"-"ￜ"]>
| <#Lt: ["ǅ","ǈ","ǋ","ǲ","ᾈ"-"ᾏ","ᾘ"-"ᾟ","ᾨ"-"ᾯ","ᾼ","ῌ","ῼ"]>
| <#Lu: ["A"-"Z","À"-"Ö","Ø"-"Þ","Ā","Ă","Ą","Ć","Ĉ","Ċ","Č","Ď","Đ","Ē","Ĕ","Ė","Ę","Ě","Ĝ","Ğ","Ġ","Ģ","Ĥ","Ħ","Ĩ","Ī","Ĭ","Į","İ","Ĳ","Ĵ","Ķ","Ĺ","Ļ","Ľ","Ŀ","Ł","Ń","Ņ","Ň","Ŋ","Ō","Ŏ","Ő","Œ","Ŕ","Ŗ","Ř","Ś","Ŝ","Ş","Š","Ţ","Ť","Ŧ","Ũ","Ū","Ŭ","Ů","Ű","Ų","Ŵ","Ŷ","Ÿ"-"Ź","Ż","Ž","Ɓ"-"Ƃ","Ƅ","Ɔ"-"Ƈ","Ɖ"-"Ƌ","Ǝ"-"Ƒ","Ɠ"-"Ɣ","Ɩ"-"Ƙ","Ɯ"-"Ɲ","Ɵ"-"Ơ","Ƣ","Ƥ","Ʀ"-"Ƨ","Ʃ","Ƭ","Ʈ"-"Ư","Ʊ"-"Ƴ","Ƶ","Ʒ"-"Ƹ","Ƽ","Ǆ","Ǉ","Ǌ","Ǎ","Ǐ","Ǒ","Ǔ","Ǖ","Ǘ","Ǚ","Ǜ","Ǟ","Ǡ","Ǣ","Ǥ","Ǧ","Ǩ","Ǫ","Ǭ","Ǯ","Ǳ","Ǵ","Ƕ"-"Ǹ","Ǻ","Ǽ","Ǿ","Ȁ","Ȃ","Ȅ","Ȇ","Ȉ","Ȋ","Ȍ","Ȏ","Ȑ","Ȓ","Ȕ","Ȗ","Ș","Ț","Ȝ","Ȟ","Ƞ","Ȣ","Ȥ","Ȧ","Ȩ","Ȫ","Ȭ","Ȯ","Ȱ","Ȳ","Ⱥ"-"Ȼ","Ƚ"-"Ⱦ","Ɂ","Ƀ"-"Ɇ","Ɉ","Ɋ","Ɍ","Ɏ","Ͱ","Ͳ","Ͷ","Ϳ","Ά","Έ"-"Ί","Ό","Ύ"-"Ώ","Α"-"Ρ","Σ"-"Ϋ","Ϗ","ϒ"-"ϔ","Ϙ","Ϛ","Ϝ","Ϟ","Ϡ","Ϣ","Ϥ","Ϧ","Ϩ","Ϫ","Ϭ","Ϯ","ϴ","Ϸ","Ϲ"-"Ϻ","Ͻ"-"Я","Ѡ","Ѣ","Ѥ","Ѧ","Ѩ","Ѫ","Ѭ","Ѯ","Ѱ","Ѳ","Ѵ","Ѷ","Ѹ","Ѻ","Ѽ","Ѿ","Ҁ","Ҋ","Ҍ","Ҏ","Ґ","Ғ","Ҕ","Җ","Ҙ","Қ","Ҝ","Ҟ","Ҡ","Ң","Ҥ","Ҧ","Ҩ","Ҫ","Ҭ","Ү","Ұ","Ҳ","Ҵ","Ҷ","Ҹ","Һ","Ҽ","Ҿ","Ӏ"-"Ӂ","Ӄ","Ӆ","Ӈ","Ӊ","Ӌ","Ӎ","Ӑ","Ӓ","Ӕ","Ӗ","Ә","Ӛ","Ӝ","Ӟ","Ӡ","Ӣ","Ӥ","Ӧ","Ө","Ӫ","Ӭ","Ӯ","Ӱ","Ӳ","Ӵ","Ӷ","Ӹ","Ӻ","Ӽ","Ӿ","Ԁ","Ԃ","Ԅ","Ԇ","Ԉ","Ԋ","Ԍ","Ԏ","Ԑ","Ԓ","Ԕ","Ԗ","Ԙ","Ԛ","Ԝ","Ԟ","Ԡ","Ԣ","Ԥ","Ԧ","Ԩ","Ԫ","Ԭ","Ԯ","Ա"-"Ֆ","Ⴀ"-"Ⴥ","Ⴧ","Ⴭ","Ꭰ"-"Ᏽ","Ა"-"Ჺ","Ჽ"-"Ჿ","Ḁ","Ḃ","Ḅ","Ḇ","Ḉ","Ḋ","Ḍ","Ḏ","Ḑ","Ḓ","Ḕ","Ḗ","Ḙ","Ḛ","Ḝ","Ḟ","Ḡ","Ḣ","Ḥ","Ḧ","Ḩ","Ḫ","Ḭ","Ḯ","Ḱ","Ḳ","Ḵ","Ḷ","Ḹ","Ḻ","Ḽ","Ḿ","Ṁ","Ṃ","Ṅ","Ṇ","Ṉ","Ṋ","Ṍ","Ṏ","Ṑ","Ṓ","Ṕ","Ṗ","Ṙ","Ṛ","Ṝ","Ṟ","Ṡ","Ṣ","Ṥ","Ṧ","Ṩ","Ṫ","Ṭ","Ṯ","Ṱ","Ṳ","Ṵ","Ṷ","Ṹ","Ṻ","Ṽ","Ṿ","Ẁ","Ẃ","Ẅ","Ẇ","Ẉ","Ẋ","Ẍ","Ẏ","Ẑ","Ẓ","Ẕ","ẞ","Ạ","Ả","Ấ","Ầ","Ẩ","Ẫ","Ậ","Ắ","Ằ","Ẳ","Ẵ","Ặ","Ẹ","Ẻ","Ẽ","Ế","Ề","Ể","Ễ","Ệ","Ỉ","Ị","Ọ","Ỏ","Ố","Ồ","Ổ","Ỗ","Ộ","Ớ","Ờ","Ở","Ỡ","Ợ","Ụ","Ủ","Ứ","Ừ","Ử","Ữ","Ự","Ỳ","Ỵ","Ỷ","Ỹ","Ỻ","Ỽ","Ỿ","Ἀ"-"Ἇ","Ἐ"-"Ἕ","Ἠ"-"Ἧ","Ἰ"-"Ἷ","Ὀ"-"Ὅ","Ὑ","Ὓ","Ὕ","Ὗ","Ὠ"-"Ὧ","Ᾰ"-"Ά","Ὲ"-"Ή","Ῐ"-"Ί","Ῠ"-"Ῥ","Ὸ"-"Ώ","ℂ","ℇ","ℋ"-"ℍ","ℐ"-"ℒ","ℕ","ℙ"-"ℝ","ℤ","Ω","ℨ","K"-"ℭ","ℰ"-"ℳ","ℾ"-"ℿ","ⅅ","Ↄ","Ⰰ"-"Ⱟ","Ⱡ","Ɫ"-"Ɽ","Ⱨ","Ⱪ","Ⱬ","Ɑ"-"Ɒ","Ⱳ","Ⱶ","Ȿ"-"Ⲁ","Ⲃ","Ⲅ","Ⲇ","Ⲉ","Ⲋ","Ⲍ","Ⲏ","Ⲑ","Ⲓ","Ⲕ","Ⲗ","Ⲙ","Ⲛ","Ⲝ","Ⲟ","Ⲡ","Ⲣ","Ⲥ","Ⲧ","Ⲩ","Ⲫ","Ⲭ","Ⲯ","Ⲱ","Ⲳ","Ⲵ","Ⲷ","Ⲹ","Ⲻ","Ⲽ","Ⲿ","Ⳁ","Ⳃ","Ⳅ","Ⳇ","Ⳉ","Ⳋ","Ⳍ","Ⳏ","Ⳑ","Ⳓ","Ⳕ","Ⳗ","Ⳙ","Ⳛ","Ⳝ","Ⳟ","Ⳡ","Ⳣ","Ⳬ","Ⳮ","Ⳳ","Ꙁ","Ꙃ","Ꙅ","Ꙇ","Ꙉ","Ꙋ","Ꙍ","Ꙏ","Ꙑ","Ꙓ","Ꙕ","Ꙗ","Ꙙ","Ꙛ","Ꙝ","Ꙟ","Ꙡ","Ꙣ","Ꙥ","Ꙧ","Ꙩ","Ꙫ","Ꙭ","Ꚁ","Ꚃ","Ꚅ","Ꚇ","Ꚉ","Ꚋ","Ꚍ","Ꚏ","Ꚑ","Ꚓ","Ꚕ","Ꚗ","Ꚙ","Ꚛ","Ꜣ","Ꜥ","Ꜧ","Ꜩ","Ꜫ","Ꜭ","Ꜯ","Ꜳ","Ꜵ","Ꜷ","Ꜹ","Ꜻ","Ꜽ","Ꜿ","Ꝁ","Ꝃ","Ꝅ","Ꝇ","Ꝉ","Ꝋ","Ꝍ","Ꝏ","Ꝑ","Ꝓ","Ꝕ","Ꝗ","Ꝙ","Ꝛ","Ꝝ","Ꝟ","Ꝡ","Ꝣ","Ꝥ","Ꝧ","Ꝩ","Ꝫ","Ꝭ","Ꝯ","Ꝺ","Ꝼ","Ᵹ"-"Ꝿ","Ꞁ","Ꞃ","Ꞅ","Ꞇ","Ꞌ","Ɥ","Ꞑ","Ꞓ","Ꞗ","Ꞙ","Ꞛ","Ꞝ","Ꞟ","Ꞡ","Ꞣ","Ꞥ","Ꞧ","Ꞩ","Ɦ"-"Ɪ","Ʞ"-"Ꞵ","Ꞷ","Ꞹ","Ꞻ","Ꞽ","Ꞿ","Ꟁ","Ꟃ","Ꞔ"-"Ꟈ","Ꟊ","Ꟑ","Ꟗ","Ꟙ","Ꟶ","Ａ"-"Ｚ"]>
| <#Nl: ["ᛮ"-"ᛰ","Ⅰ"-"ↂ","ↅ"-"ↈ","〇","〡"-"〩","〸"-"〺","ꛦ"-"ꛯ"]>

// unicode_identifier_extend
| <#UnicodeIdentifierExtend: (<Mn>|<Mc>|<Nd>|<Pc>|<Cf>|<CJK>)>
| <#Cf: ["­","؀"-"؅","؜","۝","܏","࢐"-"࢑","࣢","᠎","​"-"‏","‪"-"‮","⁠"-"⁤","⁦"-"⁯","﻿","￹"-"￻"]>
| <#Mc: ["ः","ऻ","ा"-"ी","ॉ"-"ौ","ॎ"-"ॏ","ং"-"ঃ","া"-"ী","ে"-"ৈ","ো"-"ৌ","ৗ","ਃ","ਾ"-"ੀ","ઃ","ા"-"ી","ૉ","ો"-"ૌ","ଂ"-"ଃ","ା","ୀ","େ"-"ୈ","ୋ"-"ୌ","ୗ","ா"-"ி","ு"-"ூ","ெ"-"ை","ொ"-"ௌ","ௗ","ఁ"-"ః","ు"-"ౄ","ಂ"-"ಃ","ಾ","ೀ"-"ೄ","ೇ"-"ೈ","ೊ"-"ೋ","ೕ"-"ೖ","ೳ","ം"-"ഃ","ാ"-"ീ","െ"-"ൈ","ൊ"-"ൌ","ൗ","ං"-"ඃ","ා"-"ෑ","ෘ"-"ෟ","ෲ"-"ෳ","༾"-"༿","ཿ","ါ"-"ာ","ေ","း","ျ"-"ြ","ၖ"-"ၗ","ၢ"-"ၤ","ၧ"-"ၭ","ႃ"-"ႄ","ႇ"-"ႌ","ႏ","ႚ"-"ႜ","᜕","᜴","ា","ើ"-"ៅ","ះ"-"ៈ","ᤣ"-"ᤦ","ᤩ"-"ᤫ","ᤰ"-"ᤱ","ᤳ"-"ᤸ","ᨙ"-"ᨚ","ᩕ","ᩗ","ᩡ","ᩣ"-"ᩤ","ᩭ"-"ᩲ","ᬄ","ᬵ","ᬻ","ᬽ"-"ᭁ","ᭃ"-"᭄","ᮂ","ᮡ","ᮦ"-"ᮧ","᮪","ᯧ","ᯪ"-"ᯬ","ᯮ","᯲"-"᯳","ᰤ"-"ᰫ","ᰴ"-"ᰵ","᳡","᳷","〮"-"〯","ꠣ"-"ꠤ","ꠧ","ꢀ"-"ꢁ","ꢴ"-"ꣃ","ꥒ"-"꥓","ꦃ","ꦴ"-"ꦵ","ꦺ"-"ꦻ","ꦾ"-"꧀","ꨯ"-"ꨰ","ꨳ"-"ꨴ","ꩍ","ꩻ","ꩽ","ꫫ","ꫮ"-"ꫯ","ꫵ","ꯣ"-"ꯤ","ꯦ"-"ꯧ","ꯩ"-"ꯪ","꯬"]>
| <#Mn: ["̀"-"ͯ","҃"-"҇","֑"-"ֽ","ֿ","ׁ"-"ׂ","ׄ"-"ׅ","ׇ","ؐ"-"ؚ","ً"-"ٟ","ٰ","ۖ"-"ۜ","۟"-"ۤ","ۧ"-"ۨ","۪"-"ۭ","ܑ","ܰ"-"݊","ަ"-"ް","߫"-"߳","߽","ࠖ"-"࠙","ࠛ"-"ࠣ","ࠥ"-"ࠧ","ࠩ"-"࠭","࡙"-"࡛","࢘"-"࢟","࣊"-"࣡","ࣣ"-"ं","ऺ","़","ु"-"ै","्","॑"-"ॗ","ॢ"-"ॣ","ঁ","়","ু"-"ৄ","্","ৢ"-"ৣ","৾","ਁ"-"ਂ","਼","ੁ"-"ੂ","ੇ"-"ੈ","ੋ"-"੍","ੑ","ੰ"-"ੱ","ੵ","ઁ"-"ં","઼","ુ"-"ૅ","ે"-"ૈ","્","ૢ"-"ૣ","ૺ"-"૿","ଁ","଼","ି","ୁ"-"ୄ","୍","୕"-"ୖ","ୢ"-"ୣ","ஂ","ீ","்","ఀ","ఄ","఼","ా"-"ీ","ె"-"ై","ొ"-"్","ౕ"-"ౖ","ౢ"-"ౣ","ಁ","಼","ಿ","ೆ","ೌ"-"್","ೢ"-"ೣ","ഀ"-"ഁ","഻"-"഼","ു"-"ൄ","്","ൢ"-"ൣ","ඁ","්","ි"-"ු","ූ","ั","ิ"-"ฺ","็"-"๎","ັ","ິ"-"ຼ","່"-"໎","༘"-"༙","༵","༷","༹","ཱ"-"ཾ","ྀ"-"྄","྆"-"྇","ྍ"-"ྗ","ྙ"-"ྼ","࿆","ိ"-"ူ","ဲ"-"့","္"-"်","ွ"-"ှ","ၘ"-"ၙ","ၞ"-"ၠ","ၱ"-"ၴ","ႂ","ႅ"-"ႆ","ႍ","ႝ","፝"-"፟","ᜒ"-"᜔","ᜲ"-"ᜳ","ᝒ"-"ᝓ","ᝲ"-"ᝳ","឴"-"឵","ិ"-"ួ","ំ","៉"-"៓","៝","᠋"-"᠍","᠏","ᢅ"-"ᢆ","ᢩ","ᤠ"-"ᤢ","ᤧ"-"ᤨ","ᤲ","᤹"-"᤻","ᨗ"-"ᨘ","ᨛ","ᩖ","ᩘ"-"ᩞ","᩠","ᩢ","ᩥ"-"ᩬ","ᩳ"-"᩼","᩿","᪰"-"᪽","ᪿ"-"ᫎ","ᬀ"-"ᬃ","᬴","ᬶ"-"ᬺ","ᬼ","ᭂ","᭫"-"᭳","ᮀ"-"ᮁ","ᮢ"-"ᮥ","ᮨ"-"ᮩ","᮫"-"ᮭ","᯦","ᯨ"-"ᯩ","ᯭ","ᯯ"-"ᯱ","ᰬ"-"ᰳ","ᰶ"-"᰷","᳐"-"᳒","᳔"-"᳠","᳢"-"᳨","᳭","᳴","᳸"-"᳹","᷀"-"᷿","⃐"-"⃜","⃡","⃥"-"⃰","⳯"-"⳱","⵿","ⷠ"-"ⷿ","〪"-"〭","゙"-"゚","꙯","ꙴ"-"꙽","ꚞ"-"ꚟ","꛰"-"꛱","ꠂ","꠆","ꠋ","ꠥ"-"ꠦ","꠬","꣄"-"ꣅ","꣠"-"꣱","ꣿ","ꤦ"-"꤭","ꥇ"-"ꥑ","ꦀ"-"ꦂ","꦳","ꦶ"-"ꦹ","ꦼ"-"ꦽ","ꧥ","ꨩ"-"ꨮ","ꨱ"-"ꨲ","ꨵ"-"ꨶ","ꩃ","ꩌ","ꩼ","ꪰ","ꪲ"-"ꪴ","ꪷ"-"ꪸ","ꪾ"-"꪿","꫁","ꫬ"-"ꫭ","꫶","ꯥ","ꯨ","꯭","ﬞ","︀"-"️","︠"-"︯"]>
| <#Nd: ["0"-"9","٠"-"٩","۰"-"۹","߀"-"߉","०"-"९","০"-"৯","੦"-"੯","૦"-"૯","୦"-"୯","௦"-"௯","౦"-"౯","೦"-"೯","൦"-"൯","෦"-"෯","๐"-"๙","໐"-"໙","༠"-"༩","၀"-"၉","႐"-"႙","០"-"៩","᠐"-"᠙","᥆"-"᥏","᧐"-"᧙","᪀"-"᪉","᪐"-"᪙","᭐"-"᭙","᮰"-"᮹","᱀"-"᱉","᱐"-"᱙","꘠"-"꘩","꣐"-"꣙","꤀"-"꤉","꧐"-"꧙","꧰"-"꧹","꩐"-"꩙","꯰"-"꯹","０"-"９"]>
| <#Pc: ["‿"-"⁀","⁔","︳"-"︴","﹍"-"﹏","＿"]>

// CJK Unified Ideographs block according to https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)
| <#CJK: ["\uAC00"-"\uD7A3", "\u4E00"-"\u9FFF"]>

| < #SPECIAL_ESC: "\\'" > /* Allowing this will break LIKE ... ESCAPE ...  */
| < #ESC: "\\" ["n","t","b","r","f","\\","\""] >
| < S_CHAR_LITERAL: (
                        (["U","E","N","R","B"]|"RB"|"_utf8")?
                        (
                            ("'" ( <ESC> | <SPECIAL_ESC> | ~["'", "\\"] )* "'") | ("'" ("''" | ~["'"])* "'" | "$$" (~["$"])* "$$")
                            // Alternative Oracle Escape Modes
                            | ("q'{" (~[])* "}'")
                            | ("q'(" (~[])* ")'")
                            | ("q'[" (~[])* "]'")
                            | ("q''" (~[])* "''")
                            // | ("q'\\" (~[])* "\\'") <--- Does not work
                        )
                     ) >
    {
        // <S_CHAR_LITERAL> contains the <SPECIAL_ESC> token and always the longest match is returned
        // So when Backslash is explicitly not allowed as an Escape Character and a <S_CHAR_LITERAL> is found
        // which contains the <SPECIAL_ESC>, then we will need to
        // 1) break the <S_CHAR_LITERAL> at <SPECIAL_ESC> close it with a "'"
        // 2) continue tokenizing after that <SPECIAL_ESC> with a new <S_CHAR_LITERAL> or any other Token
        boolean allowEscape = configuration.getAsBoolean(Feature.allowBackslashEscapeCharacter);
                String img = matchedToken.image;
                int pos;
                if (!allowEscape) {
                    pos = indexOfSequence(img, "\\'");
                    if (pos > 0) {
                        matchedToken.image = "'" + image.substring( 0, image.indexOf("\\'") + 1 ) + "'";
                        // `charLiteralIndex` defined in TokenManagerDeclaration above
                        matchedToken.kind = charLiteralIndex;
                        input_stream.backup(image.length() + 1 - matchedToken.image.length());
                    }
                } else {
                    pos = lastIndexOfSequence(img, "\\''");
                    if (pos > 0) {
                        matchedToken.image = "'" + image.substring( 0, image.lastIndexOf("\\'") + 3);
                        // `charLiteralIndex` defined in TokenManagerDeclaration above
                        matchedToken.kind = charLiteralIndex;
                        input_stream.backup(image.length() + 1 - matchedToken.image.length() );
                    }
                }
    }
| < S_QUOTED_IDENTIFIER: "\"" ( "\"\"" | ~["\n","\r","\""])* "\"" | ("`" (~["\n","\r","`"])+ "`") | ( "[" (~["\n","\r","]"])* "]" ) >
    {
        if ( !configuration.getAsBoolean(Feature.allowSquareBracketQuotation)
            && matchedToken.image.charAt(0) == '[' ) {

            matchedToken.image = "[";
            // `squaredBracketOpenIndex` defined in TokenManagerDeclaration above
            matchedToken.kind = squaredBracketOpenIndex;
            input_stream.backup(image.length() - 1);
        }
    }
}

/**
 * Parses identifiers including standard SQL identifiers, quoted identifiers, and specific keywords.
 *
 * This is used in cases where certain SQL keywords (like NAME, NEXT, VALUE, etc.) can appear
 * as identifiers (e.g., table names, column names) depending on the SQL dialect or context.
 *
 * Supported tokens:
 *  - <S_IDENTIFIER>: Standard unquoted SQL identifier
 *  - <S_QUOTED_IDENTIFIER>: Quoted identifier (e.g., `identifier` or "identifier")
 *  - <K_NAME>, <K_NEXT>, <K_VALUE>, <K_PUBLIC>, <K_STRING>, <K_DATA>: Specific keywords treated as identifiers
 *
 * @return Token representing the identifier or keyword used as identifier
 */
Token KeywordOrIdentifier():
{
    Token tk;
}
{
    (
        tk = <S_IDENTIFIER>
      | tk = <S_QUOTED_IDENTIFIER>
      | tk = <K_NAME>
      | tk = <K_NEXT>
      | tk = <K_VALUE>
      | tk = <K_PUBLIC>
      | tk = <K_STRING>
      | tk = <K_DATA>
    )
    { return tk; }
}

Statement Statement() #Statement:
{
    IfElseStatement ifElseStatement = null;
    Statement stm = null;
    Statement stm2 = null;
    Expression condition;
}
{
    (
         try {
            (
                 <K_IF> condition=Condition()
                 ( stm = SingleStatement() | stm = Block() ) {  ifElseStatement = new IfElseStatement(condition, stm); }
                 [ LOOKAHEAD(2)
                     [ <ST_SEMICOLON> { ifElseStatement.setUsingSemicolonForIfStatement(true); } ]
                     <K_ELSE> ( stm2 = SingleStatement() |  stm2 =  Block() ) {  ifElseStatement.setElseStatement(stm2);  }
                 ]

                 [
                     LOOKAHEAD(2) <ST_SEMICOLON>
                     { if (stm2!=null)
                           ifElseStatement.setUsingSemicolonForElseStatement(true);
                        else if (ifElseStatement!=null)
                           ifElseStatement.setUsingSemicolonForIfStatement(true);
                     }
                 ]
            )
            |
            (
                (stm = SingleStatement()
                    | stm = Block())

                ( <ST_SEMICOLON> | <EOF> )
            )
            |
            LOOKAHEAD( { stm==null && getAsBoolean(Feature.allowUnsupportedStatements) } ) stm = UnsupportedStatement()
         } catch (ParseException ex) {
            if ( getAsBoolean(Feature.allowUnsupportedStatements) ) {
                stm = new UnsupportedStatement( stm.toString(), error_skipto(ST_SEMICOLON) );
            } else if ( errorRecovery ) {
                parseErrors.add(ex);
                error_skipto(ST_SEMICOLON);
                stm = null;
            } else {
                throw ex;
            }
         }

    )

	{
		return ifElseStatement!=null ? ifElseStatement : stm;
	}
}

Statement SingleStatement() :
{
    Statement stm = null;
    List<WithItem<?>> with = null;
}
{
        (
           LOOKAHEAD(3) (
                [ LOOKAHEAD(2) with=WithList() ]
                (
                    stm = SelectWithWithItems( with )
                    |
                    stm = InsertWithWithItems( with )
                    |
                    stm = UpdateWithWithItems( with )
                    |
                    stm = DeleteWithWithItems( with )
                    |
                    stm = Merge( with )
                )
            )
            |
            stm = Select()
            |
            stm = TableStatement()
            |
            LOOKAHEAD(3) stm = Upsert()
            |
            LOOKAHEAD(2) stm = Alter()
            |
            // @todo: merge this into the ALTER TABLE statement
            stm = RenameTableStatement()
            |
            stm = Create()
            |
            stm = Drop()
            |
            stm = Analyze()
            |
            stm = Truncate()
            |
            stm = Execute()
            |
            stm = Set()
            |
            stm = Reset()
            |
            stm = Show()
            |
            stm = RefreshMaterializedView()
            |
            stm = Use()
            |
            stm = SavepointStatement()
            |
            stm = RollbackStatement()
            |
            stm = Commit()
            |
            stm = Comment()
            |
            stm = Describe()
            |
            stm = Explain()
            |
            stm = Declare()
            |
            stm = Grant()
            |
            stm = PurgeStatement()
            |
            stm = SessionStatement()
            |
            stm = LockStatement()
            |
            LOOKAHEAD({ Dialect.EXASOL.name().equals(getAsString(Feature.dialect)) }) ( stm = Import() | stm = Export() )
        )
        { return stm; }
}

Block Block() #Block : {
    Statements stmts = new Statements();
    List<Statement> list = new ArrayList<Statement>();
    Statement stm;
    Block block = new Block();
}
{
    <K_BEGIN>
    (<ST_SEMICOLON>)*
       (
            stm = SingleStatement()
            | stm = Block()
       )
       <ST_SEMICOLON>
       { list.add(stm); }

        (
             (
                (
                    stm = SingleStatement()
                    | stm = Block()
                )
                <ST_SEMICOLON>
                { list.add(stm); }
            )
       )*

    {
        stmts.setStatements(list);
        block.setStatements(stmts);
    }

    <K_END> [LOOKAHEAD(2) <ST_SEMICOLON> { block.setSemicolonAfterEnd(true); } ]
    {
        return block;
    }
}

Statements Statements() #Statements: {
    Statements stmts = new Statements();
    IfElseStatement ifElseStatement = null;
    Statement stm = null;
    Statement stm2 = null;
    Expression condition;
}
{
    (
        (
             ( <ST_SEMICOLON> )*

             // todo: allow also first statement to be an `UnsupportedStatement`
             try {
                (
                     <K_IF> condition=Condition()
                     ( stm = SingleStatement() | stm = Block() ) {  ifElseStatement = new IfElseStatement(condition, stm); }
                     [ LOOKAHEAD(2)
                         [ <ST_SEMICOLON> { ifElseStatement.setUsingSemicolonForIfStatement(true); } ]
                         <K_ELSE> ( stm2 = SingleStatement() |  stm2 =  Block() ) {  ifElseStatement.setElseStatement(stm2);  }
                     ]

                     { stmts.add( ifElseStatement ); }

                     [
                         LOOKAHEAD(2) <ST_SEMICOLON>
                         { if (stm2!=null)
                               ifElseStatement.setUsingSemicolonForElseStatement(true);
                            else if (ifElseStatement!=null)
                               ifElseStatement.setUsingSemicolonForIfStatement(true);
                         }
                     ]
                )
                |
                (
                    (stm = SingleStatement()
                        | stm = Block())

                    ( <ST_SEMICOLON> | <EOF> )
                )
                {
                    stmts.add(stm); stm=null;
                }

             } catch (ParseException ex) {
                if ( getAsBoolean(Feature.allowUnsupportedStatements) ) {
                    UnsupportedStatement unsupportedStatement = new UnsupportedStatement( stm!=null ? stm.toString() : "", error_skipto(ST_SEMICOLON) );
                    if (!unsupportedStatement.isEmpty()) {
                        stmts.add( unsupportedStatement );
                    }
                } else if ( errorRecovery ) {
                    parseErrors.add(ex);
                    error_skipto(ST_SEMICOLON);
                    stmts.add( null );
                } else {
                    throw ex;
                }
             }

        )

        (  LOOKAHEAD(2)
            ( <ST_SEMICOLON> )*
            try {
                (
                    <K_IF> condition=Condition()
                    ( stm = SingleStatement() | stm = Block() ) {  ifElseStatement = new IfElseStatement(condition, stm); }
                    [ LOOKAHEAD(2)
                        [ <ST_SEMICOLON> { ifElseStatement.setUsingSemicolonForIfStatement(true); } ]
                        <K_ELSE> ( stm2 = SingleStatement() | stm2 = Block() ) {  ifElseStatement.setElseStatement(stm2);  }
                    ]

                    { stmts.add( ifElseStatement ); }
               )
               |
                (
                    stm = SingleStatement()
                    | stm = Block()
                ) { stmts.add(stm); stm=null; }
            } catch (ParseException ex) {
               if ( getAsBoolean(Feature.allowUnsupportedStatements) ) {
                   UnsupportedStatement unsupportedStatement = new UnsupportedStatement( stm!=null ? stm.toString() : "" , error_skipto(ST_SEMICOLON) );
                   if (!unsupportedStatement.isEmpty()) {
                       stmts.add( unsupportedStatement );
                   }
               } else if ( errorRecovery ) {
                   parseErrors.add(ex);
                   error_skipto(ST_SEMICOLON);
                   stmts.add( null );
               } else {
                   throw ex;
               }
            }

            ( LOOKAHEAD(2) <ST_SEMICOLON> { if (stm2!=null)
                             ifElseStatement.setUsingSemicolonForElseStatement(true);
                          else if (ifElseStatement!=null)
                             ifElseStatement.setUsingSemicolonForIfStatement(true);
             } )*

        )*

        [
            LOOKAHEAD( { getAsBoolean(Feature.allowUnsupportedStatements) } )
            stm = UnsupportedStatement()
            {
                if (!( (UnsupportedStatement) stm).isEmpty()) {
                    stmts.add( stm );
                }
            }
        ]

    )*

    <EOF>
    {
        return stmts;
    }
}

JAVACODE
List<String> error_skipto(int kind) {
  ArrayList<String> tokenImages = new ArrayList<String>();
  ParseException e = generateParseException("test");
  Token t;
  do {
    t = getNextToken();
    if (t.kind != kind && t.kind != EOF) {
        tokenImages.add(t.image);
    }
  } while (t.kind != kind && t.kind != EOF);
  return tokenImages;
}

LockStatement LockStatement(): {
  	Table table;
  	boolean noWait = false;
  	LockMode lockMode;
    Token waitSecondsToken = null;
    Long waitSeconds = null;
} {
  	<K_LOCK> <K_TABLE> table = Table() <K_IN>
  	(
  	  LOOKAHEAD(2) ( <K_ROW> <K_SHARE> { lockMode = LockMode.RowShare; } ) |
  	  ( <K_ROW> <K_EXCLUSIVE> { lockMode = LockMode.RowExclusive; } ) |
	  LOOKAHEAD(2) ( <K_SHARE> <K_ROW> <K_EXCLUSIVE> { lockMode = LockMode.ShareRowExclusive; } ) |
  	  LOOKAHEAD(2) ( <K_SHARE> <K_UPDATE> { lockMode = LockMode.ShareUpdate; }  ) |
  	  ( <K_SHARE> { lockMode = LockMode.Share; } ) |
  	  ( <K_EXCLUSIVE > { lockMode = LockMode.Exclusive; } )
  	)
  	<K_MODE>
    [ <K_NOWAIT> { noWait = true; } | <K_WAIT> waitSecondsToken = <S_LONG> { waitSeconds = Long.valueOf(waitSecondsToken.image); } ]

  {
    return new LockStatement(table, lockMode, noWait, waitSeconds);
  }
}

LikeClause LikeClause(): {
    LikeClause likeClause = new LikeClause();
    Table table;
    List<SelectItem<Column>> columnsList;
} {
    <K_LIKE>
    table = Table() { likeClause.setTable(table); }
    [ "(" columnsList = ColumnSelectItemsList() ")" { likeClause.setColumnsList(columnsList); }]

    [
        LOOKAHEAD(2)
        (
              <K_INCLUDING> { likeClause.setIncludingDefaults(true); }
            | <K_EXCLUDING> { likeClause.setExcludingDefaults(true); }
        )
        <K_DEFAULTS>
    ]

    [
        LOOKAHEAD(2)
        (
              <K_INCLUDING> { likeClause.setIncludingIdentity(true); }
            | <K_EXCLUDING> { likeClause.setExcludingIdentity(true); }
        )
        <K_IDENTITY>
    ]

    [
        LOOKAHEAD(2)
        (
              <K_INCLUDING> { likeClause.setIncludingComments(true); }
            | <K_EXCLUDING> { likeClause.setExcludingComments(true); }
        )
        <K_COMMENTS>
    ]
    
    {
        return likeClause;
    }
}

Export Export() #Export: {
    Export export = new Export();
    Table table;
    ParenthesedExpressionList<Column> columns;
    ParenthesedSelect select;
    ExportIntoItem exportIntoItem;
} {
    <K_EXPORT>
    (
          table = Table() { export.setTable(table); }
          [ columns = ParenthesedColumnList() { export.setColumns(columns); } ]
        | select = ParenthesedSelect() { export.setSelect(select); }
    )

    <K_INTO>
    exportIntoItem = ExportIntoItem() { export.setExportIntoItem(exportIntoItem); }

    {
        return export;
    }
}

Import Import() #Import: {
    Import impt = new Import();
    Table table;
    ParenthesedExpressionList<Column> columns;
    List<ImportColumn> importColumns;
    ImportFromItem fromItem;
} {
    <K_IMPORT>
    [
        <K_INTO>
        (
              table = Table() { impt.setTable(table); }
              [ columns = ParenthesedColumnList() { impt.setColumns(columns); } ]
            | importColumns = ImportColumns() { impt.setImportColumns(importColumns); }
        )
    ]

    <K_FROM>
    fromItem = ImportFromItem() { impt.setFromItem(fromItem); }

    {
        return impt;
    }
}

Import SubImport() #SubImport: {
    Import impt = new Import();
    List<ImportColumn> importColumns;
    ImportFromItem fromItem;
} {
    "("
        <K_IMPORT>
        [ <K_INTO> importColumns = ImportColumns() { impt.setImportColumns(importColumns); } ]

        <K_FROM>
        fromItem = ImportFromItem() { impt.setFromItem(fromItem); }
    ")"

    {
        return impt;
    }
}

List<ImportColumn> ImportColumns(): {
    ImportColumn importColumn;
    List<ImportColumn> importColumns = new ArrayList<ImportColumn>();
} {
    "("
        (
              importColumn = ColumnDefinition()
            | importColumn = LikeClause()
        )
        { importColumns.add(importColumn); }

        (
            ","
            (
                  importColumn = ColumnDefinition()
                | importColumn = LikeClause()
            )
            { importColumns.add(importColumn); }
        )*
    ")"

    {
        return importColumns;
    }
}

ExportIntoItem ExportIntoItem(): {
    ExportIntoItem exportIntoItem;
    ErrorClause errorClause;
} {
    (
          exportIntoItem = DBMSDestination()
        | exportIntoItem = FileDestination()
        | exportIntoItem = ScriptSourceDestination()
    )
    [ LOOKAHEAD(2) errorClause = ErrorClause() { exportIntoItem.setErrorClause(errorClause); } ]

    {
        return exportIntoItem;
    }
}

ImportFromItem ImportFromItem(): {
    ImportFromItem importFromItem;
    ErrorClause errorClause;
} {
    (
          importFromItem = DBMSSource()
        | importFromItem = FileSource()
        | importFromItem = ScriptSourceDestination()
    )
    [ LOOKAHEAD(2) errorClause = ErrorClause() { importFromItem.setErrorClause(errorClause); } ]

    {
        return importFromItem;
    }
}

DBMSDestination DBMSDestination() #DBMSDestination: {
    DBMSDestination dbmsDestination = new DBMSDestination();
    DBMSType dbmsType;
    ConnectionDefinition connectionDefinition;
    Table table;
    ExpressionList<Column> columns;
    StringValue statement;
    List<DBMSTableDestinationOption> dbmsTableDestinationOptions;
} {
    dbmsType = DBMSType() { dbmsDestination.setDestinationType(dbmsType); }

    connectionDefinition = ConnectionDefinition() { dbmsDestination.setConnectionDefinition(connectionDefinition); }

    (
          LOOKAHEAD(3)
          <K_TABLE> table = Table() { dbmsDestination.setTable(table); }
          [ LOOKAHEAD(2) columns = ParenthesedColumnList() { dbmsDestination.setColumns(columns); } ]
          [ LOOKAHEAD(2) dbmsTableDestinationOptions = DBMSTableDestinationOptionList() { dbmsDestination.setDBMSTableDestinationOptions(dbmsTableDestinationOptions); } ]
        | statement = ImportExportStatement() { dbmsDestination.setStatement(statement); }
    )

    {
      return dbmsDestination;
    }
}

DBMSTableDestinationOption DBMSTableDestinationOption(): {
    DBMSTableDestinationOption dbmsTableDestinationOption;

    Token token;
    Token token2;
    Token token3;
} {
    (
        (
              token = <K_REPLACE>
            | token = <K_TRUNCATE>
            ) { dbmsTableDestinationOption = new DBMSTableDestinationOption(token.image); }
        | token = <K_CREATED> token2 = <K_BY> token3 = <S_CHAR_LITERAL> { dbmsTableDestinationOption = new DBMSTableDestinationOption(token.image + " " + token2.image, new StringValue(token3.image)); }
    )

    {
        return dbmsTableDestinationOption;
    }
}

List<DBMSTableDestinationOption> DBMSTableDestinationOptionList(): {
    List<DBMSTableDestinationOption> dbmsTableDestinationOptions = new ArrayList<DBMSTableDestinationOption>();
    DBMSTableDestinationOption dbmsTableDestinationOption;
} {
    ( LOOKAHEAD(2) dbmsTableDestinationOption = DBMSTableDestinationOption() { dbmsTableDestinationOptions.add(dbmsTableDestinationOption); } )+
    {
        return dbmsTableDestinationOptions;
    }
}

DBMSSource DBMSSource() #DBMSSource: {
    DBMSSource dbmsSource = new DBMSSource();
    DBMSType dbmsType;
    ConnectionDefinition connectionDefinition;
    Table table;
    ExpressionList<Column> columns;
    List<StringValue> statements;
} {
    dbmsType = DBMSType() { dbmsSource.setSourceType(dbmsType); }

    connectionDefinition = ConnectionDefinition() { dbmsSource.setConnectionDefinition(connectionDefinition); }

    (
          <K_TABLE> table = Table() { dbmsSource.setTable(table); }
          [ LOOKAHEAD(2) columns = ParenthesedColumnList() { dbmsSource.setColumns(columns); } ]
        | statements = ImportExportStatementsList() { dbmsSource.setStatements(statements); }
    )
    {
      return dbmsSource;
    }
}

DBMSType DBMSType(): {
    DBMSType dbmsType;
    Token tk1;
    Token tk2 = null;
} {
    (
        tk1=<K_EXA>
      | tk1=<K_ORA>
      | tk1=<K_JDBC>
        [<K_DRIVER> "=" tk2=<S_CHAR_LITERAL>]
    ) { dbmsType = new DBMSType(tk1.image, tk2 == null ? null : tk2.image); }
    {
        return dbmsType;
    }
}

FileType FileType(): {
    FileType fileType;
    Token tk;
} {
    (
        tk=<K_CSV>
      | tk=<K_FBV>
    ) { fileType = new FileType(tk.image); }
    {
        return fileType;
    }
}

StringValue ImportExportStatement() #ImportExportStatement: {
    StringValue statement;
} {
    <K_STATEMENT> token = <S_CHAR_LITERAL>
    {
      statement = new StringValue(token.image);
      linkAST(statement, jjtThis);
      return statement;
    }
}

List<StringValue> ImportExportStatementsList(): {
    List<StringValue> statements = new ArrayList<StringValue>();
    StringValue statement;
} {
    ( statement = ImportExportStatement() { statements.add(statement); } )+

    {
        return statements;
    }
}

StringValue File() #File: {
    Token token;
} {
    <K_FILE> token = <S_CHAR_LITERAL>
    {
        StringValue file = new StringValue(token.image);
        linkAST(file, jjtThis);
        return file;
    }
}

List<StringValue> FileList(): {
    List<StringValue> files = new ArrayList<StringValue>();
    StringValue file;
} {
    ( file = File() { files.add(file); } )+
    {
        return files;
    }
}

ConnectionFileDefinition ConnectionFileDefinition(): {
    ConnectionDefinition connectionDefinition = null;
    List<StringValue> files;
} {
    connectionDefinition = ConnectionOrCloudConnectionDefinition()
    files = FileList()
    {
        return new ConnectionFileDefinition(connectionDefinition, files);
    }
}

List<ConnectionFileDefinition> ConnectionFileDefinitionList(): {
    List<ConnectionFileDefinition> connectionFileDefinitions = new ArrayList<ConnectionFileDefinition>();
    ConnectionFileDefinition connectionFileDefinition;
} {
    ( LOOKAHEAD(2) connectionFileDefinition = ConnectionFileDefinition() { connectionFileDefinitions.add(connectionFileDefinition); } )+
    {
        return connectionFileDefinitions;
    }
}

CSVColumn CSVDestinationColumn(): {
    CSVColumn csvColumn;

    Token token;
    Token token2;
} {
    (
          LOOKAHEAD(2)
          token=<S_LONG> ".." token2=<S_LONG> { csvColumn = new CSVColumn(Long.valueOf(token.image), Long.valueOf(token2.image)); }
        | token=<S_LONG> { csvColumn = new CSVColumn(Long.valueOf(token.image)); }
          [ <K_FORMAT> "=" token = <S_CHAR_LITERAL> { csvColumn.setFormat(new StringValue(token.image)); }]
          [
            <K_DELIMIT>
            "="
            (
                  token=<K_ALWAYS>
                | token=<K_NEVER>
                | token=<K_AUTO>
            )
            { csvColumn.setDelimit(token.image); }
          ]
    )
    {
        return csvColumn;
    }
}

List<CSVColumn> CSVDestinationColumnList(): {
    List<CSVColumn> csvColumns = new ArrayList<CSVColumn>();
    CSVColumn csvColumn;
} {
    csvColumn = CSVDestinationColumn() { csvColumns.add(csvColumn); }
    ( "," csvColumn = CSVDestinationColumn() { csvColumns.add(csvColumn); } )*
    {
        return csvColumns;
    }
}

CSVColumn CSVSourceColumn(): {
    CSVColumn csvColumn;

    Token token;
    Token token2;
} {
    (
          LOOKAHEAD(2)
          token=<S_LONG> ".." token2=<S_LONG> { csvColumn = new CSVColumn(Long.valueOf(token.image), Long.valueOf(token2.image)); }
        | token=<S_LONG> { csvColumn = new CSVColumn(Long.valueOf(token.image)); }
          [ <K_FORMAT> "=" token = <S_CHAR_LITERAL> { csvColumn.setFormat(new StringValue(token.image)); }]
    )
    {
        return csvColumn;
    }
}

List<CSVColumn> CSVSourceColumnList(): {
    List<CSVColumn> csvColumns = new ArrayList<CSVColumn>();
    CSVColumn csvColumn;
} {
    csvColumn = CSVSourceColumn() { csvColumns.add(csvColumn); }
    ( "," csvColumn = CSVSourceColumn() { csvColumns.add(csvColumn); } )*
    {
        return csvColumns;
    }
}

FBVColumn FBVDestinationColumn(): {
    FBVColumn fbvColumn;

    Token token;
    Token token2;
} {
    (
          token=<K_SIZE> "=" token2=<S_LONG> { fbvColumn = new FBVColumn(token.image, new LongValue(token2.image)); }
        | ( token=<K_FORMAT> | token=<K_PADDING> ) "=" token2=<S_CHAR_LITERAL> { fbvColumn = new FBVColumn(token.image, new StringValue(token2.image)); }
        | token=<K_ALIGN> "=" ( token2=<K_LEFT> | token2=<K_RIGHT> ) { fbvColumn = new FBVColumn(token.image, token2.image); }
    )
    {
        return fbvColumn;
    }
}

List<FBVColumn> FBVDestinationColumnList(): {
    List<FBVColumn> fbvColumns = new ArrayList<FBVColumn>();
    FBVColumn fbvColumn;
    boolean precedesComma;
} {
    fbvColumn = FBVDestinationColumn() { fbvColumns.add(fbvColumn); }
    (
        { precedesComma = false; }
        ["," { precedesComma = true; }]
        fbvColumn = FBVDestinationColumn() { fbvColumn.setPrecedesComma(precedesComma); fbvColumns.add(fbvColumn); }
    )*
    {
        return fbvColumns;
    }
}

FBVColumn FBVSourceColumn(): {
    FBVColumn fbvColumn;

    Token token;
    Token token2;
} {
    (
          ( token=<K_SIZE> | token=<K_START> ) "=" token2=<S_LONG> { fbvColumn = new FBVColumn(token.image, new LongValue(token2.image)); }
        | ( token=<K_FORMAT> | token=<K_PADDING> ) "=" token2=<S_CHAR_LITERAL> { fbvColumn = new FBVColumn(token.image, new StringValue(token2.image)); }
        | token=<K_ALIGN> "=" ( token2=<K_LEFT> | token2=<K_RIGHT> ) { fbvColumn = new FBVColumn(token.image, token2.image); }
    )
    {
        return fbvColumn;
    }
}

List<FBVColumn> FBVSourceColumnList(): {
    List<FBVColumn> fbvColumns = new ArrayList<FBVColumn>();
    FBVColumn fbvColumn;
    boolean precedesComma;
} {
    fbvColumn = FBVSourceColumn() { fbvColumns.add(fbvColumn); }
    (
        { precedesComma = false; }
        ["," { precedesComma = true; }]
        fbvColumn = FBVSourceColumn() { fbvColumn.setPrecedesComma(precedesComma); fbvColumns.add(fbvColumn); }
    )*
    {
        return fbvColumns;
    }
}

FileOption FileDestinationOption(): {
    FileOption fileOption;

    Token token;
    Token token2;
    Token token3;
} {
    (
        ( token=<K_REPLACE> | token=<K_TRUNCATE> ) { fileOption = new FileOption(token.image); }
      | token=<K_WITH> token2=<K_COLUMN> token3=<K_NAMES> { fileOption = new FileOption(token.image + " " + token2.image + " " + token3.image); }
      | ( token=<K_ENCODING> | token=<K_NULL> | token=<K_BOOLEAN> ) "=" token2=<S_CHAR_LITERAL> { fileOption = new FileOption(token.image, new StringValue(token2.image)); }
      | (
            token=<K_ROW> token2=<K_SEPARATOR> "=" token3=<S_CHAR_LITERAL>
          | token=<K_COLUMN> ( token2=<K_SEPARATOR> | token2=<K_DELIMITER> ) "=" token3=<S_CHAR_LITERAL>
        )
        { fileOption = new FileOption(token.image + " " + token2.image, new StringValue(token3.image)); }
      | token=<K_DELIMIT> "=" ( token2=<K_ALWAYS> | token2=<K_NEVER> | token2=<K_AUTO> ) { fileOption = new FileOption(token.image, token2.image); }
    )
    {
        return fileOption;
    }
}

List<FileOption> FileDestinationOptionList(): {
    List<FileOption> fileOptions = new ArrayList<FileOption>();
    FileOption fileOption;
} {
    ( LOOKAHEAD(2) fileOption = FileDestinationOption() { fileOptions.add(fileOption); } )+
    {
        return fileOptions;
    }
}

FileOption FileSourceOption(): {
    FileOption fileOption;

    Token token;
    Token token2;
    Token token3;
} {
    (
        ( token=<K_TRIM> | token=<K_LTRIM> | token=<K_RTRIM> ) { fileOption = new FileOption(token.image); }
      | (
            ( token=<K_ENCODING> | token=<K_NULL> ) "=" token2=<S_CHAR_LITERAL> { fileOption = new FileOption(token.image, new StringValue(token2.image)); }
          | token=<K_SKIP> "=" token2=<S_LONG> { fileOption = new FileOption(token.image, new LongValue(token2.image)); }
        )
      | LOOKAHEAD(2)
        (
            token=<K_ROW> token2=<K_SEPARATOR> "=" token3=<S_CHAR_LITERAL>
          | token=<K_COLUMN> ( token2=<K_SEPARATOR> | token2=<K_DELIMITER> ) "=" token3=<S_CHAR_LITERAL>
        )
        { fileOption = new FileOption(token.image + " " + token2.image, new StringValue(token3.image)); }
      | token=<K_ROW> token2=<K_SIZE> "=" token3=<S_LONG>
        { fileOption = new FileOption(token.image + " " + token2.image, new LongValue(token3.image)); }
    )
    {
        return fileOption;
    }
}

List<FileOption> FileSourceOptionList(): {
    List<FileOption> fileOptions = new ArrayList<FileOption>();
    FileOption fileOption;
} {
    ( LOOKAHEAD(2) fileOption = FileSourceOption() { fileOptions.add(fileOption); } )+
    {
        return fileOptions;
    }
}

FileDestination FileDestination() #FileDestination: {
    FileDestination fileDestination = new FileDestination();
    FileType fileType;
    List<ConnectionFileDefinition> connectionFileDefinitions;
    List<StringValue> files;
    List<CSVColumn> csvColumns;
    List<FBVColumn> fbvColumns;
    List<FileOption> fileOptions;
    CertificateVerification certificateVerification;
} {
  (
      fileType = FileType() { fileDestination.setDestinationType(fileType); }
      connectionFileDefinitions = ConnectionFileDefinitionList() { fileDestination.setConnectionFileDefinitions(connectionFileDefinitions); }
    | <K_LOCAL> { fileDestination.setLocal(true); }
      [<K_SECURE> { fileDestination.setSecure(true); }]

      fileType = FileType() { fileDestination.setDestinationType(fileType); }
      files = FileList()
      {
            connectionFileDefinitions = new ArrayList<ConnectionFileDefinition>();
            connectionFileDefinitions.add(new ConnectionFileDefinition(files));
      }
  )
  { fileDestination.setConnectionFileDefinitions(connectionFileDefinitions); }

  [
    LOOKAHEAD(2)
    "("
        (
            csvColumns = CSVDestinationColumnList() { fileDestination.setCSVColumns(csvColumns); }
          | fbvColumns = FBVDestinationColumnList() { fileDestination.setFBVColumns(fbvColumns); }
        )
    ")"
  ]

  [ LOOKAHEAD(2) fileOptions = FileDestinationOptionList() { fileDestination.setFileOptions(fileOptions); } ]

  [ LOOKAHEAD(2) certificateVerification = CertificateVerification() { fileDestination.setCertificateVerification(certificateVerification); } ]

  {
    return fileDestination;
  }
}

FileSource FileSource() #FileSource: {
    FileSource fileSource = new FileSource();
    FileType fileType;
    List<ConnectionFileDefinition> connectionFileDefinitions;
    List<StringValue> files;
    List<CSVColumn> csvColumns;
    List<FBVColumn> fbvColumns;
    List<FileOption> fileOptions;
    CertificateVerification certificateVerification;
} {
  (
      fileType = FileType() { fileSource.setSourceType(fileType); }
      connectionFileDefinitions = ConnectionFileDefinitionList() { fileSource.setConnectionFileDefinitions(connectionFileDefinitions); }
    | <K_LOCAL> { fileSource.setLocal(true); }
      [<K_SECURE> { fileSource.setSecure(true); }]

      fileType = FileType() { fileSource.setSourceType(fileType); }
      files = FileList()
      {
            connectionFileDefinitions = new ArrayList<ConnectionFileDefinition>();
            connectionFileDefinitions.add(new ConnectionFileDefinition(files));
      }
  )
  { fileSource.setConnectionFileDefinitions(connectionFileDefinitions); }

  [
    LOOKAHEAD(2)
    "("
        (
            csvColumns = CSVSourceColumnList() { fileSource.setCSVColumns(csvColumns); }
          | fbvColumns = FBVSourceColumnList() { fileSource.setFBVColumns(fbvColumns); }
        )
    ")"
  ]

  [ LOOKAHEAD(2) fileOptions = FileSourceOptionList() { fileSource.setFileOptions(fileOptions); } ]

  [ LOOKAHEAD(2) certificateVerification = CertificateVerification() { fileSource.setCertificateVerification(certificateVerification); } ]

  {
    return fileSource;
  }
}

CertificateVerification CertificateVerification(): {
    CertificateVerification certificateVerification = new CertificateVerification();
    Token token;
} {
    (
          (
                <K_IGNORE> { certificateVerification.setIgnoreCertificate(true); }
              | <K_VERIFY> { certificateVerification.setVerifyCertificate(true); }
          )
          <K_CERTIFICATE>
          [
            LOOKAHEAD(2)
            <K_PUBLIC> <K_KEY>
            token = <S_CHAR_LITERAL> { certificateVerification.setPublicKey(new StringValue(token.image)); }
          ]
        | <K_PUBLIC> <K_KEY>
          token = <S_CHAR_LITERAL> { certificateVerification.setPublicKey(new StringValue(token.image)); }
    )
    {
        return certificateVerification;
    }
}

ScriptSourceDestination ScriptSourceDestination(): {
  ScriptSourceDestination scriptSourceDestination = new ScriptSourceDestination();
  ConnectionDefinition connectionDefinition;
  Table script;
  String property;
  StringValue value;

  Token token;
} {
    <K_SCRIPT>
    script = Table() { scriptSourceDestination.setScript(script); }

    [ LOOKAHEAD(2) connectionDefinition = ConnectionDefinition() { scriptSourceDestination.setConnectionDefinition(connectionDefinition); } ]

    [
        LOOKAHEAD(2)
        {
            List<String> properties = new ArrayList<String>();
            List<StringValue> values = new ArrayList<StringValue>();
            scriptSourceDestination.setProperties(properties);
            scriptSourceDestination.setValues(values);
        }

        <K_WITH>
        (
            LOOKAHEAD(2)
            property = RelObjectNameWithoutValue() "=" token = <S_CHAR_LITERAL> { value = new StringValue(token.image); }
            {
                properties.add(property);
                values.add(value);
            }
        )+
    ]

    {
      return scriptSourceDestination;
    }
}

UserIdentification UserIdentification(): {
    UserIdentification userIdentification = new UserIdentification();
    Token token;
} {
    <K_USER>
    token=<S_CHAR_LITERAL> { userIdentification.setUser(new StringValue(token.image)); }
    <K_IDENTIFIED> <K_BY>
    token=<S_CHAR_LITERAL> { userIdentification.setPassword(new StringValue(token.image)); }

    {
        return userIdentification;
    }
}

ConnectionDefinition ConnectionDefinition(): {
  ConnectionDefinition connectionDefinition = new ConnectionDefinition();
  String connectionObjectName;
  UserIdentification userIdentification;
  CertificateVerification certificateVerification;

  Token token;
} {
  <K_AT>
  (
      connectionObjectName = RelObjectNameWithoutValue() { connectionDefinition.setConnectionObjectName(connectionObjectName); }
    | token=<S_CHAR_LITERAL> { connectionDefinition.setConnectionDefinition(new StringValue(token.image)); }
  )

  [ LOOKAHEAD(2) userIdentification = UserIdentification() { connectionDefinition.setUserIdentification(userIdentification); } ]

  [ LOOKAHEAD(2) certificateVerification = CertificateVerification() { connectionDefinition.setCertificateVerification(certificateVerification); } ]

  {
      return connectionDefinition;
  }
}

ConnectionDefinition CloudConnectionDefinition(): {
  CloudConnectionDefinition connectionDefinition = new CloudConnectionDefinition();
  String connectionObjectName;
  UserIdentification userIdentification;

  Token token;
  Token token2;
} {
  <K_AT> <K_CLOUD>
  (
      token = <K_NONE> { connectionDefinition.setStorage(token.image); }
    | token = <K_AZURE> token2 = <K_BLOBSTORAGE> { connectionDefinition.setStorage(token.image + " " + token2.image); }
  )

  (
      connectionObjectName = RelObjectNameWithoutValue() { connectionDefinition.setConnectionObjectName(connectionObjectName); }
    | token = <S_CHAR_LITERAL> { connectionDefinition.setConnectionDefinition(new StringValue(token.image)); }
  )

  [ userIdentification = UserIdentification() { connectionDefinition.setUserIdentification(userIdentification); } ]

  {
      return connectionDefinition;
  }
}

ConnectionDefinition ConnectionOrCloudConnectionDefinition(): {
    ConnectionDefinition connectionDefinition;
} {
    (
        LOOKAHEAD(2) connectionDefinition = CloudConnectionDefinition()
      | connectionDefinition = ConnectionDefinition()
    )
    {
        return connectionDefinition;
    }
}

ErrorClause ErrorClause(): {
  ErrorClause errorClause = new ErrorClause();
  ErrorDestination errorDestination;
  Expression expression;
  RejectClause rejectClause;

  Token token;
} {
    (
        <K_ERRORS> <K_INTO>
        errorDestination = ErrorDestination() { errorClause.setErrorDestination(errorDestination); }
        [
          LOOKAHEAD(2)
          "("
          expression = Expression() { errorClause.setExpression(expression); }
          ")"
        ]
        [
            LOOKAHEAD(2) 
            (
                <K_REPLACE> { errorClause.setReplace(true); }
              | <K_TRUNCATE> { errorClause.setTruncate(true); }
            )
        ]
        [ LOOKAHEAD(2) rejectClause = RejectClause() { errorClause.setRejectClause(rejectClause); } ]
      | rejectClause = RejectClause() { errorClause.setRejectClause(rejectClause); }
  )
  
  {
    return errorClause;
  }
}

RejectClause RejectClause(): {
    RejectClause rejectClause = new RejectClause();
} {
    <K_REJECT> <K_LIMIT>
    (
          token=<S_LONG> { rejectClause.setLimit(new LongValue(token.image)); }
        | <K_UNLIMITED>
    )

    [ LOOKAHEAD(2) <K_ERRORS> { rejectClause.setErrors(true); } ]

    {
        return rejectClause;
    }
}

ErrorDestination ErrorDestination(): {
    ErrorDestination errorDestination;
} {
    (
          LOOKAHEAD(2) errorDestination = CSVFileDestination()
        | errorDestination = Table()
    )

    {
        return errorDestination;
    }
}

CSVFileDestination CSVFileDestination(): {
    CSVFileDestination csvFileDestination = new CSVFileDestination();
    ConnectionDefinition connectionDefinition;
    StringValue file;
} {
    (
          <K_CSV>
          connectionDefinition = ConnectionOrCloudConnectionDefinition() { csvFileDestination.setConnectionDefinition(connectionDefinition); }
        | <K_LOCAL> { csvFileDestination.setLocal(true); }
          [ <K_SECURE> { csvFileDestination.setSecure(true); } ]
          <K_CSV>
    )

    file = File() { csvFileDestination.setFile(file); }

    {
        return csvFileDestination;
    }
}

DeclareStatement Declare(): {
    UserVariable userVariable;
    ColDataType colDataType;
    Expression defaultExpr = null;
    DeclareStatement stmt = new DeclareStatement();
    String typeName;
    String columnName;
    ColumnDefinition colDef;
} {
    <K_DECLARE> userVariable = UserVariable()
    (
         LOOKAHEAD(2) (
            <K_TABLE> "(" colDef = ColumnDefinition()
            {
            stmt.withUserVariable(userVariable)
            .withDeclareType(DeclareType.TABLE)
            .addColumnDefinition(colDef);
            }
            ("," colDef = ColumnDefinition() { stmt.addColumnDefinition(colDef); })*  ")"
        )
        |
            <K_AS> typeName = RelObjectName()
                {
                    stmt.withUserVariable(userVariable)
                      .withDeclareType(DeclareType.AS)
                      .withTypeName(typeName);
                }
        |
            (colDataType = ColDataType() ["=" defaultExpr = Expression()]
                {
                  stmt.withDeclareType(DeclareType.TYPE)
                  .addType(userVariable, colDataType, defaultExpr);
                }
                ("," userVariable = UserVariable() colDataType = ColDataType() { defaultExpr = null; }
                ["=" defaultExpr = Expression()] { stmt.addType(userVariable, colDataType, defaultExpr); } )*
            )
    )
    {
       return stmt;
    }
}

SessionStatement SessionStatement():
{
    SessionStatement sessionsStatement;
    Token actionToken;
    Token idToken = null;
    String id = null;
}
{
    ( <K_SESSION> | <K_BRANCH> )
    (
        actionToken = <K_START>
        |
        actionToken = <K_APPLY>
        |
        actionToken = <K_DROP>
        |
        actionToken = <K_SHOW>
        |
        actionToken = <K_DESCRIBE>
    )

    [
        (
            idToken = <S_IDENTIFIER>
            |
            idToken = <S_QUOTED_IDENTIFIER>
            |
            idToken = <S_CHAR_LITERAL>
            |
            idToken = <S_LONG>
        ) { id = idToken.image; }

        (
            "."
            (
                idToken = <S_IDENTIFIER>
                |
                idToken = <S_QUOTED_IDENTIFIER>
                |
                idToken = <S_CHAR_LITERAL>
                |
                idToken = <S_LONG>
            ) { id += "." + idToken.image; }
        )?
    ]
    {
        sessionsStatement = id!=null
            ? new SessionStatement(actionToken.image, id)
            : new SessionStatement(actionToken.image);
    }

    // options
    [
        LOOKAHEAD(2) <K_WITH>
        ( idToken = <S_IDENTIFIER> | idToken = <K_KEEP> )
        "="
        ( actionToken = <S_IDENTIFIER> | actionToken = <S_QUOTED_IDENTIFIER> | actionToken = <S_CHAR_LITERAL> | actionToken = <S_LONG> | actionToken = <K_TRUE> | actionToken = <K_FALSE> | actionToken = <K_ON> | actionToken = <K_OFF>  | actionToken = <K_YES> | actionToken = <K_NO> )
        { sessionsStatement.putOption(idToken.image, actionToken.image ); }

        (
            ","
            ( idToken = <S_IDENTIFIER> | idToken = <K_KEEP> )
            "="
            ( actionToken = <S_IDENTIFIER> | actionToken = <S_QUOTED_IDENTIFIER> | actionToken = <S_CHAR_LITERAL> | actionToken = <S_LONG> | actionToken = <K_TRUE> | actionToken = <K_FALSE> | actionToken = <K_ON> | actionToken = <K_OFF>  | actionToken = <K_YES> | actionToken = <K_NO> )
            { sessionsStatement.putOption(idToken.image, actionToken.image ); }
        )*
    ]

    {
        //linkAST(sessionsStatement,jjtThis);
        return sessionsStatement;
    }
}

SetStatement Set(): {
    String namePart;
    Object name;
    ExpressionList expList;
    boolean useEqual = false;
    SetStatement set;
    Expression exp = null;
    Token tk = null;
    String effectParameter = null;
}
{
    <K_SET>
    [LOOKAHEAD(3) (tk = <K_LOCAL> | tk = <K_SESSION>) {effectParameter = tk.image; } ]
    (
        LOOKAHEAD(2)
        <K_DATETIMELITERAL> <K_ZONE> { name = "Time Zone"; useEqual=false; }
        |
        (
            name = UserVariable() ["=" { useEqual=true; } ]
        )
        |
        (
            name = IdentifierChain()
            ["=" { useEqual=true; } ]
        )
    )
    exp=Expression()
    {
        expList = new ExpressionList();
        expList.add(exp);
        set = new SetStatement(name, expList)
            .withUseEqual(useEqual)
            .withEffectParameter(effectParameter);
    }

    (
        { useEqual=false; }
        ","
        (LOOKAHEAD(3)
            (
                ( LOOKAHEAD(2)
                    <K_DATETIMELITERAL> <K_ZONE> { name = "Time Zone"; useEqual=false; }
                    |
                    (name = RelObjectNameExt() ["=" { useEqual=true; } ])
                )
                exp=Expression()
                {
                    expList = new ExpressionList();
                    expList.add(exp);
                    set.add(name, expList, useEqual);
                }
            )
            |
            exp=Expression() { expList.add(exp); }
         )
    )*
    { return set; }
}

ResetStatement Reset(): {
    String name;
    ResetStatement reset;
    Token all;
}
{
    <K_RESET> ( LOOKAHEAD(2) <K_DATETIMELITERAL> <K_ZONE> {name = "Time Zone"; } | name = RelObjectName() | all = <K_ALL> {name = all.image; } )
    { reset = new ResetStatement(name);   return reset; }
}

RenameTableStatement RenameTableStatement(): {
    RenameTableStatement renameTableStatement;
    Table oldName;
    Table newName;
    boolean usingTableKeyword=false;
    boolean usesIfExistsKeyword=false;
    String waitDirective = "";
    Token token;
}
{
    <K_RENAME>
    [ LOOKAHEAD(2) <K_TABLE> { usingTableKeyword = true; } ]
    [ LOOKAHEAD(2) <K_IF> <K_EXISTS> { usesIfExistsKeyword = true; } ]
    oldName = Table()
    [ (
        <K_WAIT> token=<S_LONG> { waitDirective = "WAIT " + token.image; }
        |
        <K_NOWAIT>  { waitDirective = "NOWAIT"; }
       ) ]
    <K_TO>
    newName = Table()

    {
        renameTableStatement = new RenameTableStatement(oldName, newName, usingTableKeyword, usesIfExistsKeyword, waitDirective);
    }

    (
        ","
        oldName = Table()
        <K_TO>
        newName = Table()
        {
            renameTableStatement.addTableNames(oldName, newName);
        }
    )*

    {
        return renameTableStatement;
    }
}

PurgeStatement PurgeStatement(): {
    PurgeStatement purgeStatement = null;
    Table table;
    Index index;
    Token tableSpaceToken;
    Token userToken = null;
}
{
    <K_PURGE>
    (
        <K_TABLE> table=Table() { purgeStatement = new PurgeStatement(table); }
        |
        <K_INDEX> index=Index() { purgeStatement = new PurgeStatement(index); }
        |
        <K_RECYCLEBIN> { purgeStatement = new PurgeStatement(PurgeObjectType.RECYCLEBIN); }
        |
        <K_DBA_RECYCLEBIN> { purgeStatement = new PurgeStatement(PurgeObjectType.DBA_RECYCLEBIN); }
        |
        <K_TABLESPACE> tableSpaceToken=<S_IDENTIFIER> [ <K_USER> userToken=<S_IDENTIFIER> ] {
            purgeStatement = new PurgeStatement(
                PurgeObjectType.TABLESPACE
                , tableSpaceToken.image
                , userToken!=null ? userToken.image : null);
            }
    )

    {
        return purgeStatement;
    }
}

DescribeStatement Describe(): {
    Table table;
    DescribeStatement stmt = new DescribeStatement();
    Token tk = null;
} {
    (tk=<K_DESCRIBE> | tk=<K_DESC>)
    table = Table() { stmt.setDescribeType(tk.image).setTable(table); }
    {
        return stmt;
    }
}

ExplainStatement Explain():
{
    Token tk;
    Select select;
    Table table;
    List<ExplainStatement.Option> options;
    ExplainStatement es;
}
{
    ( tk=<K_EXPLAIN> | tk = <K_SUMMARIZE> )
    (
        LOOKAHEAD(3)(
            options= ExplainStatementOptions()
            select = Select( )
            {
                es = new ExplainStatement(tk.image, select, options);
            }
        )
        |
        (
           table=Table( ) {  es = new ExplainStatement(tk.image, table);  }
        )
    )
    {
        return es;
    }
}

/**
 * Postgres supports TRUE,ON,1,FALSE,OFF,0 as values
 */
String ExplainOptionBoolean():
{
  Token tk = null;
}
{
   // intentionally not supporting 0,1 at the moment
   [( tk=<K_TRUE> | tk=<K_FALSE> | tk=<K_ON> | tk=<K_OFF> )] // optional
   {
    return tk != null ? tk.image : null;
   }
}

/**
 * The output format, which can be TEXT, XML, JSON, or YAML
 */
String ExplainFormatOption():
{
  Token tk = null;
}
{
   // TODO support Text
   [( tk=<K_XML> | tk=<K_JSON> | tk=<K_YAML> )] // optional
   {
    return tk != null ? tk.image : null;
   }
}

/**
 * Options for explain, see https://www.postgresql.org/docs/9.1/sql-explain.html
 */
List<ExplainStatement.Option> ExplainStatementOptions():
{
  List<ExplainStatement.Option> options = new ArrayList<ExplainStatement.Option>();
  ExplainStatement.Option option = null;
  Token token = null;
  String value = null;
}
{
  (
    (<K_ANALYZE> value=ExplainOptionBoolean()
     {
       option = new ExplainStatement.Option(ExplainStatement.OptionType.ANALYZE);
       option.setValue(value);
       options.add(option);
     }
    )
    |
    (<K_BUFFERS> value=ExplainOptionBoolean()
      {
        option = new ExplainStatement.Option(ExplainStatement.OptionType.BUFFERS);
        option.setValue(value);
        options.add(option);
      }
    )
    |
    (<K_COSTS> value=ExplainOptionBoolean()
      {
        option = new ExplainStatement.Option(ExplainStatement.OptionType.COSTS);
        option.setValue(value);
        options.add(option);
      }
    )
    |
    (<K_VERBOSE> value=ExplainOptionBoolean()
      {
        option = new ExplainStatement.Option(ExplainStatement.OptionType.VERBOSE);
        option.setValue(value);
        options.add(option);
      }
    )
    |
    (<K_FORMAT> value=ExplainFormatOption()
      {
        option = new ExplainStatement.Option(ExplainStatement.OptionType.FORMAT);
        option.setValue(value);
        options.add(option);
      }
    )
    |
    (
        <K_PLAN> { option = new ExplainStatement.Option(ExplainStatement.OptionType.PLAN); }
        [ <K_FOR> { option = new ExplainStatement.Option(ExplainStatement.OptionType.PLAN_FOR); } ]

        value=ExplainFormatOption()
        {
            option.setValue(value);
            options.add(option);
        }
    )
  )* //zero or many times those productions
  {
    return options;
  }
}

UseStatement Use(): {
    String name;
    boolean hasSchemaKeyword = false;
}
{
    <K_USE> [ LOOKAHEAD(2) <K_SCHEMA> { hasSchemaKeyword = true; } ] name = RelObjectNameExt()
    {
        return new UseStatement(name, hasSchemaKeyword);
    }
}

Statement Show():
{
    Statement statement;
    List<String> captureRest;
}
{
    <K_SHOW>
    (
        LOOKAHEAD(2) statement = ShowColumns()
        |
        LOOKAHEAD(2) statement = ShowIndex()
        |
        LOOKAHEAD(2) statement = ShowTables()
        |
        // any of the RDBMS specific SHOW syntax
        captureRest = captureRest()
        {
            if (captureRest.size()==1) {
                statement = new ShowStatement(captureRest.get(0));
            } else {
                statement = new UnsupportedStatement("SHOW", captureRest);
            }
        }
    )
    {
        return statement;
    }
}

ShowColumnsStatement ShowColumns(): {
    String tableName;
}
{
    <K_COLUMNS> <K_FROM> tableName = RelObjectNameExt()
    {
        return new ShowColumnsStatement(tableName);
    }
}

ShowIndexStatement ShowIndex(): {
    String tableName;
}
{
    <K_INDEX> <K_FROM> tableName = RelObjectNameExt()
    {
        return new ShowIndexStatement(tableName);
    }
}

Statement RefreshMaterializedView(): {
    Table view = null;
    boolean concurrently = false;
    RefreshMode refreshMode = null;
    List<String> captureRest;
}
{
    <K_REFRESH> <K_MATERIALIZED> <K_VIEW>
    [ LOOKAHEAD(2) <K_CONCURRENTLY>  { concurrently = true; } ]
    view = Table()
    [
        <K_WITH> { refreshMode = RefreshMode.WITH_DATA; }
        [
            <K_NO> { refreshMode = RefreshMode.WITH_NO_DATA; }
        ]
        <K_DATA>
    ]
    captureRest = captureRest()
    {
        if (concurrently && refreshMode == RefreshMode.WITH_NO_DATA) {
            return new UnsupportedStatement("REFRESH", captureRest);
        } else {
           return new RefreshMaterializedViewStatement(view, concurrently, refreshMode);
        }
    }
}
// https://dev.mysql.com/doc/refman/8.0/en/show-tables.html
ShowTablesStatement ShowTables(): {
    ShowTablesStatement showTablesStatement;
    EnumSet<ShowTablesStatement.Modifiers> modifiers =  EnumSet.noneOf(ShowTablesStatement.Modifiers.class);
    ShowTablesStatement.SelectionMode selectionMode = null;
    String dbName = null;
    Expression likeExpression = null;
    Expression whereCondition = null;
}
{
  [ <K_EXTENDED> { modifiers.add(ShowTablesStatement.Modifiers.EXTENDED); } ]
  [ <K_FULL> { modifiers.add(ShowTablesStatement.Modifiers.FULL); } ]
  <K_TABLES>
  [
    LOOKAHEAD(2) (
        <K_FROM> { selectionMode = ShowTablesStatement.SelectionMode.FROM; }
        |
        <K_IN> { selectionMode = ShowTablesStatement.SelectionMode.IN; }
    )
    dbName = RelObjectNameExt()
  ]
  [ (<K_LIKE> likeExpression = SimpleExpression() | <K_WHERE> whereCondition = Expression()) ]
  {
    showTablesStatement = new ShowTablesStatement();
    showTablesStatement.setModifiers(modifiers);
    showTablesStatement.setSelectionMode(selectionMode);
    showTablesStatement.setDbName(dbName);
    showTablesStatement.setLikeExpression(likeExpression);
    showTablesStatement.setWhereCondition(whereCondition);
    return showTablesStatement;
  }
}

Values Values(): {
    ExpressionList expressions;
} {
    ( <K_VALUES> | <K_VALUE> )
    expressions = ExpressionList()

    {
        return new Values(expressions);
    }
}

ReturningClause ReturningClause():
{
    Token keyword;
    List<SelectItem<?>> selectItems;
    Object dataItem;
    List<Object> dataItems = null;
}
{
    ( keyword=<K_RETURNING> | keyword=<K_RETURN> )
    selectItems = SelectItemsList()

    [
        <K_INTO>
        ( dataItem = Table() | dataItem = UserVariable() )
        { dataItems = new ArrayList<Object>(); dataItems.add(dataItem); }

        (
            ","
            ( dataItem = Table() | dataItem = UserVariable() ) { dataItems.add(dataItem); }
        )*
    ]

    {
        return new ReturningClause(keyword.image, selectItems, dataItems);
    }
}

Update UpdateWithWithItems( List<WithItem<?>> withItems ):
{
    Update update;
}
{
    update = Update() { update.setWithItemsList( withItems );
    return update;
}
}

Update Update():
{
    Update update = new Update();
    Table table = null;
    List<Join> startJoins = null;
    List<WithItem<?>> with = null;
    List<UpdateSet> updateSets;
    Expression where = null;
    PreferringClause preferringClause = null;
    FromItem fromItem = null;
    List<Join> joins = null;
    Limit limit = null;
    List<OrderByElement> orderByElements;
    boolean useColumnsBrackets = false;
    ReturningClause returningClause;
    Token tk = null;
    UpdateModifierPriority modifierPriority = null;
    boolean modifierIgnore = false;

    OutputClause outputClause = null;
}
{
   <K_UPDATE> { update.setOracleHint(getOracleHint()); }
    [ LOOKAHEAD(2) <K_LOW_PRIORITY> { modifierPriority = UpdateModifierPriority.LOW_PRIORITY; }]
    [ LOOKAHEAD(2) <K_IGNORE> { modifierIgnore = true; }]
    table=TableWithAliasAndMysqlIndexHint() [ startJoins=JoinsList() ]
    <K_SET> updateSets = UpdateSets() { update.setUpdateSets(updateSets); }

    [ outputClause = OutputClause() {update.setOutputClause(outputClause); } ]

    [ LOOKAHEAD(2) <K_FROM>
      fromItem=FromItem()
      [ LOOKAHEAD(2) joins=JoinsList() ] ]

    [ where=WhereClause() { update.setWhere(where); } ]
    [ preferringClause=PreferringClause() { update.setPreferringClause(preferringClause); } ]

    [ orderByElements = OrderByElements() { update.setOrderByElements(orderByElements); } ]
    [ limit = PlainLimit() { update.setLimit(limit); } ]
    [ returningClause = ReturningClause() { update.setReturningClause(returningClause); } ]

    {
        return update.withWithItemsList(with)
              .withTable(table)
              .withStartJoins(startJoins)
              .withFromItem(fromItem)
              .withJoins(joins)
              .withModifierPriority(modifierPriority)
              .withModifierIgnore(modifierIgnore);
    }
}

List<UpdateSet> UpdateSets():
{
    ArrayList<UpdateSet> updateSets = new ArrayList<UpdateSet>();
    UpdateSet updateSet;
    Column tableColumn;
    Expression valueExpression;

    ExpressionList<Column> columns;
    ExpressionList<Expression>values;
}
{
    (
        (
            tableColumn=Column() "=" valueExpression=Expression()
            { updateSets.add( new UpdateSet (tableColumn, valueExpression)); }
        )
        |
        (
            { updateSet = new UpdateSet(); updateSets.add(updateSet); }
            columns = ParenthesedExpressionList() { updateSet.setColumns(columns); }
            "="
            (
                LOOKAHEAD(3) valueExpression = ParenthesedSelect() { updateSet.setValues( new ExpressionList(valueExpression)); }
                |
                values = ParenthesedExpressionList() { updateSet.setValues(values); }
            )
        )
    )

    (
        LOOKAHEAD(2) (
            ","
            tableColumn=Column() "=" valueExpression=Expression()
            { updateSets.add( new UpdateSet (tableColumn, valueExpression)); }
            |
            (
                { updateSet = new UpdateSet(); updateSets.add(updateSet); }
                columns = ParenthesedExpressionList() { updateSet.setColumns(columns); }
                "="
                (
                    LOOKAHEAD(3) valueExpression = ParenthesedSelect() { updateSet.setValues( new ExpressionList(valueExpression)); }
                    |
                    values = ParenthesedExpressionList() { updateSet.setValues(values); }
                )
            )
        )
    )*

    {
        return updateSets;
    }
}

List<Partition> Partitions():
{
    List<Partition> partitions = new ArrayList<Partition>();
    Column tableColumn;
    Expression valueExpression = null;
}
{
    (
        (
            tableColumn=Column() [ "=" valueExpression=Expression() ]
            { partitions.add( new Partition (tableColumn, valueExpression)); }
        )
    )

    (
        LOOKAHEAD(2) (
            ","
            tableColumn=Column() [ "=" valueExpression=Expression() ]
            { partitions.add( new Partition (tableColumn, valueExpression)); }
        )
    )*

    {
        return partitions;
    }
}

Insert InsertWithWithItems( List<WithItem<?>> withItems ):
{
    Insert insert;
}
{
    insert = Insert() { insert.setWithItemsList( withItems );
    return insert;
}
}

Insert Insert():
{
    Insert insert = new Insert();
    Table table = null;
    List<WithItem<?>> with = null;
    Column tableColumn = null;
    ExpressionList<Column> columns = new ExpressionList<Column>();
    List<Partition> partitions = new ArrayList<Partition>();
    Expression exp = null;
    ReturningClause returningClause;
    Select select = null;
    Token tk = null;
    InsertModifierPriority modifierPriority = null;
    boolean modifierIgnore = false;

    List<UpdateSet> updateSets;
    List<UpdateSet> duplicateUpdateSets;

    String name = null;
    boolean useAs = false;
    OutputClause outputClause = null;

    InsertConflictTarget conflictTarget = null;
    InsertConflictAction conflictAction = null;

    InsertDuplicateAction duplicateAction = null;
}
{
    <K_INSERT> { insert.setOracleHint(getOracleHint()); }

    [
        LOOKAHEAD(2) (tk = <K_LOW_PRIORITY> | tk = <K_DELAYED> | tk = <K_HIGH_PRIORITY>)
        {
            if (tk!=null)
            modifierPriority = InsertModifierPriority.from(tk.image);
        }
    ]
    [ LOOKAHEAD(2) <K_IGNORE>{ modifierIgnore = true; }]
    [ LOOKAHEAD(2) (
        <K_OVERWRITE> <K_TABLE> { insert.setOverwrite(true); insert.setTableKeyword(true); }
        | <K_INTO> [ LOOKAHEAD(2) <K_TABLE> { insert.setTableKeyword(true); }]
        )
    ]   table=Table()
    [ LOOKAHEAD(2) <K_PARTITION> "(" partitions=Partitions() ")" ]

    [ LOOKAHEAD(2) [<K_AS> { useAs = true; } ] name=RelObjectNameWithoutValue() { table.setAlias(new Alias(name,useAs)); }]

    [ LOOKAHEAD(2) "(" columns=ColumnList() ")"  ]

    [ LOOKAHEAD(2) <K_OVERRIDING> <K_SYSTEM> <K_VALUE> { insert.setOverriding(true); } ]

    [ outputClause = OutputClause() { insert.setOutputClause(outputClause); } ]

    (
        <K_DEFAULT> <K_VALUES> { insert.setOnlyDefaultValues(true); }
        |
        (
            <K_SET> updateSets = UpdateSets() { insert.withSetUpdateSets(updateSets); }
        )
        |
        select = Select()
    )

    [ LOOKAHEAD(2) <K_ON> <K_DUPLICATE> <K_KEY> <K_UPDATE>
                 duplicateAction = InsertDuplicateAction() { insert.setDuplicateAction(duplicateAction); }
    ]

    [
        <K_ON> <K_CONFLICT>
        [ conflictTarget = InsertConflictTarget() ]
        conflictAction = InsertConflictAction() { insert.withConflictTarget(conflictTarget).setConflictAction(conflictAction); }
    ]

    [ returningClause = ReturningClause() { insert.setReturningClause(returningClause); } ]

    {
        if (!columns.isEmpty()) {
            insert.setColumns(columns);
        }
        if (!partitions.isEmpty()) {
            insert.setPartitions(partitions);
        }
        return insert.withWithItemsList(with)
              .withSelect(select)
              .withTable(table)
              .withModifierPriority(modifierPriority)
              .withModifierIgnore(modifierIgnore);
    }
}

InsertConflictTarget  InsertConflictTarget():
{
    String indexColumnName;
    ArrayList<String> indexColumnNames = new ArrayList<String>();
    Expression indexExpression = null;
    Expression whereExpression = null;
    String constraintName = null ;
}
{
    (
        (
            "("
            indexColumnName = RelObjectNameExt2() { indexColumnNames.add(indexColumnName); }
            ( "," indexColumnName = RelObjectNameExt2() { indexColumnNames.add(indexColumnName); } )*
//            |
//            (
//                "(" indexExpression = Expression() ")"
//            )

            ")"
            [ whereExpression = WhereClause() ]
        )
        |
        (
         <K_ON> <K_CONSTRAINT> constraintName = RelObjectNameExt2()
        )
    )

    { return new InsertConflictTarget(indexColumnNames, indexExpression, whereExpression, constraintName); }
}

InsertConflictAction InsertConflictAction():
{
    InsertConflictAction conflictAction;
    Expression whereExpression = null;
    List<UpdateSet> updateSets;
}
{
    (
        LOOKAHEAD(2) (
            <K_DO> <K_NOTHING> { conflictAction = new InsertConflictAction( ConflictActionType.DO_NOTHING ); }
        )
        |
        (
            <K_DO> <K_UPDATE> <K_SET> { conflictAction = new InsertConflictAction( ConflictActionType.DO_UPDATE ); }
            updateSets = UpdateSets() { conflictAction.setUpdateSets(updateSets); }
            [ whereExpression = WhereClause() ]
        )
    )

    { return conflictAction
                .withWhereExpression(whereExpression); }
}

InsertDuplicateAction InsertDuplicateAction():
{
    InsertDuplicateAction duplicateAction;
    Expression whereExpression = null;
    List<UpdateSet> updateSets;
}
{
    (
        LOOKAHEAD(2) (
            <K_NOTHING> { duplicateAction = new InsertDuplicateAction( ConflictActionType.NOTHING ); }
        )
        |
        (
            { duplicateAction = new InsertDuplicateAction( ConflictActionType.DO_UPDATE ); }
            updateSets = UpdateSets() { duplicateAction.setUpdateSets(updateSets); }
            [ whereExpression = WhereClause() ]
        )
    )

    { return duplicateAction
                .withWhereExpression(whereExpression); }
}


OutputClause OutputClause():
{
    List<SelectItem<?>> selectItemList = null;
    UserVariable tableVariable = null;
    Table outputTable = null;
    List<String> columnList = null;
}
{
    <K_OUTPUT>
    selectItemList = SelectItemsList()
    [   <K_INTO>
        (
            tableVariable = UserVariable()
            |
            outputTable = Table()
        )
        [
           LOOKAHEAD(2)  columnList = ColumnsNamesList()
        ]
    ]

    {
        return new OutputClause(selectItemList, tableVariable, outputTable, columnList);
    }
}

Upsert Upsert():
{
    Upsert upsert = new Upsert();
    Table table = null;
    ExpressionList<Column> columns;
    List<UpdateSet> updateSets;

    Select select = null;
    List<UpdateSet> duplicateUpdateSets;
    InsertDuplicateAction duplicateAction = null;
    Token tk = null;
}
{
    (
        <K_UPSERT> { upsert.setUpsertType(UpsertType.UPSERT); }
        |
        <K_REPLACE> { upsert.setUpsertType(UpsertType.REPLACE); }
        |
        (
            <K_INSERT> <K_OR> <K_REPLACE> { upsert.setUpsertType(UpsertType.INSERT_OR_REPLACE); }
        )
    )
    [ LOOKAHEAD(2) <K_INTO> { upsert.setUsingInto(true); } ]

    table=Table() { upsert.setTable(table); }

    [ LOOKAHEAD(2) columns = ParenthesedColumnList() { upsert.setColumns(columns); } ]
    (
        (
            <K_SET>
            updateSets = UpdateSets() { upsert.setUpdateSets(updateSets); }
        )
        |
        (
            select = Select() { upsert.setSelect(select); }
        )
    )

    [
        <K_ON> <K_DUPLICATE> <K_KEY> <K_UPDATE>
        duplicateAction = InsertDuplicateAction() { upsert.setDuplicateAction(duplicateAction); }
    ]

    {
        return upsert;
    }
}

Delete DeleteWithWithItems( List<WithItem<?>> withItems ):
{
    Delete delete;
}
{
    delete = Delete() { delete.setWithItemsList( withItems );
    return delete;
}
}

Delete Delete():
{
    Delete delete = new Delete();
    Table table = null;
    List<Table> tables = new ArrayList<Table>();
    List<WithItem<?>> with = null;
    FromItem usingFromItem = null;
    List<FromItem> usingFromItemList = new ArrayList<FromItem>();
    List<Join> joins = null;
    Expression where = null;
    PreferringClause preferringClause = null;
    Limit limit = null;
    List<OrderByElement> orderByElements;
    boolean hasFrom = false;
    Token tk = null;
    DeleteModifierPriority modifierPriority = null;
    boolean modifierIgnore = false;
    boolean modifierQuick = false;

    ReturningClause returningClause;
    OutputClause outputClause;
}
{
    <K_DELETE> { delete.setOracleHint(getOracleHint()); }
    [ LOOKAHEAD(2) <K_LOW_PRIORITY> { modifierPriority = DeleteModifierPriority.LOW_PRIORITY; }]
    [ LOOKAHEAD(2) <K_QUICK> { modifierQuick = true; }]
    [ LOOKAHEAD(2) <K_IGNORE> { modifierIgnore = true; }]
    [LOOKAHEAD(4) (table=TableWithAlias() { tables.add(table); }
          ("," table=TableWithAlias() { tables.add(table); } )*
    [ outputClause = OutputClause() {delete.setOutputClause(outputClause); } ]
    <K_FROM> | <K_FROM>) { hasFrom = true; }]

    [ LOOKAHEAD(3) table=TableWithAlias() [ LOOKAHEAD(2)  joins=JoinsList() ] ]
    [ <K_USING> usingFromItem=FromItem() { usingFromItemList.add(usingFromItem); }
          ("," usingFromItem=FromItem() { usingFromItemList.add(usingFromItem); } )*]
    [where=WhereClause() { delete.setWhere(where); } ]
    [preferringClause=PreferringClause() { delete.setPreferringClause(preferringClause);} ]
    [orderByElements = OrderByElements() { delete.setOrderByElements(orderByElements); } ]
    [limit=PlainLimit() {delete.setLimit(limit); } ]

    [ returningClause = ReturningClause() { delete.setReturningClause(returningClause); } ]
    {
        if (joins != null && joins.size() > 0) {
            delete.setJoins(joins);
        }
        return delete.withWithItemsList(with)
              .withTables(tables)
              .withTable(table)
              .withHasFrom(hasFrom)
              .withUsingFromItemList(usingFromItemList)
              .withModifierPriority(modifierPriority)
              .withModifierIgnore(modifierIgnore)
              .withModifierQuick(modifierQuick);
    }
}

Statement Merge( List<WithItem<?>> with ) : {
    Merge merge = new Merge();
    Table table;
    FromItem fromItem;
    Expression condition;
    List<MergeOperation> operations;
    OutputClause outputClause;
}
{
    <K_MERGE> { merge.setOracleHint(getOracleHint()); } <K_INTO> table=TableWithAlias() { merge.setTable(table); }
    <K_USING> fromItem = FromItem() { merge.setFromItem(fromItem); }
    <K_ON> condition = Expression() { merge.setOnCondition(condition); }

    operations = MergeOperations() { merge.setOperations(operations); }

    [ outputClause = OutputClause() { merge.setOutputClause(outputClause); } ]

    { return merge.withWithItemsList(with); }
}

List<MergeOperation> MergeOperations() : {
    List<MergeOperation> operationsList = new ArrayList<MergeOperation>();
    MergeOperation operation;
}
{
    (
        LOOKAHEAD(2) operation = MergeWhenMatched() { operationsList.add(operation); }
        |
        operation = MergeWhenNotMatched() { operationsList.add(operation); }
    )*
    { return operationsList; }
}

MergeOperation MergeWhenMatched() : {
    Expression predicate = null;
    MergeOperation operation;
}
{
    <K_WHEN> <K_MATCHED>
    [ <K_AND> predicate = Expression() ]
    <K_THEN>
    (
        operation = MergeDeleteClause(predicate) | operation = MergeUpdateClause(predicate)
    )
    { return operation; }
}

MergeOperation MergeDeleteClause(Expression predicate) : {
    MergeDelete md = new MergeDelete().withAndPredicate(predicate);
}
{
    <K_DELETE> { return md; }
}

MergeOperation MergeUpdateClause(Expression predicate) : {
    MergeUpdate mu = new MergeUpdate().withAndPredicate(predicate);
    List<UpdateSet> updateSets;
    Expression condition;
}
{
    <K_UPDATE> <K_SET> updateSets = UpdateSets() { mu.setUpdateSets(updateSets); }
    [ <K_WHERE> condition = Expression() { mu.setWhereCondition(condition); }]
    [ LOOKAHEAD(2)  <K_DELETE> <K_WHERE> condition = Expression() { mu.setDeleteWhereCondition(condition); } ]
    { return mu; }
}

MergeOperation MergeWhenNotMatched() : {
    MergeInsert mi = new MergeInsert();
    Expression predicate;
    ExpressionList<Column> columns;
    ExpressionList expList;
    Expression condition;
}
{
    <K_WHEN> <K_NOT> <K_MATCHED>
    [ <K_AND> predicate = Expression() { mi.setAndPredicate(predicate); } ]
    <K_THEN>
        <K_INSERT>
        [ "(" columns = ColumnList() ")"
            {
                mi.setColumns( new ParenthesedExpressionList<Column>(columns) );
            }
        ]
        <K_VALUES> "(" expList = SimpleExpressionList() ")"
        {
            mi.setValues( new ParenthesedExpressionList(expList) );
        }

        [ <K_WHERE> condition = Expression() { mi.setWhereCondition(condition); }]

        { return mi; }
}

// table names seem to allow ":" delimiters, e.g. for Informix see #1134
ObjectNames RelObjectNames() : {
    String token = null;
    Token delimiter = null;
    List<String> data = new ArrayList<String>();
    List<String> delimiters = new ArrayList<String>();
} {
    token = RelObjectNameExt() { data.add(token); }
    (
        LOOKAHEAD (2) (
            ( delimiter = "..."  { delimiters.add("."); data.add(null); delimiters.add("."); data.add(null); delimiters.add("."); } )
            |
            ( delimiter = ".."  { delimiters.add("."); data.add(null); delimiters.add("."); } )
            |
            ( ( delimiter = "." | delimiter = ":" ) { delimiters.add(delimiter.image); } )
        )

        token = RelObjectNameExt2() { data.add(token); }
    ) *

    { return new ObjectNames(data, delimiters); }
}

// column names do not allow ":" delimeters as those represent JSON `GET` operators
ObjectNames ColumnIdentifier() : {
    String token = null;
    Token delimiter = null;
    List<String> data = new ArrayList<String>();
    List<String> delimiters = new ArrayList<String>();
} {
    token = RelObjectNameExt() { data.add(token); }
    (
        LOOKAHEAD (2) (
            ( delimiter = "..."  { delimiters.add("."); data.add(null); delimiters.add("."); data.add(null); delimiters.add("."); } )
            |
            ( delimiter = ".."  { delimiters.add("."); data.add(null); delimiters.add("."); } )
            |
            ( delimiter = "."  { delimiters.add(delimiter.image); } )
        )

        token = RelObjectNameExt2() { data.add(token); }
    ) *

    { return new ObjectNames(data, delimiters); }
}

// See: http://technet.microsoft.com/en-us/library/ms187879%28v=sql.105%29.aspx
Column Column() #Column :
{
    ObjectNames data = null;
    ArrayConstructor arrayConstructor = null;
    Token tk = null;
}
{
    data = ColumnIdentifier()
    [ LOOKAHEAD(2) <K_COMMENT> tk=<S_CHAR_LITERAL> ]
    // @todo: we better should return a SEQUENCE instead of a COLUMN
    [  LOOKAHEAD(2) "." <K_NEXTVAL> { data.getNames().add("nextval"); } ]

    [ LOOKAHEAD(2) arrayConstructor = ArrayConstructor(false) ]
    {
        Column col = new Column(data.getNames(), data.getDelimiters());
        if (tk != null) { col.withCommentText(tk.image); }
        if (arrayConstructor!=null) {
            col.setArrayConstructor(arrayConstructor);
        }
        linkAST(col,jjtThis);
        return col;
    }
}

/*
The following tokens are allowed as Names for Schema, Table, Column and Aliases
*/

// Generated Code! Please do not edit manually.
// Instead:
// 1) define the ALL_RESERVED_KEYWORDS in the PARSER DECLARATION above (line 157 ff)
// 2) run the Gradle Task :JSQLParser:updateKeywords, which would update/replace the content of this method
String RelObjectNameWithoutValue() :
{    Token tk = null; }
{
    ( tk=<DATA_TYPE> | tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> |  tk=<K_DATE_LITERAL> | tk=<K_DATETIMELITERAL> | tk=<K_STRING_FUNCTION_NAME> | tk=<K_ISOLATION> | tk=<K_TIME_KEY_EXPR> | tk=<K_TEXT_LITERAL> 
       | tk="ACTION" | tk="ACTIVE" | tk="ADD" | tk="ADVANCE" | tk="ADVISE" | tk="AGAINST" | tk="AGGREGATE" | tk="ALGORITHM" | tk="ALIGN" | tk="ALTER" | tk="ALWAYS" | tk="ANALYZE" | tk="APPEND_ONLY" | tk="APPLY" | tk="APPROXIMATE" | tk="ARCHIVE" | tk="ARRAY" | tk="ASC" | tk="ASYMMETRIC" | tk="AT" | tk="AUTHORIZATION" | tk="AUTO" | tk="AUTO_INCREMENT" | tk="AZURE" | tk="BASE64" | tk="BEFORE" | tk="BEGIN" | tk="BERNOULLI" | tk="BINARY" | tk="BIT" | tk="BLOBSTORAGE" | tk="BLOCK" | tk="BOOLEAN" | tk="BRANCH" | tk="BROWSE" | tk="BUFFERS" | tk="BY" | tk="BYTE" | tk="BYTES" | tk="CACHE" | tk="CALL" | tk="CASCADE" | tk="CASE" | tk="CAST" | tk="CERTIFICATE" | tk="CHANGE" | tk="CHANGES" | tk="CHAR" | tk="CHARACTER" | tk="CHECKPOINT" | tk="CLOSE" | tk="CLOUD" | tk="COALESCE" | tk="COLLATE" | tk="COLUMN" | tk="COLUMNS" | tk="COMMENT" | tk="COMMENTS" | tk="COMMIT" | tk="CONCURRENTLY" | tk="CONFLICT" | tk="CONSTRAINTS" | tk="CONVERT" | tk="CORRESPONDING" | tk="COSTS" | tk="COUNT" | tk="CREATED" | tk="CS" | tk="CYCLE" | tk="DATA" | tk="DATABASE" | tk="DATETIME" | tk="DBA_RECYCLEBIN" | tk="DDL" | tk="DECLARE" | tk="DEFAULTS" | tk="DEFERRABLE" | tk="DELAYED" | tk="DELETE" | tk="DELIMIT" | tk="DELIMITER" | tk="DESC" | tk="DESCRIBE" | tk="DISABLE" | tk="DISCARD" | tk="DISCONNECT" | tk="DIV" | tk="DML" | tk="DO" | tk="DOMAIN" | tk="DRIVER" | tk="DROP" | tk="DUMP" | tk="DUPLICATE" | tk="ELEMENTS" | tk="EMIT" | tk="ENABLE" | tk="ENCODING" | tk="ENCRYPTION" | tk="END" | tk="ENFORCED" | tk="ENGINE" | tk="ERROR" | tk="ESCAPE" | tk="EXA" | tk="EXCHANGE" | tk="EXCLUDE" | tk="EXCLUDING" | tk="EXCLUSIVE" | tk="EXEC" | tk="EXECUTE" | tk="EXPLAIN" | tk="EXPLICIT" | tk="EXPORT" | tk="EXTENDED" | tk="EXTRACT" | tk="FILTER" | tk="FIRST" | tk="FLUSH" | tk="FN" | tk="FOLLOWING" | tk="FORMAT" | tk="FULLTEXT" | tk="FUNCTION" | tk="GRANT" | tk="GROUP_CONCAT" | tk="GUARD" | tk="HASH" | tk="HIGH" | tk="HIGH_PRIORITY" | tk="HISTORY" | tk="HOPPING" | tk="IDENTIFIED" | tk="IDENTITY" | tk="INCLUDE" | tk="INCLUDE_NULL_VALUES" | tk="INCLUDING" | tk="INCREMENT" | tk="INDEX" | tk="INFORMATION" | tk="INSERT" | tk="INTERLEAVE" | tk="INTERPRET" | tk="INVALIDATE" | tk="INVERSE" | tk="INVISIBLE" | tk="ISNULL" | tk="JDBC" | tk="JSON" | tk="JSON_ARRAY" | tk="JSON_ARRAYAGG" | tk="JSON_OBJECT" | tk="JSON_OBJECTAGG" | tk="KEEP" | tk="KEY" | tk="KEYS" | tk="KEY_BLOCK_SIZE" | tk="KILL" | tk="LAST" | tk="LEADING" | tk="LESS" | tk="LEVEL" | tk="LINK" | tk="LOCAL" | tk="LOCK" | tk="LOCKED" | tk="LOG" | tk="LONGTEXT" | tk="LOOP" | tk="LOW" | tk="LOW_PRIORITY" | tk="LTRIM" | tk="MATCH" | tk="MATCHED" | tk="MATCH_ALL" | tk="MATCH_ANY" | tk="MATCH_PHRASE" | tk="MATCH_PHRASE_PREFIX" | tk="MATCH_REGEXP" | tk="MATERIALIZED" | tk="MAX" | tk="MAXVALUE" | tk="MEDIUMTEXT" | tk="MEMBER" | tk="MERGE" | tk="MIN" | tk="MINVALUE" | tk="MODE" | tk="MODIFY" | tk="MOVEMENT" | tk="NAME" | tk="NAMES" | tk="NEVER" | tk="NEXT" | tk="NO" | tk="NOCACHE" | tk="NOKEEP" | tk="NOLOCK" | tk="NOMAXVALUE" | tk="NOMINVALUE" | tk="NONE" | tk="NOORDER" | tk="NOTHING" | tk="NOTNULL" | tk="NOVALIDATE" | tk="NOWAIT" | tk="NULLS" | tk="OF" | tk="OFF" | tk="OPEN" | tk="ORA" | tk="ORDINALITY" | tk="OVER" | tk="OVERFLOW" | tk="OVERLAPS" | tk="OVERRIDING" | tk="OVERWRITE" | tk="PADDING" | tk="PARALLEL" | tk="PARENT" | tk="PARSER" | tk="PARTITION" | tk="PARTITIONING" | tk="PATH" | tk="PERCENT" | tk="PLACING" | tk="PLAN" | tk="PLUS" | tk="POLICY" | tk="PRECEDING" | tk="PRIMARY" | tk="PURGE" | tk="QUERY" | tk="QUICK" | tk="QUIESCE" | tk="RANGE" | tk="RAW" | tk="READ" | tk="REBUILD" | tk="RECURSIVE" | tk="RECYCLEBIN" | tk="REFERENCES" | tk="REFRESH" | tk="REGEXP" | tk="REGEXP_LIKE" | tk="REGISTER" | tk="REJECT" | tk="REMOTE" | tk="REMOVE" | tk="RENAME" | tk="REORGANIZE" | tk="REPAIR" | tk="REPEATABLE" | tk="REPLACE" | tk="RESET" | tk="RESPECT" | tk="RESTART" | tk="RESTRICT" | tk="RESTRICTED" | tk="RESUMABLE" | tk="RESUME" | tk="RETURN" | tk="RLIKE" | tk="ROLLBACK" | tk="ROLLUP" | tk="ROOT" | tk="ROW" | tk="ROWS" | tk="RR" | tk="RS" | tk="RTRIM" | tk="SAFE_CAST" | tk="SAFE_CONVERT" | tk="SAVEPOINT" | tk="SCHEMA" | tk="SECURE" | tk="SECURITY" | tk="SEED" | tk="SEPARATOR" | tk="SEQUENCE" | tk="SESSION" | tk="SETS" | tk="SHARE" | tk="SHOW" | tk="SHUTDOWN" | tk="SIBLINGS" | tk="SIGNED" | tk="SIMILAR" | tk="SIZE" | tk="SKIP" | tk="SPATIAL" | tk="STORED" | tk="STREAM" | tk="STRICT" | tk="STRING" | tk="STRUCT" | tk="SUMMARIZE" | tk="SUSPEND" | tk="SWITCH" | tk="SYMMETRIC" | tk="SYNONYM" | tk="SYSTEM" | tk="SYSTEM_TIME" | tk="SYSTEM_TIMESTAMP" | tk="SYSTEM_VERSION" | tk="TABLE" | tk="TABLESPACE" | tk="TEMP" | tk="TEMPORARY" | tk="TEXT" | tk="THAN" | tk="THEN" | tk="TIMEOUT" | tk="TIMESTAMPTZ" | tk="TIMEZONE" | tk="TINYTEXT" | tk="TO" | tk="TRIGGER" | tk="TRUNCATE" | tk="TRY_CAST" | tk="TRY_CONVERT" | tk="TUMBLING" | tk="TYPE" | tk="UNLIMITED" | tk="UNLOGGED" | tk="UNQIESCE" | tk="UNSIGNED" | tk="UPDATE" | tk="UPSERT" | tk="UR" | tk="USER" | tk="VALIDATE" | tk="VALIDATION" | tk="VERBOSE" | tk="VERSION" | tk="VIEW" | tk="VISIBLE" | tk="VOLATILE" | tk="WAIT" | tk="WITHIN" | tk="WITHOUT" | tk="WITHOUT_ARRAY_WRAPPER" | tk="WORK" | tk="XML" | tk="XMLAGG" | tk="XMLDATA" | tk="XMLSCHEMA" | tk="XMLTEXT" | tk="XSINIL" | tk="YAML" | tk="YES" | tk="ZONE" )
    { return tk.image; }
}

/*
These tokens can be used as names for Schema and Tables and Columns
BUT NOT for Aliases (without quoting)
*/
String RelObjectName() :
{    Token tk = null; String result = null; }
{
    (result = RelObjectNameWithoutValue()
        | tk=<K_GROUP> | tk=<K_INTERVAL> | tk=<K_ON>  | tk=<K_START> | tk=<K_TOP> | tk=<K_VALUE>
        | tk=<K_VALUES> | tk=<K_CREATE> | tk=<K_TABLES> | tk=<K_CONNECT> | tk=<K_IGNORE >
        | tk=<K_QUALIFY> | tk=<K_DEFAULT>
        )

    { return tk!=null ? tk.image : result; }
}

String RelObjectNameWithoutStart() :
{    Token tk = null; String result = null; }
{
    (result = RelObjectNameWithoutValue() | tk=<K_TOP> | tk=<K_VALUE> | tk=<K_VALUES>
        | tk=<K_INTERVAL>
        )

    { return tk!=null ? tk.image : result; }
}

/*
Extended version of object names.

These tokens can be used as names for Schema and Tables and Columns
BUT NOT for Aliases (without quoting)

*/
String RelObjectNameExt():
{ Token tk = null;
  String result=null;
}
{
    ( result=RelObjectName() | tk=<K_ALL> | tk=<K_ANY>  | tk=<K_SOME> | tk=<K_LEFT> | tk=<K_RIGHT> | tk=<K_SET>
        | tk=<K_IF> | tk=<K_IIF> | tk=<K_OPTIMIZE> | tk=<K_LIMIT>
        | tk=<K_OFFSET> | tk=<K_PROCEDURE> | tk=<K_PUBLIC>
        | tk=<K_CASEWHEN> | tk=<K_IN> | tk=<K_GROUPING> | tk=<K_ORDER>
        | tk=<K_NEXTVAL>
        | tk=<K_GLOBAL>
        )
    { return tk!=null ? tk.image : result; }
}

/*
Extended usage of object names - part 2. Using within multipart names as following parts.

These tokens can be used as names for Tables and Columns
BUT NOT for Schema or  Aliases (without quoting)

*/
String RelObjectNameExt2():
{ Token tk = null;
  String result=null;
}
{
    ( result=RelObjectNameExt() | tk=<K_FROM> | tk=<K_SELECT> | tk=<K_CURRENT> )
    { return tk!=null ? tk.image : result; }
}

Table Table() #TableName :
{
    //String serverName = null, databaseName = null, schemaName = null, tableName = null;
    ObjectNames data = null;
    Token fileNameToken = null;
    Table table;
    String timeTravelStr = null;
}
{
    (
        data = RelObjectNames() [ LOOKAHEAD(2) timeTravelStr = TimeTravelBeforeAlias() ]
        {
            table = new Table(data.getNames());
            table.setTimeTravel(timeTravelStr);
        }
        |
        fileNameToken = <S_CHAR_LITERAL>
        {
            // don't split name parts
            table = new Table(fileNameToken.image, false);
        }
    )

    {
        linkAST(table,jjtThis);
        return table;
    }
}

Table TableWithAlias():
{
    Table table = null;
    Alias alias = null;
}
{
    table=Table()
    [ LOOKAHEAD(2) alias=Alias() { table.setAlias(alias); }]
    { return table; }
}

Table TableWithAliasAndMysqlIndexHint():
{
    Table table = null;
    Alias alias = null;
    MySQLIndexHint indexHint = null;
}
{
    table=Table()
    [ LOOKAHEAD(2) alias=Alias() { table.setAlias(alias); } ]
    [ LOOKAHEAD(2) indexHint=MySQLIndexHint() { table.setHint(indexHint); } ]
    { return table; }
}

Number Number():
{
    Token token;
    Number number;
}
{
    (
        token = <S_DOUBLE> { number = Double.valueOf(token.image); }
        |
        token = <S_LONG> { number = Long.valueOf(token.image); }
    )

    {
        return number;
    }
}

SampleClause SampleClause():
{
    Token token;
    SampleClause sampleClause;
    String keyword;
    String method=null;
    Number percentageArgument;
    String percentageUnit = null;
    Number repeatArgument=null;
    Number seedArgument=null;
}
{
    (
        (
            // Oracle
            token=<K_SAMPLE> { keyword = token.image; }
            [ token=<K_BLOCK> { method = token.image; } ]
        )
        |
        (
            // SQL:2016 compliant
            token = <K_TABLESAMPLE> { keyword = token.image; }
            ( token = <K_SYSTEM> | token = <K_BERNOULLI> ) { method = token.image; }
        )
        |
        (
            // Duck DB
            <K_USING> <K_SAMPLE> { keyword = "USING SAMPLE"; }
            ( token = <K_SYSTEM> | token = <K_BERNOULLI> ) { method = token.image; }
        )
    )

    "(" percentageArgument = Number()
    [
        "%" { percentageUnit="%"; }
        |
        <K_PERCENT> { percentageUnit="PERCENT"; }
        |
        <K_ROWS> { percentageUnit="ROWS"; }
    ]
    ")"

    [ LOOKAHEAD(2) <K_REPEATABLE> "(" repeatArgument = Number() ")" ]

    [ LOOKAHEAD(2) <K_SEED> "(" seedArgument = Number() ")" ]

    {
        return new SampleClause(keyword, method, percentageArgument, percentageUnit, repeatArgument, seedArgument);
    }
}

Select SelectWithWithItems( List<WithItem<?>> withItems):
{
    Select select;
}
{
    select = Select() { select.setWithItemsList( withItems );
    return select;
}
}

Select Select() #Select:
{
    Select select = null;
    List<WithItem<?>> with = null;
    List<OrderByElement> orderByElements = null;
    Limit limit = null;
    Offset offset = null;
    Fetch fetch = null;
    WithIsolation withIsolation = null;
    Alias alias = null;
}
{

    [ with=WithList() ]
    (
        LOOKAHEAD(3) select = FromQuery()
        |
        (
            (
                LOOKAHEAD(3) select = PlainSelect()
                |
                LOOKAHEAD(3) select = Values()
                |
                LOOKAHEAD(3) select = ParenthesedSelect() [ LOOKAHEAD(2) alias = Alias() {select.setAlias(alias);} ]
            )
            [ LOOKAHEAD(2) select = FromQueryFromSelect(select) ]
            [ LOOKAHEAD(2) select = SetOperationList(select) ]

            [ LOOKAHEAD(<K_ORDER> <K_BY>) orderByElements = OrderByElements() { select.setOrderByElements(orderByElements); } ]

            [ LOOKAHEAD(<K_LIMIT>) limit=LimitWithOffset() {select.setLimit(limit);} ]
            [ LOOKAHEAD(<K_OFFSET>) offset = Offset() { select.setOffset(offset);} ]
            [ LOOKAHEAD(<K_FETCH>) fetch = Fetch() { select.setFetch(fetch);} ]
            [ LOOKAHEAD(<K_WITH> <K_ISOLATION>) withIsolation = WithIsolation() { select.setIsolation(withIsolation);} ]
        )
    )
    {
        linkAST(select, jjtThis);
        return select.withWithItemsList(with);
    }
}

FromQuery FromQuery() #FromQuery:
{
    FromQuery fromQuery;
    FromItem fromItem;
    List<LateralView> lateralViews = null;
    List<Join> joins = null;
    PipeOperator pipeOperator;
}
{
    <K_FROM> fromItem = FromItem() { fromQuery = new FromQuery(fromItem); }
    [ LOOKAHEAD(2) lateralViews=LateralViews() { fromQuery.setLateralViews(lateralViews); } ]
    [ LOOKAHEAD(2) joins=JoinsList() { fromQuery.setJoins(joins); } ]
    (
        LOOKAHEAD(2) "|>" pipeOperator = PipeOperator() { fromQuery.add(pipeOperator); }
    )*

    {
        return fromQuery;
    }
}

FromQuery FromQueryFromSelect(Select select):
{
    FromQuery fromQuery;
    FromItem fromItem;
    PipeOperator pipeOperator;
}
{
    "|>" pipeOperator = PipeOperator()
    {
        fromQuery = new FromQuery(select, false);
        fromQuery.add(pipeOperator);
    }
    (
        LOOKAHEAD(2) "|>" pipeOperator = PipeOperator()
        { fromQuery.add(pipeOperator); }
    )*

    {
        return fromQuery;
    }
}

PipeOperator PipeOperator() #PipeOperator:
{
    PipeOperator operator;
}
{
    (
        // SELECT covers also EXTEND, WINDOW and RENAME
        operator = SelectPipeOperator()
        |
        operator = SetPipeOperator()
        |
        operator = DropPipeOperator()
        |
        LOOKAHEAD(2) operator = AsPipeOperator()
        |
        operator = WherePipeOperator()
        |
        operator = LimitPipeOperator()
        |
        LOOKAHEAD(2) operator = AggregatePipeOperator()
        |
        operator = OrderByPipeOperator()
        |
        // covers UNION, INTERSET, EXCEPT
        operator = SetOperationPipeOperator()
        |
        operator = JoinPipeOperator()
        |
        operator = CallPipeOperator()
        |
        operator = TableSamplePipeOperator()
        |
        operator = PivotPipeOperator()
        |
        operator = UnPivotPipeOperator()
    )
    {
        return operator;
    }
}

SelectPipeOperator SelectPipeOperator():
{
    Token operatorKeyToken;
    Token modifierToken = null;
    SelectPipeOperator selectPipeOperator;
    SelectItem<?> selectItem;
}
{
    (
        ( operatorKeyToken = <K_SELECT> [ LOOKAHEAD(2) ( modifierToken=<K_DISTINCT> | modifierToken=<K_ALL> ) ] )
        |
        operatorKeyToken = <K_EXTEND>
        |
        operatorKeyToken = <K_WINDOW>
        |
        operatorKeyToken = <K_RENAME>
    )
    selectItem = SelectItem()
    { selectPipeOperator = new SelectPipeOperator(operatorKeyToken.image, selectItem, modifierToken !=null ? modifierToken.image : null); }

    ( LOOKAHEAD(2) "," selectItem = SelectItem() { selectPipeOperator.add(selectItem); } )*

    {
        return selectPipeOperator;
    }
}

WherePipeOperator WherePipeOperator():
{
    WherePipeOperator wherePipeOperator;
    Expression expression;
}
{
    <K_WHERE> expression = Expression()
    {
        wherePipeOperator = new WherePipeOperator(expression);
        return wherePipeOperator;
    }
}

String OrderSuffix():
{
    Token token =null;
    String orderSuffix = null;
}
{
    ( token = <K_ASC> | token = <K_DESC> ) { orderSuffix = token.image; }
    [ LOOKAHEAD(2) <K_NULLS> ( token = <K_FIRST> | token = <K_LAST> ) { orderSuffix += " NULLS " + token.image; } ]

    {
        return orderSuffix;
    }
}

AggregatePipeOperator AggregatePipeOperator():
{
    AggregatePipeOperator aggregatePipeOperator;
    SelectItem<?> selectItem;
    Token token =null;
    String orderSuffix = null;
}
{
    <K_AGGREGATE>
    selectItem = SelectItem() [ LOOKAHEAD(2) orderSuffix = OrderSuffix() ]
    { aggregatePipeOperator = new AggregatePipeOperator(selectItem, orderSuffix); orderSuffix=null; }

    ( LOOKAHEAD(2) "," selectItem = SelectItem() [ LOOKAHEAD(2) orderSuffix = OrderSuffix() ]
    { aggregatePipeOperator.add(selectItem, orderSuffix); orderSuffix=null; } )*

    [
        LOOKAHEAD(2) <K_GROUP> [ <K_AND> <K_ORDER> { aggregatePipeOperator.setShorthandOrdering(true); } ] <K_BY>
        selectItem = SelectItem() [ LOOKAHEAD(2) orderSuffix = OrderSuffix() ]
        { aggregatePipeOperator.addGroupItem(selectItem, orderSuffix); orderSuffix=null; }

        (
            LOOKAHEAD(2) "," selectItem = SelectItem() [ LOOKAHEAD(2) orderSuffix = OrderSuffix() ]
            { aggregatePipeOperator.addGroupItem(selectItem, orderSuffix); orderSuffix=null; }
        )*
    ]

    {
        return aggregatePipeOperator;
    }
}

OrderByPipeOperator OrderByPipeOperator():
{
    OrderByPipeOperator orderByPipeOperator;
    List<OrderByElement> orderByElements;
}
{
    orderByElements = OrderByElements()
    {
        orderByPipeOperator = new OrderByPipeOperator(orderByElements);
        return orderByPipeOperator;
    }
}

AsPipeOperator AsPipeOperator():
{
    AsPipeOperator asPipeOperator;
    Alias alias;
}
{
    <K_AS> alias = Alias()
    {
        asPipeOperator = new AsPipeOperator( alias.withUseAs(true) );
        return asPipeOperator;
    }
}

JoinPipeOperator JoinPipeOperator():
{
    JoinPipeOperator joinPipeOperator;
    Join join;
}
{
    join = JoinerExpression()
    {
        joinPipeOperator = new JoinPipeOperator(join);
        return joinPipeOperator;
    }
}

SetPipeOperator SetPipeOperator():
{
    SetPipeOperator setPipeOperator;
    List<UpdateSet> updateSets;
}
{
    <K_SET> updateSets = UpdateSets()
    {
        setPipeOperator = new SetPipeOperator(updateSets);
        return setPipeOperator;
    }
}

DropPipeOperator DropPipeOperator():
{
    DropPipeOperator dropPipeOperator;
    ExpressionList<Column> columns;
}
{
    <K_DROP> columns = ColumnList()
    {
        dropPipeOperator = new DropPipeOperator(columns);
        return dropPipeOperator;
    }
}

LimitPipeOperator LimitPipeOperator():
{
    LimitPipeOperator limitPipeOperator;
    Expression expression;
}
{
    <K_LIMIT> expression = Expression() { limitPipeOperator = new LimitPipeOperator(expression); }
    [ LOOKAHEAD(2) <K_OFFSET> expression = Expression() { limitPipeOperator.setOffsetExpression(expression); } ]

    {
        return limitPipeOperator;
    }
}

// see https://manticore-projects.com/SQL2016Parser/syntax_snapshot.html#corresponding-spec
String SetOperationModifier():
{
    Token tk;
    String modifier = "";
    String identifier;
}
{
    (
        LOOKAHEAD(2) (
             [ ( tk=<K_ALL> | tk="DISTINCT")  { modifier+=tk.image; } ]
            <K_BY> <K_NAME> { modifier+= " BY NAME"; }
            [
                "MATCHING" { modifier+= " MATCHING"; }
                "("
                identifier = RelObjectNameExt() { modifier+="(" + identifier; }
                ("," identifier = RelObjectNameExt()  { modifier+=", " + identifier; })*
                ")" { modifier+=")"; }
            ]
        )
        |
        (
            [ <K_STRICT>  { modifier+= " STRICT"; } ]
            <K_CORRESPONDING> { modifier+= " CORRESPONDING"; }
            [ (tk=<K_ALL> | tk="DISTINCT")  { modifier+=tk.image; } ]
            [
                <K_BY> { modifier+= " BY"; }[ (tk=<K_ALL> | tk="DISTINCT")  { modifier+=tk.image; } ]
                "("
                identifier = RelObjectNameExt() { modifier+="(" + identifier; }
                ("," identifier = RelObjectNameExt()  { modifier+=", " + identifier;})*
                ")" { modifier+=")"; }
            ]
        )
        |
        ( tk=<K_ALL> | tk=<K_DISTINCT> ) { modifier+=tk.image; }
    )
    {
        return modifier;
    }
}

SetOperationPipeOperator SetOperationPipeOperator():
{
    SetOperationPipeOperator setOperationPipeOperator = null;
    SetOperationType setOperationType;
    String modifier = null;
    ParenthesedSelect select;
}
{
    (
        (
            <K_UNION>  [ modifier=SetOperationModifier() ] { setOperationType = SetOperationType.UNION; }
            select = ParenthesedSelect() { setOperationPipeOperator = new SetOperationPipeOperator(select, setOperationType,  modifier); }
        )
        |
        (
            <K_INTERSECT> [ modifier=SetOperationModifier() ]  { setOperationType = SetOperationType.INTERSECT; }
            select = ParenthesedSelect() { setOperationPipeOperator = new SetOperationPipeOperator(select, setOperationType,  modifier); }
        )
        |
        (
            <K_EXCEPT> [ modifier=SetOperationModifier() ]  { setOperationType = SetOperationType.EXCEPT; }
            select = ParenthesedSelect() { setOperationPipeOperator = new SetOperationPipeOperator(select, setOperationType,  modifier); }
        )
    )

    (
        LOOKAHEAD(2) "," select = ParenthesedSelect() { setOperationPipeOperator.add(select); }
    )*

    {
        return setOperationPipeOperator;
    }
}

CallPipeOperator CallPipeOperator():
{
    TableFunction tableFunction;
    Alias alias=null;
}
{
    <K_CALL> tableFunction = TableFunction() [ LOOKAHEAD(2) alias = Alias() ]

    {
        return new CallPipeOperator(tableFunction, alias);
    }
}


TableSamplePipeOperator TableSamplePipeOperator():
{
    Token token;
}
{
    <K_TABLESAMPLE> <K_SYSTEM> "(" ( token=<S_DOUBLE> | token=<S_LONG> ) <K_PERCENT> ")"
    {
        return new TableSamplePipeOperator( token.image );
    }
}

PivotPipeOperator PivotPipeOperator():
{
    Function aggregateExpression;
    Column inputColumn;
    List<SelectItem<?>> pivotColumns;
    Alias alias = null;
}
{
    <K_PIVOT> "(" aggregateExpression=Function()
    <K_FOR> inputColumn=Column()
    <K_IN> "(" pivotColumns = SelectItemsList() ")"
    ")"
    [ LOOKAHEAD(2)  alias = Alias() ]
    {
        return new PivotPipeOperator(aggregateExpression, inputColumn, pivotColumns, alias);
    }
}

UnPivotPipeOperator UnPivotPipeOperator():
{
    Column valuesColumn;
    Column nameColumn;
    List<SelectItem<?>> pivotColumns;
    Alias alias = null;
}
{
    <K_UNPIVOT> "(" valuesColumn=Column()
    <K_FOR> nameColumn=Column()
    <K_IN> "(" pivotColumns = SelectItemsList() ")"
    ")"
    [ LOOKAHEAD(2) alias = Alias() ]
    {
        return new UnPivotPipeOperator(valuesColumn, nameColumn, pivotColumns, alias);
    }
}

TableStatement TableStatement():
{
    Table table = null;
    List<OrderByElement> orderByElements = null;
    Limit limit = null;
    Offset offset = null;
    TableStatement tableStatement = new TableStatement();
}{
    <K_TABLE>
    table = Table()
    { tableStatement.setTable(table); }
    [ LOOKAHEAD(<K_ORDER> <K_BY>) orderByElements = OrderByElements() { tableStatement.setOrderByElements(orderByElements); } ]
    [ LOOKAHEAD(<K_LIMIT>) limit = LimitWithOffset() { tableStatement.setLimit(limit);} ]
    [ LOOKAHEAD(<K_OFFSET>) offset = Offset() { tableStatement.setOffset(offset);} ]
    { return tableStatement; }
    /* Support operationList */
}

ParenthesedSelect ParenthesedSelect() #ParenthesedSelect:
{
    ParenthesedSelect parenthesedSelect = new ParenthesedSelect();
    Select select;
}
{
    "("
    select = Select()
    ")"
    {
        linkAST(parenthesedSelect,jjtThis);
        return parenthesedSelect.withSelect(select);
    }
}

ParenthesedInsert ParenthesedInsert() #ParenthesedInsert:
{
    ParenthesedInsert parenthesedInsert = new ParenthesedInsert();
    Insert insert;
}
{
    "("
    insert = Insert()
    ")"
    {
        return parenthesedInsert.withInsert(insert);
    }
}

ParenthesedUpdate ParenthesedUpdate() #ParenthesedUpdate:
{
    ParenthesedUpdate parenthesedUpdate = new ParenthesedUpdate();
    Update update;
}
{
    "("
    update = Update()
    ")"
    {
        return parenthesedUpdate.withUpdate(update);
    }
}

ParenthesedDelete ParenthesedDelete() #ParenthesedDelete:
{
    ParenthesedDelete parenthesedDelete = new ParenthesedDelete();
    Delete delete;
}
{
    "("
    delete = Delete()
    ")"
    {
        return parenthesedDelete.withDelete(delete);
    }
}

LateralView LateralView() #LateralView:
{
    boolean useOuter = false;
    Function generatorFunction = null;
    String tableName = null;
    String columnName = null;
    Alias tableAlias = null;
    Alias columnAlias = null;
}
{
    <K_LATERAL> <K_VIEW> [ <K_OUTER> { useOuter=true; } ]
    generatorFunction = Function()
    [ LOOKAHEAD(2)
        tableName=RelObjectNameWithoutStart()
        {
            tableAlias = new Alias(tableName, false);
        }
    ]
    <K_AS> columnName = RelObjectNameWithoutStart() { columnAlias = new Alias(columnName, true); }

    // Spark SQL supports multiple Alias Columns: https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-lateral-view.html
    // we simulate this by setting the alias name to null and then just adding the columns
    [
        LOOKAHEAD(2) ","  { columnAlias.setName(null);  columnAlias.addAliasColumns( columnName); }
        columnName = RelObjectNameWithoutStart() { columnAlias.addAliasColumns( columnName); }
    ]
    {
        return new LateralView(
            useOuter
            , generatorFunction
            , tableAlias
            , columnAlias
        );
    }
}

ForClause ForClause() #ForClause:
{
    Token token = null;
    ForClause forClause = new ForClause();
}
{
    <K_FOR>
    (
        token = <K_BROWSE>
        |
        token = <K_XML>
        (
            (
                ( <K_RAW> [ LOOKAHEAD(2) "(" <S_CHAR_LITERAL> ")" ] | <K_AUTO> )
                (
                    LOOKAHEAD(2) ","
                    (
                        <K_BINARY> <K_BASE64>
                        | <K_TYPE>
                        | <K_ROOT> [ LOOKAHEAD(2) "(" <S_CHAR_LITERAL> ")" ]
                        | <K_XMLDATA>
                        | <K_XMLSCHEMA> [ LOOKAHEAD(2) "(" <S_CHAR_LITERAL> ")"  ]
                        | <K_ELEMENTS> [ LOOKAHEAD(2) ( <K_XSINIL> | <K_ABSENT> ) ]
                    )
                )*
            )
            |
            (
                <K_EXPLICIT>
                (
                    LOOKAHEAD(2) ","
                    (
                        <K_BINARY> <K_BASE64>
                        | <K_TYPE>
                        | <K_ROOT> [ LOOKAHEAD(2) "(" <S_CHAR_LITERAL> ")" ]
                        | <K_XMLDATA>
                    )
                )*
            )
            |
            (
                <K_PATH> [ LOOKAHEAD(2) "(" <S_CHAR_LITERAL> ")" ]
                (
                    LOOKAHEAD(2) ","
                    (
                        <K_BINARY> <K_BASE64>
                        | <K_TYPE>
                        | <K_ROOT> [ LOOKAHEAD(2) "(" <S_CHAR_LITERAL> ")" ]
                        | <K_ELEMENTS> [ LOOKAHEAD(2) ( <K_XSINIL> | <K_ABSENT> ) ]
                    )
                )*
            )
        )
        |
        (
            token = <K_JSON> ( <K_AUTO> | <K_PATH> )
            (
                LOOKAHEAD(2) ","
                (
                    <K_ROOT> [ LOOKAHEAD(2) "(" <S_CHAR_LITERAL> ")" ]
                    | <K_INCLUDE_NULL_VALUES>
                    | <K_WITHOUT_ARRAY_WRAPPER>
                )
            )*
        )
    )
    {
        forClause.setForOption(token.image);
        linkAST(forClause,jjtThis);
        return forClause;
    }
}


List<LateralView> LateralViews():
{
    ArrayList<LateralView> lateralViews = new ArrayList<LateralView>();
    LateralView lateralView = null;
}
{
    lateralView = LateralView() { lateralViews.add(lateralView); }
    ( LOOKAHEAD(2) lateralView = LateralView() { lateralViews.add(lateralView); } )*

    {
        return lateralViews;
    }
}

LateralSubSelect LateralSubSelect() #LateralSubSelect:
{
    LateralSubSelect lateralSubSelect = new LateralSubSelect();;
    Select select;
}
{
    <K_LATERAL> "(" select = Select()  ")" { lateralSubSelect.withSelect(select).setPrefix("LATERAL"); }
    {
        linkAST(lateralSubSelect,jjtThis);
        return lateralSubSelect;
    }
}

PlainSelect PlainSelect() #PlainSelect:
{
    PlainSelect plainSelect = new PlainSelect();
    List<SelectItem<?>> selectItems = null;
    FromItem fromItem = null;
    List<LateralView> lateralViews = null;
    List<Join> joins = null;
    List<SelectItem<?>> distinctOn = null;
    Expression where = null;
    ForClause forClause = null;
    List<OrderByElement> orderByElements;
    GroupByElement groupBy = null;
    Expression having = null;
    Expression qualify;
    Limit limitBy = null;
    Limit limit = null;
    Offset offset = null;
    Fetch fetch = null;
    WithIsolation withIsolation = null;
    OptimizeFor optimize = null;
    Top top = null;
    Skip skip = null;
    First first = null;
    OracleHierarchicalExpression oracleHierarchicalQueryClause = null;
    PreferringClause preferringClause = null;
    ExpressionList expressionList = null;
    boolean partitionByBrackets = false;
    List<Table> intoTables = null;
    Table updateTable = null;
    Wait wait = null;
    boolean mySqlSqlCalcFoundRows = false;
    Token token;
    KSQLWindow ksqlWindow = null;
    boolean noWait = false;
    String windowName = null;
    WindowDefinition winDef;
    Table intoTempTable = null;
    Distinct distinct;
}
{
    <K_SELECT>

    [ <K_STRAIGHT> { plainSelect.setMySqlHintStraightJoin(true); } ]

    { plainSelect.setOracleHint(getOracleHint()); }

    [ LOOKAHEAD(2) skip = Skip() { plainSelect.setSkip(skip); } ]

    [ LOOKAHEAD(2) first = First() { plainSelect.setFirst(first); } ]

    // Redshift allows TOP before DISTINCT
    // https://docs.aws.amazon.com/redshift/latest/dg/r_SELECT_list.html
    // @Todo: reflect the order when de-parsing
    [ LOOKAHEAD(2) top = Top() { plainSelect.setTop(top);    } ]

    [ LOOKAHEAD(2)
        (
        <K_ALL>
        |
        (
            <K_DISTINCT> { distinct = new Distinct(); plainSelect.setDistinct(distinct); }
            [ LOOKAHEAD(2) "ON" "(" distinctOn=SelectItemsList() { plainSelect.getDistinct().setOnSelectItems(distinctOn); } ")" ]
        )
        |
        <K_DISTINCTROW> { distinct = new Distinct(); distinct.setUseDistinctRow(true); plainSelect.setDistinct(distinct); }
        |
        <K_UNIQUE> { distinct = new Distinct(true); plainSelect.setDistinct(distinct); }
        |
        <K_SQL_CALC_FOUND_ROWS> { plainSelect.setMySqlSqlCalcFoundRows(true); }
        |
        <K_SQL_NO_CACHE> { plainSelect.setMySqlSqlCacheFlag(MySqlSqlCacheFlags.SQL_NO_CACHE); }
        |
        <K_SQL_CACHE> { plainSelect.setMySqlSqlCacheFlag(MySqlSqlCacheFlags.SQL_CACHE); }
        )
    ]

    [
        <K_AS>
        (
            <K_STRUCT> { plainSelect.setBigQuerySelectQualifier( PlainSelect.BigQuerySelectQualifier.AS_STRUCT ); }
            |
            <K_VALUE> { plainSelect.setBigQuerySelectQualifier( PlainSelect.BigQuerySelectQualifier.AS_VALUE ); }
        )
    ]

    [ LOOKAHEAD(2) top = Top() { plainSelect.setTop(top);    } ]

    selectItems=SelectItemsList()

    [ LOOKAHEAD(2) intoTables = IntoClause() { plainSelect.setIntoTables(intoTables); } ]
    [ LOOKAHEAD(2) <K_FROM> fromItem=FromItem()
        [ LOOKAHEAD(2) lateralViews=LateralViews() ]
        [ LOOKAHEAD(2) joins=JoinsList() ]
    ]
    [ LOOKAHEAD(3) <K_FROM> <K_ONLY> { plainSelect.setUsingOnly(true); } fromItem=FromItem()
            [ LOOKAHEAD(2) lateralViews=LateralViews() ]
            [ LOOKAHEAD(2) joins=JoinsList() ]
    ]

    // Clickhouse FINAL as shown at https://clickhouse.com/docs/en/operations/settings/settings#final
    [ LOOKAHEAD(2) <K_FINAL> { plainSelect.setUsingFinal(true); } ]

    [ LOOKAHEAD(2) ksqlWindow=KSQLWindowClause() { plainSelect.setKsqlWindow(ksqlWindow); } ]
    [ LOOKAHEAD(2) where=WhereClause() { plainSelect.setWhere(where); }]
    [ LOOKAHEAD(2) oracleHierarchicalQueryClause=OracleHierarchicalQueryClause() { plainSelect.setOracleHierarchical(oracleHierarchicalQueryClause); } ]
    [ LOOKAHEAD(2) preferringClause=PreferringClause() { plainSelect.setPreferringClause(preferringClause); }
        [LOOKAHEAD(2) <K_PARTITION> <K_BY>
            (
                LOOKAHEAD(2) expressionList=ComplexExpressionList()
                |
                "(" {partitionByBrackets = true;} expressionList=ComplexExpressionList() ")"
            )
            {
                preferringClause.setPartitionExpressionList(expressionList, partitionByBrackets);
            }
        ]
    ]
    // Oracle supports "HAVING" before "GROUP BY", we will simply parse that but won't pay special attention to the order
    [ LOOKAHEAD(2) having=Having() { plainSelect.setHaving(having); }]
    [ LOOKAHEAD(2) groupBy=GroupByColumnReferences() { plainSelect.setGroupByElement(groupBy); }]
    [ LOOKAHEAD(2) having=Having() { plainSelect.setHaving(having); }]
    [ LOOKAHEAD(2) qualify=Qualify() {plainSelect.setQualify(qualify); }]
    [ LOOKAHEAD(2) forClause = ForClause() {plainSelect.setForClause(forClause);} ]
    [ LOOKAHEAD(<K_ORDER> <K_SIBLINGS> <K_BY>) orderByElements = OrderByElements() { plainSelect.setOracleSiblings(true); plainSelect.setOrderByElements(orderByElements);    }   ]
    [ LOOKAHEAD(2) <K_WINDOW>
        windowName = RelObjectName() <K_AS> winDef = windowDefinition() { List<WindowDefinition> winDefs = new ArrayList<WindowDefinition>(); winDefs.add(winDef.withWindowName(windowName)); }
        ( LOOKAHEAD(2) "," windowName = RelObjectName() <K_AS> winDef = windowDefinition() { winDefs.add(winDef.withWindowName(windowName)); } )*
        { plainSelect.setWindowDefinitions(winDefs); }
    ]
    [ LOOKAHEAD(<K_ORDER> <K_BY>) orderByElements = OrderByElements() { plainSelect.setOrderByElements(orderByElements); } ]
    [ LOOKAHEAD(2) <K_EMIT> <K_CHANGES> { plainSelect.setEmitChanges(true); } ]
    [ LOOKAHEAD(7) limit = LimitBy() { plainSelect.setLimitBy(limit);  } ]
    [ LOOKAHEAD(<K_LIMIT>) limit = LimitWithOffset() { plainSelect.setLimit(limit);    } ]
    [ LOOKAHEAD(<K_OFFSET>) offset = Offset() { plainSelect.setOffset(offset);    } ]
	[ LOOKAHEAD(<K_LIMIT>, { limit==null }) limit = LimitWithOffset() { plainSelect.setLimit(limit);    } ]
    [ LOOKAHEAD(<K_FETCH>) fetch = Fetch() { plainSelect.setFetch(fetch);    } ]
    [ LOOKAHEAD(<K_WITH> <K_ISOLATION>) withIsolation = WithIsolation() { plainSelect.setIsolation(withIsolation); } ]
    [ LOOKAHEAD(2)
        <K_FOR>
            (
            <K_UPDATE> { plainSelect.setForMode(ForMode.UPDATE); }
            | <K_SHARE> { plainSelect.setForMode(ForMode.SHARE); }
            | (<K_NO> <K_KEY> <K_UPDATE> { plainSelect.setForMode(ForMode.NO_KEY_UPDATE); })
            | (<K_KEY> <K_SHARE> { plainSelect.setForMode(ForMode.KEY_SHARE); })
            | (<K_READ> <K_ONLY> { plainSelect.setForMode(ForMode.READ_ONLY); })
            | (<K_FETCH> <K_ONLY> { plainSelect.setForMode(ForMode.FETCH_ONLY); })
            )
        [ LOOKAHEAD(2) <K_OF> updateTable = Table() { plainSelect.setForUpdateTable(updateTable); } ]
        [ LOOKAHEAD(<K_WAIT>) wait = Wait() { plainSelect.setWait(wait); } ]
        [ LOOKAHEAD(2) (<K_NOWAIT> { plainSelect.setNoWait(true); }
               | <K_SKIP> <K_LOCKED> { plainSelect.setSkipLocked(true); }) ]
    ]
    [ LOOKAHEAD(<K_OPTIMIZE>) optimize = OptimizeFor() { plainSelect.setOptimizeFor(optimize); } ]
    [ LOOKAHEAD(3) <K_INTO> <K_TEMP> intoTempTable = Table() { plainSelect.setIntoTempTable(intoTempTable);} ]
    [ LOOKAHEAD(3)<K_WITH> <K_NO> <K_LOG> { plainSelect.setUseWithNoLog(true); } ]
    {
        plainSelect.setSelectItems(selectItems);
        plainSelect.setFromItem(fromItem);
        if ( lateralViews!=null && lateralViews.size()>0 ) {
            plainSelect.setLateralViews( lateralViews );
        }
        if ( joins!=null && joins.size()>0 ) {
            plainSelect.setJoins( joins );
        }
        linkAST(plainSelect,jjtThis);
        return plainSelect;
    }
}

Select SetOperationList(Select select) #SetOperationList: {
    SetOperationList list = new SetOperationList();
    List<OrderByElement> orderByElements = null;
    Limit limit = null;
    Offset offset = null;
    Fetch fetch = null;
    WithIsolation withIsolation = null;
    List<Select> selects = new ArrayList<Select>();
    List<SetOperation> operations = new ArrayList<SetOperation>();
    String modifier = null;
}
{

    {
        selects.add(select);
    }

    ( LOOKAHEAD(2) (
            (
                <K_UNION> [ modifier=SetOperationModifier() ] { UnionOp union = new UnionOp(modifier); linkAST(union,jjtThis); operations.add(union); }

            )
            |
            (
                <K_INTERSECT> [ modifier=SetOperationModifier() ] { IntersectOp intersect = new IntersectOp(modifier); linkAST(intersect,jjtThis); operations.add(intersect); }
            )
            |
            ( 
                <K_MINUS> [ modifier=SetOperationModifier() ] { MinusOp minus = new MinusOp(); linkAST(minus,jjtThis); operations.add(minus); }
            )
            |
            (
                <K_EXCEPT> [ modifier=SetOperationModifier() ] { ExceptOp except = new ExceptOp(); linkAST(except,jjtThis); operations.add(except); }
            )
           
        )

        (
            select = PlainSelect()
            |
            select = Values()
            |
            select = ParenthesedSelect()
        )
        {
            selects.add(select);
        }
    )+

    [ LOOKAHEAD(2) orderByElements=OrderByElements() {list.setOrderByElements(orderByElements);} ]
    [ LOOKAHEAD(<K_LIMIT>) limit = LimitWithOffset() { list.setLimit(limit);    } ]
    [ LOOKAHEAD(<K_OFFSET>) offset = Offset() { list.setOffset(offset);    } ]
    [ LOOKAHEAD(<K_LIMIT>, { limit==null }) limit = LimitWithOffset() { list.setLimit(limit);    } ]
    [ LOOKAHEAD(<K_FETCH>) fetch = Fetch() { list.setFetch(fetch);    } ]
    [ LOOKAHEAD(<K_WITH> <K_ISOLATION>) withIsolation = WithIsolation() { list.setIsolation(withIsolation);    } ]

    {
        if ( selects.get(selects.size()-1) instanceof PlainSelect ) {
            PlainSelect ps = (PlainSelect)selects.get(selects.size()-1);
            if (ps.getOrderByElements() != null) {
                list.setOrderByElements(ps.getOrderByElements());
                list.setLimit(ps.getLimit());
                list.setOffset(ps.getOffset());
                ps.setOrderByElements(null);
                ps.setLimit(null);
                ps.setOffset(null);
            }
            if (ps.getFetch() != null) {
                list.setFetch(ps.getFetch());
                ps.setFetch(null);
            }
            if (ps.getIsolation() != null) {
                list.setIsolation(ps.getIsolation());
                ps.setIsolation(null);
            }
        }
        list.setBracketsOpsAndSelects(selects,operations);
        return list;
    }
}

List<WithItem<?>> WithList():
{
    List<WithItem<?>> withItemsList = new ArrayList<WithItem<?>>();
    WithItem with = null;
}
{
    <K_WITH> with=WithItem() { withItemsList.add(with); }
    ( "," with=WithItem() { withItemsList.add(with); } )*

     { return withItemsList; }
}

WithItem<?> WithItem() #WithItem:
{
    boolean recursive = false;
    boolean materialized = false;
    boolean usingNot = false;
    String name = null;
    List<SelectItem<?>> selectItems = null;
    WithFunctionDeclaration withFunctionDeclaration = null;
    ParenthesedStatement statement = null;
    WithItem<?> withItem;
}
{
    (
         LOOKAHEAD(2) <K_FUNCTION>
         withFunctionDeclaration = WithFunctionDeclaration()
         {
             withItem = new WithItem().withWithFunctionDeclaration(withFunctionDeclaration);
         }
         |
         (
             [ LOOKAHEAD(2) <K_RECURSIVE>  { recursive = true; } ]
             name=RelObjectName()
             [ "(" selectItems=SelectItemsList() ")" ]
             <K_AS>
             [ LOOKAHEAD(2) [ <K_NOT> { usingNot = true; } ] <K_MATERIALIZED>  { materialized = true; } ]
             (
                 LOOKAHEAD(2) statement = ParenthesedSelect()
                 |
                 LOOKAHEAD(2) statement = ParenthesedInsert()
                 |
                 LOOKAHEAD(2) statement = ParenthesedUpdate()
                 |
                 LOOKAHEAD(2) statement = ParenthesedDelete()
             )
             {
                withItem = new WithItem(statement, new Alias(name, false))
                    .withRecursive(recursive, usingNot, materialized)
                    .withWithItemList(selectItems);
             }
         )
     )
     {
     return withItem;
     }
}

WithFunctionDeclaration WithFunctionDeclaration() #WithFunctionDeclaration:
{
     String functionName;
     List<WithFunctionParameter> parameters = new ArrayList<WithFunctionParameter>();
     String returnType;
     Expression returnExpression;
     WithFunctionParameter parameter;
}
{
    functionName = RelObjectName()
    "("
        [ parameter=WithFunctionParameter() { parameters.add(parameter); }
          ( "," parameter=WithFunctionParameter() { parameters.add(parameter); } )*
        ]
    ")"
    <K_RETURNS> returnType = RelObjectName()
    <K_RETURN> returnExpression = Expression()
    {
        return new WithFunctionDeclaration(functionName, parameters, returnType, returnExpression);
    }
}

WithFunctionParameter WithFunctionParameter() #WithFunctionParameter:
{
     String name;
     String type = null;
     String arrayType = null;
}
{
    name = RelObjectName()
    (
        LOOKAHEAD(2) <K_ARRAY_LITERAL> "<" arrayType = RelObjectName() ">"
        |
        type = RelObjectName()
    )
    {
        if (arrayType != null) {
            type = "ARRAY<" + arrayType + ">";
        }
        return new WithFunctionParameter(name, type);
    }
}

List<SelectItem<Column>> ColumnSelectItemsList():
{
    List<SelectItem<Column>> selectItemsList = null;
    SelectItem selectItem = null;
}
{
    selectItem=SelectItem() {  selectItemsList = new ArrayList<SelectItem<Column>>(); selectItemsList.add(selectItem); }
    (
        LOOKAHEAD(2) "," selectItem=SelectItem()
        {
            selectItemsList.add(selectItem);
        }
    )*

    { return selectItemsList; }
}

List<SelectItem<?>> SelectItemsList():
{
    List<SelectItem<?>> selectItemsList = null;
    SelectItem selectItem = null;
}
{
    selectItem=SelectItem() {  selectItemsList = new ArrayList<SelectItem<?>>(); selectItemsList.add(selectItem); }
    (
        LOOKAHEAD(2) "," selectItem=SelectItem()
        {
            selectItemsList.add(selectItem);
        }
    )*

    { return selectItemsList; }
}

FunctionAllColumns FunctionAllColumns() #FunctionAllColumns:
{
    Function function;
}
{
    "(" ( "(" )* function=Function() ")" ( ")" )* "." "*"
    {
        return new FunctionAllColumns(function);
    }
}

SelectItem<?> SelectItem() #SelectItem:
{
    Expression expression;
    Alias alias = null;
}
{
    // @fixme: Oracle's SEQUENCE.nextval is parsed as COLUMN with a name part nextval
    // @todo: parse a proper SEQUENCE instead of a COLUMN
    (
        LOOKAHEAD( 3 ) expression = ConnectByPriorOperator()
        |
        LOOKAHEAD( 3 ) expression = XorExpression()
        |
        LOOKAHEAD( 3 ) expression = ConcatExpression()
        |
        expression=Expression()
    )
    [ LOOKAHEAD(2) alias=Alias() ]
    {
        SelectItem<?> selectItem = new SelectItem(expression, alias);
        linkAST(selectItem,jjtThis);
        return selectItem;
    }
}

/**
 * Parses the AllColumns-Pattern '*'.
 *
 * If the allowAdditions is true, it parses additional Keywords.
 */
AllColumns AllColumns(boolean allowAdditions):
{
    ParenthesedExpressionList<Column> exceptColumns = null;
    List<SelectItem<?>> replaceExpressions = null;
    String exceptKeyword=null;
    Token tk;
}
{
    "*"
    // BigData allows EXCEPT, DuckDB allows EXCLUDE
    [ LOOKAHEAD(2, { allowAdditions }) ( tk=<K_EXCEPT> | tk=<K_EXCLUDE> ) exceptColumns = ParenthesedColumnList() { exceptKeyword=tk.image; } ]
    // BigData allows REPLACE
    [ LOOKAHEAD(2, { allowAdditions }) <K_REPLACE> "(" replaceExpressions = SelectItemsList() ")" ]

    {
        return new AllColumns(exceptColumns, replaceExpressions, exceptKeyword);
    }
}

/**
 * Parses the AllTableColumns-Pattern 'table.*'
 *
 * If the allowAdditions is true, it parses additional Keywords.
 */
AllTableColumns AllTableColumns(boolean allowAdditions):
{
    Table table = null;
    AllColumns allColumns;
}
{
     table=Table() "." allColumns=AllColumns(allowAdditions)
    {
        return new AllTableColumns(table, allColumns);
    }

}

Alias Alias():
{ String name = "";
  Token token = null;
  boolean useAs = false;
  Alias alias;
  String colname;
  ColDataType colDataType = null;
}
{
    (
        LOOKAHEAD(3) (
            // Aliases with AS and Columns, but optional identifier:
            //      SELECT fun(x) AS (a,b,c)
            //      SELECT fun(x) AS T(a,b,c)
            <K_AS>
            [ LOOKAHEAD(2) name=RelObjectNameWithoutStart() ]
            { alias = new Alias(name, true ); }

            "(" { List<Alias.AliasColumn> list = new ArrayList<Alias.AliasColumn>(); }
            colname = RelObjectName() [ colDataType = ColDataType() ] { list.add(new Alias.AliasColumn(colname, colDataType)); }
            (
                "," { colDataType=null; } colname = RelObjectName() [ colDataType = ColDataType()] { list.add(new Alias.AliasColumn(colname, colDataType)); }
            )*
            ")" { alias.setAliasColumns(list); }

        )
        |
        (
            // Aliases with identifier but optional AS and Columns:
            //      SELECT fun(x) AS T
            //      SELECT fun(x) T
            //      SELECT fun(x) T(a,b,c)

            [<K_AS> { useAs = true; } ]
            ( name=RelObjectNameWithoutStart() | token=<S_CHAR_LITERAL> { name=token.image; } )
            { alias = new Alias(name,useAs); }

            [ LOOKAHEAD(2) "(" { List<Alias.AliasColumn> list = new ArrayList<Alias.AliasColumn>(); }
                colname = RelObjectName() [ colDataType = ColDataType() ] { list.add(new Alias.AliasColumn(colname, colDataType)); }
                ("," { colDataType=null; } colname = RelObjectName() [ colDataType = ColDataType()] { list.add(new Alias.AliasColumn(colname, colDataType)); } )*
            ")" { alias.setAliasColumns(list); } ]

        )
    )
    { return alias; }
}

void SQLServerHint(SQLServerHints hints) : {
    String str;
}
{
        <K_INDEX> "(" str = RelObjectName() ")" { hints.setIndexName(str); }
        |
        <K_NOLOCK> { hints.withNoLock(); }
}

SQLServerHints SQLServerHints() : {
    SQLServerHints hints = new SQLServerHints();
}
{
    <K_WITH> "("
        SQLServerHint(hints) ("," SQLServerHint(hints) )*
    ")"
    { return hints; }
}

MySQLIndexHint MySQLIndexHint():
{
	Token actionToken = null;
	Token indexToken = null;
	String indexName = null;
	List<String> indexNameList = new ArrayList<String>();
}
{
	(
	actionToken = <K_USE>
	| actionToken = <K_SHOW>
	| actionToken = <K_IGNORE>
	| actionToken = <K_FORCE>
	)

	(
	indexToken = <K_INDEX>
	| indexToken = <K_KEY>
	)

	"("
	indexName = RelObjectNameWithoutValue() { indexNameList.add(indexName); }
	("," indexName= RelObjectNameWithoutValue() { indexNameList.add(indexName); })*
	")"
	{
		return new MySQLIndexHint(actionToken.image, indexToken.image, indexNameList);
	}
}

SelectItem<Function> FunctionItem():
{
    Alias alias = null;
    Function function;
}
{
    function=Function()
    [ alias=Alias() ]
    { return new SelectItem<Function>(function, alias); }
}

ExpressionList<Column> PivotForColumns():
{
    ExpressionList<Column> columns;
    Column column;
}
{
    (
        columns = ParenthesedColumnList()
        |
        column = Column() { columns = new ExpressionList<Column>(column); }
    )
    { return columns; }
}

List<SelectItem<Function>> PivotFunctionItems():
{
    List<SelectItem<Function>> functionItems = new ArrayList<SelectItem<Function>>();
    SelectItem<Function> item;
}
{
    item = FunctionItem() {functionItems.add(item);}
    ( "," item = FunctionItem() {functionItems.add(item);} )*
    { return functionItems; }
}

SelectItem<ExpressionList<?>> ExpressionListItem():
{
    ExpressionList expressionList;
    Alias alias = null;
}
{
    expressionList=ParenthesedExpressionList()
    [ alias=Alias() ]
    { return new SelectItem<ExpressionList<?>>(expressionList, alias); }
}

List<SelectItem<ExpressionList<?>>> PivotMultiInItems():
{
   List<SelectItem<ExpressionList<?>>> retval = new ArrayList<SelectItem<ExpressionList<?>>>();
   SelectItem<ExpressionList<?>> item;
}
{
   item = ExpressionListItem() {retval.add(item);}
   ("," item = ExpressionListItem() {retval.add(item);} )*
   { return retval; }
}

Pivot Pivot():
{
    Pivot retval = new Pivot();
    List<SelectItem<Function>> functionItems;
    ExpressionList<Column> forColumns;
    List<SelectItem<?>> singleInItems = null;
    List<SelectItem<ExpressionList<?>>> multiInItems = null;
    Alias alias = null;
}
{
    <K_PIVOT> "(" functionItems = PivotFunctionItems() <K_FOR>
    forColumns = PivotForColumns()
    <K_IN> "("
    (LOOKAHEAD(3) singleInItems = SelectItemsList()
    | multiInItems = PivotMultiInItems() )
    ")"
    ")"
    [ LOOKAHEAD(2) alias = Alias() ]
    {
        retval.setFunctionItems(functionItems);
        retval.setForColumns(forColumns);
        retval.setSingleInItems(singleInItems);
        retval.setMultiInItems(multiInItems);
        retval.setAlias(alias);
        return retval;
    }
}

PivotXml PivotXml():
{
    PivotXml retval = new PivotXml();
    List<SelectItem<Function>> functionItems;
    ExpressionList<Column> forColumns;
    List<SelectItem<?>> singleInItems = null;
    List<SelectItem<ExpressionList<?>>> multiInItems = null;
    Select inSelect = null;
}
{
    <K_PIVOT> <K_XML> "(" functionItems = PivotFunctionItems() <K_FOR>
    forColumns = PivotForColumns()
    <K_IN> "("
    (
        LOOKAHEAD(2) <K_ANY> { retval.setInAny(true); } |
        LOOKAHEAD(1) inSelect = Select() |
        LOOKAHEAD(2) singleInItems =SelectItemsList() |
        multiInItems = PivotMultiInItems()
    )
    ")"
    ")"
    {
        retval.setFunctionItems(functionItems);
        retval.setForColumns(forColumns);
        retval.setSingleInItems(singleInItems);
        retval.setMultiInItems(multiInItems);
        retval.setInSelect(inSelect);
        return retval;
    }
}

UnPivot UnPivot():
{
    UnPivot retval = new UnPivot();
    ExpressionList<Column> unpivotClause;
    ExpressionList<Column> unpivotForClause;
    List<SelectItem<?>> unpivotInClause;
    Alias alias = null;
}
{
    <K_UNPIVOT>
    [ ( <K_INCLUDE> <K_NULLS> { retval.setIncludeNulls(true); }
    | <K_EXCLUDE> <K_NULLS> { retval.setIncludeNulls(false); } ) ]
    "(" unpivotClause = PivotForColumns() <K_FOR>
    unpivotForClause = PivotForColumns()
    <K_IN> "("
    unpivotInClause = SelectItemsList()
    ")"
    ")"
    [ LOOKAHEAD(2) alias = Alias() ]
    {
        retval.setUnPivotClause(unpivotClause);
        retval.setUnPivotForClause(unpivotForClause);
        retval.setUnPivotInClause(unpivotInClause);
        retval.setAlias(alias);
        return retval;
    }
}

List<Table> IntoClause():
{
    List<Table> tables = new ArrayList<Table>();
    Table table;
}
{
    <K_INTO> table=Table() { tables.add(table); } ( LOOKAHEAD(2) "," table=Table() { tables.add(table); } )*
    {
        return tables;
    }
}

FromItem ParenthesedFromItem():
{
    ParenthesedFromItem ParenthesedFromItem = new ParenthesedFromItem();
    FromItem fromItem;
    List<Join> joins = null;
}
{
    "("
        fromItem = FromItem()
        [ joins=JoinsList() ]
    ")"

    {
        return ParenthesedFromItem.withFromItem(fromItem).withJoins(joins);
    }
}

FromItem FromItem() #FromItem:
{
    FromItem fromItem = null;
    FromItem fromItem2 = null;
    SampleClause sampleClause;
    Pivot pivot = null;
    UnPivot unpivot = null;
    Alias alias = null;
    MySQLIndexHint indexHint = null;
    SQLServerHints sqlServerHints = null;
    Select select;

    String timeTravelStr = null;
}
{
    (
        LOOKAHEAD(3, { !getAsBoolean(Feature.allowUnparenthesizedSubSelects) }) fromItem = Values()
        |
        LOOKAHEAD(16) fromItem=TableFunction()
        |
        LOOKAHEAD(3) fromItem=Table()
        |
        LOOKAHEAD(ParenthesedFromItem()) fromItem = ParenthesedFromItem()
        |
        LOOKAHEAD(3, { !getAsBoolean(Feature.allowUnparenthesizedSubSelects) }) (
            fromItem=ParenthesedSelect()
            [ LOOKAHEAD(2) pivot=Pivot() { fromItem.setPivot(pivot); } ]
            [ LOOKAHEAD(2) unpivot=UnPivot() { fromItem.setUnPivot(unpivot); } ]
        )
        |
        fromItem=LateralSubSelect()
        |
        LOOKAHEAD(2, { Dialect.EXASOL.name().equals(getAsString(Feature.dialect)) }) fromItem=SubImport() { fromItem = new ParenthesedFromItem(fromItem); }
        |
        LOOKAHEAD({ getAsBoolean(Feature.allowUnparenthesizedSubSelects) }) fromItem=Select()
    )

    [ LOOKAHEAD(2) alias=Alias() { fromItem.setAlias(alias); } ]
    [
        LOOKAHEAD(2, {fromItem instanceof Table }) timeTravelStr = TimeTravelAfterAlias()
        { ((Table) fromItem).setTimeTravelStrAfterAlias(timeTravelStr); }
    ]
    [ LOOKAHEAD(2) sampleClause = SampleClause() { fromItem.setSampleClause(sampleClause); } ]
    [ LOOKAHEAD(2) unpivot=UnPivot() { fromItem.setUnPivot(unpivot); } ]
    [ LOOKAHEAD(2) ( LOOKAHEAD(2) pivot=PivotXml() | pivot=Pivot() ) { fromItem.setPivot(pivot); } ]
    [
        LOOKAHEAD(2)
        (
            indexHint = MySQLIndexHint() {
                if (fromItem instanceof Table)
                    ((Table) fromItem).setHint(indexHint);
            }
            |
            sqlServerHints = SQLServerHints() {
                if (fromItem instanceof Table)
                    ((Table) fromItem).setSqlServerHints(sqlServerHints);
            }
        )
    ]
    {
        linkAST(fromItem,jjtThis);
        return fromItem;
    }
}

List<Join> JoinsList():
{
    List<Join> joinsList = new ArrayList<Join>();
    Join join = null;
}
{
    ( LOOKAHEAD(2) join=JoinerExpression() { joinsList.add(join); } )+
    {
        return joinsList;
    }
}

JoinHint JoinHint():
{
    Token token;
}
{
    (
        token = <K_LOOP>
        |
        token = <K_HASH>
        |
        token = <K_MERGE>
        |
        token = <K_REMOTE>
    )
    {
        return new JoinHint(token.image);
    }
}

Join JoinerExpression() #JoinerExpression:
{
    Join join = new Join();
    FromItem right = null;
    Expression onExpression = null;
    Column tableColumn;
    List<Column> columns = null;
    KSQLJoinWindow joinWindow = null;
    JoinHint joinHint = null;
}
{
    [ <K_GLOBAL> { join.setGlobal(true); } ]
    [ <K_NATURAL> { join.setNatural(true); } ]

    [
        (
            <K_LEFT> { join.setLeft(true); } [ <K_SEMI> { join.setSemi(true); } | <K_OUTER> { join.setOuter(true); } ]
            |
            (
                <K_RIGHT> { join.setRight(true); }
                |
                <K_FULL> { join.setFull(true); }
            ) [ <K_OUTER> { join.setOuter(true); } ]
            |
            <K_INNER> { join.setInner(true); }
        )
        |
        <K_CROSS> { join.setCross(true); }
        |
        <K_OUTER> { join.setOuter(true); }
    ]

    (
        (
            [ joinHint=JoinHint() {join.setJoinHint(joinHint); } ]
            <K_JOIN>
            [ <K_FETCH> { join.setFetch(true); } ]
        )
        |
        "," { join.setSimple(true); } (<K_OUTER> { join.setOuter(true); } )?
        |
        <K_STRAIGHT> { join.setStraight(true); }
        |
        <K_APPLY> {join.setApply(true); }
    )

    right=FromItem()

    [
        LOOKAHEAD(2) (
                        [ <K_WITHIN> "(" joinWindow = JoinWindow() ")" {join.setJoinWindow(joinWindow);} ]
                        ( <K_ON> onExpression=Expression()  { join.addOnExpression(onExpression); }
                          ( LOOKAHEAD(2)  <K_ON> onExpression=Expression()  { join.addOnExpression(onExpression); } )*
                        )
                        |
                        (
                            <K_USING> "(" tableColumn=Column() { columns = new ArrayList<Column>(); columns.add(tableColumn); }
                            ( "," tableColumn=Column() { columns.add(tableColumn); } ) *
                            ")" { join.setUsingColumns(columns); }
                        )
                    )
    ]
    {
        linkAST(join,jjtThis);
        join.setFromItem(right);
        return join;
    }

}

KSQLJoinWindow JoinWindow():
{
    KSQLJoinWindow retval = new KSQLJoinWindow();
    boolean beforeAfter;
    Token beforeDurationToken = null;
    Token beforeTimeUnitToken = null;
    Token afterDurationToken = null;
    Token afterTimeUnitToken = null;
}
{
    beforeDurationToken=<S_LONG> (beforeTimeUnitToken=<S_IDENTIFIER> | beforeTimeUnitToken=<K_DATE_LITERAL>)
    [ "," afterDurationToken=<S_LONG> (afterTimeUnitToken=<S_IDENTIFIER> | afterTimeUnitToken=<K_DATE_LITERAL>) ]
    {
        if (afterDurationToken == null) {
            retval.setDuration(Long.parseLong(beforeDurationToken.image));
            retval.setTimeUnit(KSQLWindow.TimeUnit.from(beforeTimeUnitToken.image));
            retval.setBeforeAfterWindow(false);
            return retval;
        }
        retval.setBeforeDuration(Long.parseLong(beforeDurationToken.image));
        retval.setBeforeTimeUnit(KSQLWindow.TimeUnit.from(beforeTimeUnitToken.image));
        retval.setAfterDuration(Long.parseLong(afterDurationToken.image));
        retval.setAfterTimeUnit(KSQLWindow.TimeUnit.from(afterTimeUnitToken.image));
        retval.setBeforeAfterWindow(true);
        return retval;
    }
}

KSQLWindow KSQLWindowClause():
{
    KSQLWindow retval = null;
    Token sizeDurationToken = null;
    Token sizeTimeUnitToken = null;
    Token advanceDurationToken = null;
    Token advanceTimeUnitToken = null;
}
{
    <K_WINDOW>
    {
        retval=new KSQLWindow();
        retval.setHoppingWindow(false);
        retval.setSessionWindow(false);
        retval.setTumblingWindow(false);
    }
    (
        <K_HOPPING> "("
            <K_SIZE> sizeDurationToken=<S_LONG> sizeTimeUnitToken=<S_IDENTIFIER> ","
            <K_ADVANCE> <K_BY> advanceDurationToken=<S_LONG> advanceTimeUnitToken=<S_IDENTIFIER> ")"
        {
            retval.setHoppingWindow(true);
        } |
        <K_SESSION> "(" sizeDurationToken=<S_LONG> sizeTimeUnitToken=<S_IDENTIFIER> ")"
        {
            retval.setSessionWindow(true);
        } |
        <K_TUMBLING> "(" <K_SIZE> sizeDurationToken=<S_LONG> sizeTimeUnitToken=<S_IDENTIFIER> ")"
        {
            retval.setTumblingWindow(true);
        }
    )
    {
            retval.setSizeDuration(Long.parseLong(sizeDurationToken.image));
            retval.setSizeTimeUnit(KSQLWindow.TimeUnit.from(sizeTimeUnitToken.image));
            if (advanceDurationToken != null) {
                retval.setAdvanceDuration(Long.parseLong(advanceDurationToken.image));
                retval.setAdvanceTimeUnit(KSQLWindow.TimeUnit.from(advanceTimeUnitToken.image));
            }
            return retval;
    }
}

Expression WhereClause():
{
    Expression retval = null;
}
{
    <K_WHERE> retval=Expression()
    { return retval; }
}

OracleHierarchicalExpression OracleHierarchicalQueryClause():
{
    OracleHierarchicalExpression result = new OracleHierarchicalExpression();
    Expression expr;
}
{
    (
        (
            <K_START> <K_WITH>  expr=XorExpression() {result.setStartExpression(expr);}
            <K_CONNECT> <K_BY> [ <K_NOCYCLE> { result.setNoCycle(true); } ] expr=XorExpression()
            {
                result.setConnectExpression(expr);
            }
        )
        |
        (
            <K_CONNECT> <K_BY> [ <K_NOCYCLE> { result.setNoCycle(true); } ] expr=XorExpression()
            {
                result.setConnectExpression(expr);
                result.setConnectFirst(true);
            }
            [ LOOKAHEAD(2) <K_START> <K_WITH>  expr=XorExpression() {result.setStartExpression(expr);} ]
        )
    )
    {
        return result;
    }
}

PreferringClause PreferringClause():
{
    Expression result = null;
}
{
    <K_PREFERRING>
    result=PreferenceTerm()

    {
        PreferringClause preferring = new PreferringClause(result);
        return preferring;
    }
}

Expression PreferenceTerm():
{
    Expression retval = null;
}
{
    // recursively build preferenceterm inside Plus
    // like Expression -> XorExpression -> OrExpression -> ...

    retval=Plus()

    {
        return retval;
    }
}

Expression Plus():
{
    Expression left, right, result;
}
{
    left=PriorTo() { result = left; }
    (
        LOOKAHEAD(2)
        <K_PLUS>
        right=PriorTo()
        {
          result = new Plus(left, right);
          left = result;
        }
    )*
    {
        return result;
    }
}

Expression PriorTo():
{
    Expression left, right, result;
}
{
    (
        LOOKAHEAD(3) left=PreferenceTermTerminal()
        |
        "(" left=PreferenceTerm() ")" { left = new ParenthesedExpressionList(left); }
    )
    { result = left; }

    (
        LOOKAHEAD(2) <K_PRIOR> <K_TO>
        (
            LOOKAHEAD(3) right=PreferenceTermTerminal()
            |
            "(" right=PreferenceTerm() ")" { left = new ParenthesedExpressionList(right); }
        )
        {
            result = new PriorTo(left, right);
            left = result;
        }
    )*
    {
        return result;
    }
}

Expression PreferenceTermTerminal():
{
    Expression retval;
}
{
    (
        LOOKAHEAD(2) retval=HighExpression()
        |
        LOOKAHEAD(2) retval=LowExpression()
        |
        LOOKAHEAD(2) retval=Inverse()
        |
        retval=Condition()
    )

    {
        return retval;
    }
}

Expression HighExpression() #HighExpression:
{
    Expression result;
}
{
    <K_HIGH>
    result=Expression()

    {
        HighExpression high = new HighExpression(result);
        linkAST(high,jjtThis);
        return high;
    }
}

Expression LowExpression() #LowExpression:
{
    Expression result;
}
{
    <K_LOW>
    result=Expression()

    {
        LowExpression low = new LowExpression(result);
        linkAST(low,jjtThis);
        return low;
    }
}

Expression Inverse() #Inverse:
{
    Expression result;
}
{
    <K_INVERSE>
    "(" result=PreferenceTerm() ")"

    {
        Inverse inverse = new Inverse(result);
        linkAST(inverse,jjtThis);
        return inverse;
    }
}

GroupByElement GroupByColumnReferences():
{
    Expression columnReference;
    GroupByElement groupBy = new GroupByElement();
    Expression expr;
    ExpressionList<Expression> list;
    Token token;
}
{
    <K_GROUP> <K_BY>
    (
        LOOKAHEAD(2) (
            <K_GROUPING> <K_SETS>
            "("
                list = GroupingSet() { groupBy.addGroupingSet(list); }
                ( LOOKAHEAD(2) "," list = GroupingSet() { groupBy.addGroupingSet(list); })*
            ")"
        )
        |
        (
            list = ExpressionList() { groupBy.setGroupByExpressions(list); }
            (
                LOOKAHEAD(2) <K_GROUPING> <K_SETS>
                "("
                    list = GroupingSet() { groupBy.addGroupingSet(list); }
                    ( LOOKAHEAD(2) "," list = GroupingSet() { groupBy.addGroupingSet(list); })*
                ")"
            )?
            [ LOOKAHEAD(2) <K_WITH> <K_ROLLUP> { groupBy.setMysqlWithRollup(true); }  ]
        )
    )
    {
        return groupBy;
    }
}

ExpressionList<Expression> GroupingSet():
{
    ExpressionList<Expression> list;
    Expression expression;
}
{
    (
        LOOKAHEAD(2) list = ParenthesedExpressionList()
        |
        expression = SimpleExpression() { list = new ExpressionList<Expression>(expression); }
    )
    {
        return list;
    }
}

Expression Having():
{
    Expression having = null;
}
{
    <K_HAVING> having=Expression()
    {
        return having;
    }
}

Expression Qualify():
{
    Expression qualify = null;
}
{
    <K_QUALIFY> qualify=Expression()
    {
        return qualify;
    }
}

List<OrderByElement> OrderByElements():
{
    List<OrderByElement> orderByList = new ArrayList<OrderByElement>();
    OrderByElement orderByElement = null;
}
{
    <K_ORDER> [ <K_SIBLINGS> ] <K_BY> orderByElement=OrderByElement() { orderByList.add(orderByElement); }
        ( LOOKAHEAD(2) "," orderByElement=OrderByElement() { orderByList.add(orderByElement); } )*
    {
        return orderByList;
    }
}

OrderByElement OrderByElement():
{
    OrderByElement orderByElement = new OrderByElement();
    Expression columnReference = null;
    Token collateToken = null;
}
{
    columnReference = Expression()
    [ LOOKAHEAD(<K_COLLATE>) <K_COLLATE> (collateToken=<S_CHAR_LITERAL> | collateToken=<S_QUOTED_IDENTIFIER>) { columnReference = new CollateExpression(columnReference, collateToken.image); } ]
    [ LOOKAHEAD(2) ( <K_ASC> | (<K_DESC> { orderByElement.setAsc(false); } )) { orderByElement.setAscDescPresent(true); }  ]
    [ LOOKAHEAD(2) <K_NULLS>
        [ LOOKAHEAD(2) (
            <K_FIRST> { orderByElement.setNullOrdering(OrderByElement.NullOrdering.NULLS_FIRST);  }
            |
            <K_LAST> { orderByElement.setNullOrdering(OrderByElement.NullOrdering.NULLS_LAST);  }
            )
        ]
    ]
    [ LOOKAHEAD(2) <K_WITH> <K_ROLLUP> { orderByElement.setMysqlWithRollup(true); } ]
    {
        orderByElement.setExpression(columnReference);
        return orderByElement;
    }
}

JdbcParameter JdbcParameter() : {
    Token tk;
    JdbcParameter retval;
}
{
    ( tk="?" | tk=<S_PARAMETER> )
    { retval = new JdbcParameter(++jdbcParameterIndex, false, tk.image); }

    [ LOOKAHEAD(2) token = <S_LONG> { retval.setUseFixedIndex(true); retval.setIndex(Integer.valueOf(token.image)); } ]

    { return retval; }
}


Limit LimitWithOffset() #LimitWithOffset:
{
    Limit limit = new Limit();
    Expression rowCountExpression;
    Expression offsetExpression;
}
{
    (
        LOOKAHEAD(<K_LIMIT> Expression() "," Expression()) (
            // mysql-> LIMIT offset,row_count
            <K_LIMIT>
            offsetExpression=Expression() { limit.setOffset( offsetExpression ); }
            ","
            rowCountExpression=Expression() { limit.setRowCount( rowCountExpression ); }
        )
        |
        limit = PlainLimit()
    )
    {
        linkAST(limit,jjtThis);
        return limit;
    }
}

Limit PlainLimit() #PlainLimit:
{
    Limit limit = new Limit();
    Expression rowCountExpression;
}
{
    // mysql-postgresql-> LIMIT (row_count | ALL | NULL)
    <K_LIMIT>
    (
            LOOKAHEAD(3) rowCountExpression = ParenthesedSelect()
            |
            rowCountExpression = Expression()
    )
    {
        limit.setRowCount(rowCountExpression);
        linkAST(limit,jjtThis);
        return limit;
    }
}

/**
 * Clickhouse LIMIT BY
 * @see <a href='https://clickhouse.com/docs/en/sql-reference/statements/select'>SELECT Query</a>
 */
Limit LimitBy():
{
    Limit limit;
    ExpressionList byExpressions;
}
{
    limit = LimitWithOffset()
    <K_BY> byExpressions = ExpressionList()
    {
        limit.setByExpressions(byExpressions);
        return limit;
    }
}

Offset Offset():
{
    Offset offset = new Offset();
    Expression offsetExpression;
}
{
    (
            // postgresql-> OFFSET offset
            // sqlserver-oracle-> OFFSET offset (ROW | ROWS)
             <K_OFFSET>
             offsetExpression=Expression() { offset.setOffset( offsetExpression ); }

             [ LOOKAHEAD(2) (<K_ROWS> { offset.setOffsetParam("ROWS"); } | <K_ROW> { offset.setOffsetParam("ROW"); })]

        )
    {
        return offset;
    }
}

Fetch Fetch():
{
    Fetch fetch = new Fetch();
    Token token = null;
    Expression expression;
    List<String> fetchParameters = new ArrayList<String>();
}
{
    (
        LOOKAHEAD(3) (
            <K_FETCH> (<K_FIRST> { fetch.setFetchParamFirst(true); } | <K_NEXT>)
            (
                <K_ROWS> { fetch.addFetchParameter("ROWS"); }
                |
                <K_ROW> { fetch.addFetchParameter("ROW"); }
            )
            (
                <K_ONLY> { fetch.addFetchParameter("ONLY"); }
                |
                <K_WITH_TIES> { fetch.addFetchParameter("WITH TIES"); }
            )
        )
        |
        (
            <K_FETCH> (<K_FIRST> { fetch.setFetchParamFirst(true); } | <K_NEXT>)

            // Expression is optional according to https://www.h2database.com/html/commands.html#select
            expression = Expression() { fetch.setExpression(expression); }
            [ <K_PERCENT> { fetch.addFetchParameter("PERCENT"); } ]
            (
                (
                    <K_ROWS> { fetch.addFetchParameter("ROWS"); }
                    |
                    <K_ROW> { fetch.addFetchParameter("ROW"); }
                )

                (
                    <K_ONLY> { fetch.addFetchParameter("ONLY"); }
                    |
                    <K_WITH_TIES> { fetch.addFetchParameter("WITH TIES"); }
                )
            )
        )
    )
    {
        return fetch;
    }
}

WithIsolation WithIsolation():
{
    WithIsolation withIsolation = new WithIsolation();
    Token token = null;
    JdbcParameter jdbc;
}
{
    <K_WITH>
    token=<K_ISOLATION>
    { withIsolation.setIsolation(token.image);
        return withIsolation;
    }
}

OptimizeFor OptimizeFor():
{
    Token token;
    LongValue value;
}
{
    <K_OPTIMIZE> <K_FOR> token=<S_LONG> <K_ROWS>
    {
        value = new LongValue(token.image);
        return new OptimizeFor(value.getValue());
    }
}

// according to http://technet.microsoft.com/en-us/library/ms189463.aspx
Top Top() #Top:
{
    Top top = new Top();
    Token token = null;
    Expression expr = null;
    JdbcParameter jdbc = null;
}
{
    <K_TOP>
    (
        token=<S_LONG> { top.setExpression(new LongValue(token.image)); }
        |
        jdbc = JdbcParameter() { top.setExpression(jdbc); }
        |
        ":" { top.setExpression(new JdbcNamedParameter()); }
        [ LOOKAHEAD(2) token = <S_IDENTIFIER> { ((JdbcNamedParameter)top.getExpression()).setName(token.image); } ]
        |
        "("
        expr=AdditiveExpression()
        {
            top.setExpression(expr);
            top.setParenthesis(true);
        }
        ")"
    )
    [ LOOKAHEAD(2) <K_PERCENT> { top.setPercentage(true); } ]
    [ LOOKAHEAD(2) <K_WITH_TIES> { top.setWithTies(true); } ]
    {
        linkAST(top,jjtThis);
        return top;
    }
}

// according to http://www-01.ibm.com/support/knowledgecenter/SSGU8G_12.1.0/com.ibm.sqls.doc/ids_sqs_0156.htm
Skip Skip():
{
    Skip skip = new Skip();
    Token token = null;
    JdbcParameter jdbc;
}
{
    <K_SKIP>
    (
        token=<S_LONG> { skip.setRowCount(Long.parseLong(token.image)); }
        |
        token=<S_IDENTIFIER> { skip.setVariable(token.image); }
        |
        jdbc = JdbcParameter() { skip.setJdbcParameter(jdbc); }
    )
    {
        return skip;
    }
}

JAVACODE
OracleHint getOracleHint() {
  OracleHint hint = null;
  Token tok = getToken(1);
  // Retrieve first comment (if any) prior next token
  if (tok.specialToken != null) {
    tok = tok.specialToken;
    while (tok.specialToken != null) tok = tok.specialToken;
    // Check if it matches Hint pattern?
    if (OracleHint.isHintMatch(tok.image)) {
      hint = new OracleHint();
      hint.setComment(tok.image);
    }
  }
  return hint;
}

First First():
{
    First first = new First();
    Token token = null;
    JdbcParameter jdbc;
}
{
    (
        <K_FIRST> { first.setKeyword(First.Keyword.FIRST); }
        |
        <K_LIMIT> { first.setKeyword(First.Keyword.LIMIT); }
    )
    (
        token=<S_LONG> { first.setRowCount(Long.parseLong(token.image)); }
        |
        token=<S_IDENTIFIER> { first.setVariable(token.image); }
        |
        jdbc = JdbcParameter() { first.setJdbcParameter(jdbc); }
    )
    {
        return first;
    }
}


Expression Expression() #Expression :
{
    Expression expression = null;
}
{
    expression=XorExpression()
    {
        linkAST(expression,jjtThis);
        return expression;
    }
}

Expression XorExpression():
{
    Expression left, right, result;
}
{
    left=OrExpression() { result = left; }
    ( LOOKAHEAD(2)
        <K_XOR>
        right=OrExpression()
        {
            result = new XorExpression(left, right);
            left = result;
        }
     )*
     {
         return result;
     }
}

Expression OrExpression():
{
    Expression left, right, result;
}
{
    left=AndExpression() { result = left; }
    ( LOOKAHEAD(2)
        <K_OR>
        right=AndExpression()
        {
            result = new OrExpression(left, right);
            left = result;
        }
     )*
     {
         return result;
     }

}

Expression AndExpression() :
{
    Expression left, right, result;
    boolean not = false;
	boolean exclamationMarkNot=false;
}
{
    (
        LOOKAHEAD(Condition(), {!interrupted}) left=Condition()
        |
        [ <K_NOT> { not=true; } | "!" { not=true; exclamationMarkNot=true; } ]
        "(" left=XorExpression() ")" {left = new ParenthesedExpressionList(left); if (not) { left = new NotExpression(left, exclamationMarkNot); not = false; } }
    )
    { result = left; }

    ( LOOKAHEAD(2)
        { boolean useOperator = false; }
         (<K_AND> | <OP_DOUBLEAND> {useOperator=true;} )
        (
            LOOKAHEAD(Condition(), {!interrupted}) right=Condition()
            |
            [ <K_NOT> { not=true; } | "!" { not=true; exclamationMarkNot=true; } ]
            "(" right=XorExpression() ")" {right = new ParenthesedExpressionList(right); if (not) { right = new NotExpression(right, exclamationMarkNot); not = false; } }
        )
        {
            result = new AndExpression(left, right);
            ((AndExpression)result).setUseOperator(useOperator);
            left = result;
        }
    )*
    {
        return result;
    }
}

Expression Condition():
{
    Expression result;
    Token token;
    boolean not = false;
	boolean exclamationMarkNot = false;
}
{
    [ LOOKAHEAD(2) (<K_NOT> { not=true; } | "!" { not=true; exclamationMarkNot=true; })]
    (
        LOOKAHEAD(RegularCondition(), {!interrupted}) result=RegularCondition()
        |
        result=SQLCondition()
    )

    { return not?new NotExpression(result, exclamationMarkNot):result; }
}

Expression OverlapsCondition():{
    ExpressionList left = new ExpressionList();
    ExpressionList right = new ExpressionList();
}
{
    //As per the sql2003 standard, we need at least two items in the list if there is not explicit ROW prefix
    //More than two expression are allowed per the sql2003 grammar.
    left = ParenthesedExpressionList()
    <K_OVERLAPS>
    right = ParenthesedExpressionList()

    {return new OverlapsCondition(left, right);}
}

Expression RegularCondition() #RegularCondition:
{
    Expression result = null;
    Expression leftExpression;
    Expression rightExpression;
    int oracleJoin=EqualsTo.NO_ORACLE_JOIN;
    int oraclePrior=EqualsTo.NO_ORACLE_PRIOR;
    boolean binary = false;
    boolean not = false;
}
{
    [ LOOKAHEAD(2) <K_PRIOR> { oraclePrior = EqualsTo.ORACLE_PRIOR_START; }]
    leftExpression=ComparisonItem() { result = leftExpression; }

    [ "(" "+" ")" { oracleJoin=EqualsTo.ORACLE_JOIN_RIGHT; } ]

	(
        LOOKAHEAD(2)
        ">" { result = new GreaterThan(); }
        | "<" { result = new MinorThan(); }
        | "=" { result = new EqualsTo(); }
        | token=<OP_GREATERTHANEQUALS> { result = new GreaterThanEquals(token.image); }
        | token=<OP_MINORTHANEQUALS> { result = new MinorThanEquals(token.image); }
        | token=<OP_NOTEQUALSSTANDARD> { result = new NotEqualsTo(token.image); }
        | token=<OP_NOTEQUALSBANG> { result = new NotEqualsTo(token.image); }
        | token=<OP_NOTEQUALSHAT> { result = new NotEqualsTo(token.image); }
        | "*=" { result = new TSQLLeftJoin(); }
        | "=*" { result = new TSQLRightJoin(); }
        | token=<OP_DOUBLEAND> { result = new DoubleAnd(); }
        | token=<OP_CONTAINS> { result = new Contains(); }
        | token=<OP_CONTAINEDBY> { result = new ContainedBy(); }
        | "@@" { result = new Matches(); }
        | "~" { result = new RegExpMatchOperator(RegExpMatchOperatorType.MATCH_CASESENSITIVE); }
        | "~*" { result = new RegExpMatchOperator(RegExpMatchOperatorType.MATCH_CASEINSENSITIVE); }
        | "!~" { result = new RegExpMatchOperator(RegExpMatchOperatorType.NOT_MATCH_CASESENSITIVE); }
        | "!~*" { result = new RegExpMatchOperator(RegExpMatchOperatorType.NOT_MATCH_CASEINSENSITIVE); }

        | "@>" { result = new JsonOperator("@>"); }
        | "<@" { result = new JsonOperator("<@"); }
        | "?" { result = new JsonOperator("?"); }
        | "?|" { result = new JsonOperator("?|"); }
        | "?&" { result = new JsonOperator("?&"); }
        | <OP_CONCAT> { result = new JsonOperator("||"); }
        | "-" { result = new JsonOperator("-"); }
        | "-#" { result = new JsonOperator("-#"); }
        | "<->" { result = new GeometryDistance("<->"); }
        | "<#>" { result = new GeometryDistance("<#>"); }
        | <OP_COSINESIMILARITY> { result = new CosineSimilarity(); }
    )

    ( LOOKAHEAD(2) <K_PRIOR> rightExpression=ComparisonItem() { oraclePrior = EqualsTo.ORACLE_PRIOR_END; }
    | rightExpression=ComparisonItem() )

    [ LOOKAHEAD(2) "(" "+" ")" { oracleJoin=EqualsTo.ORACLE_JOIN_LEFT; } ]

    {
        BinaryExpression regCond = (BinaryExpression) result;
        regCond.setLeftExpression(leftExpression);
        regCond.setRightExpression(rightExpression);

        if (oracleJoin>0)
            ((SupportsOldOracleJoinSyntax)result).setOldOracleJoinSyntax(oracleJoin);

        if (oraclePrior!=EqualsTo.NO_ORACLE_PRIOR)
            ((SupportsOldOracleJoinSyntax)result).setOraclePriorPosition(oraclePrior);
    }

    {
        linkAST(result,jjtThis);
        return result;
    }
}

Expression SQLCondition():
{
    Expression result;
    Expression left;
}
{
    (
    result=ExistsExpression()
    | LOOKAHEAD( OverlapsCondition(), {!interrupted}) result=OverlapsCondition()
    | left = SimpleExpression() { result = left; }
        [
            LOOKAHEAD(2) (
                LOOKAHEAD(3, {!interrupted}) result=InExpression(left)
                |
                LOOKAHEAD(3) result=ExcludesExpression(left)
                |
                LOOKAHEAD(3) result=IncludesExpression(left)
                |
                LOOKAHEAD(2) result=Between(left)
                |
                result = MemberOfExpression(left)
                |
                LOOKAHEAD(3) result=IsNullExpression(left)
                |
                LOOKAHEAD(3) result=IsBooleanExpression(left)
                |
                LOOKAHEAD(3) result=IsUnknownExpression(left)
                |
                LOOKAHEAD(2) result=LikeExpression(left)
                |
                LOOKAHEAD(3) result=IsDistinctExpression(left)
                |
                result=SimilarToExpression(left)
            )
        ]
    )
    { return result; }
}

Expression InExpression(Expression leftExpression) #InExpression :
{
    Token token;
    int oldOracleJoin = 0;
    boolean usingNot = false;
    boolean usingGlobal = false;
    Expression rightExpression;
}
{
    [ "(" "+" ")" { oldOracleJoin=EqualsTo.ORACLE_JOIN_RIGHT; } ]

    [<K_GLOBAL> { usingGlobal=true; } ]
    [<K_NOT> { usingNot=true; } ]
    <K_IN>
    (
        LOOKAHEAD(2) token=<S_CHAR_LITERAL> {  rightExpression = new StringValue(token.image); }
        |
        rightExpression = PrimaryExpression()
    )
    {
        InExpression inExpression =  new InExpression(leftExpression, rightExpression)
                                                .withOldOracleJoinSyntax(oldOracleJoin)
                                                .withNot(usingNot)
                                                .setGlobal(usingGlobal);
        linkAST(inExpression,jjtThis);
        return inExpression;
    }
}

Expression IncludesExpression(Expression leftExpression) #IncludesExpression :
{
    Token token;
    Expression rightExpression;
}
{
    <K_INCLUDES> (rightExpression = ParenthesedExpressionList())
    {
        IncludesExpression includesExpression =  new IncludesExpression(leftExpression, rightExpression);

        linkAST(includesExpression,jjtThis);
        return includesExpression;
    }
}

Expression ExcludesExpression(Expression leftExpression) #ExcludesExpression :
{
    Token token;
    Expression rightExpression;
}
{
    <K_EXCLUDES> (rightExpression = ParenthesedExpressionList())
    {
        ExcludesExpression excludesExpression =  new ExcludesExpression(leftExpression, rightExpression);

        linkAST(excludesExpression,jjtThis);
        return excludesExpression;
    }
}

Expression Between(Expression leftExpression) :
{
    Between result = new Between();
    Expression betweenExpressionStart = null;
    Expression betweenExpressionEnd = null;
}
{
        [<K_NOT> { result.setNot(true); }]
        <K_BETWEEN>
        [
            LOOKAHEAD(2) (
                <K_SYMMETRIC> { result.setUsingSymmetric(true); }
                |
                <K_ASYMMETRIC> { result.setUsingAsymmetric(true); }
            )
        ]
        (
            LOOKAHEAD( ParenthesedSelect() ) betweenExpressionStart = ParenthesedSelect()
            |
            LOOKAHEAD( RegularCondition() ) betweenExpressionStart = RegularCondition()
            |
            betweenExpressionStart  = SimpleExpression()
        )

        <K_AND>
        (
            LOOKAHEAD( ParenthesedSelect() ) betweenExpressionEnd = ParenthesedSelect()
            |
            LOOKAHEAD( RegularCondition() ) betweenExpressionEnd = RegularCondition()
            |
            betweenExpressionEnd = SimpleExpression()
        )

    {
        result.setLeftExpression(leftExpression);
        result.setBetweenExpressionStart(betweenExpressionStart);
        result.setBetweenExpressionEnd(betweenExpressionEnd);
        return result;
    }
}

Expression LikeExpression(Expression leftExpression) #LikeExpression:
{
    LikeExpression result = new LikeExpression();
    Expression rightExpression = null;
    Expression escape;
    Token token;
}
{
    [<K_NOT> { result.setNot(true); } ]
    (
        token = <K_LIKE>
        | token = <K_ILIKE>
        | token = <K_RLIKE>
        | token = <K_REGEXP_LIKE>
        | token = <K_REGEXP>
        | token = <K_SIMILAR_TO>
        | token = <K_MATCH_ANY>
        | token = <K_MATCH_ALL>
        | token = <K_MATCH_PHRASE>
        | token = <K_MATCH_PHRASE_PREFIX>
        | token = <K_MATCH_REGEXP>
    ) { result.setLikeKeyWord( LikeExpression.KeyWord.from(token.image)); }
    [ LOOKAHEAD(2) <K_BINARY> {result.setUseBinary(true); } ]
    rightExpression=SimpleExpression()
    [ LOOKAHEAD(2) <K_ESCAPE>
        (
            LOOKAHEAD(2)  token = <S_CHAR_LITERAL> { result.setEscape( new StringValue( token.image ) ); }
            |
            escape=Expression() { result.setEscape(escape); }
        )
    ]
    {
        result.setLeftExpression(leftExpression);
        result.setRightExpression(rightExpression);
        linkAST(result,jjtThis);
        return result;
    }
}

Expression SimilarToExpression(Expression leftExpression) #SimilarToExpression:
{
    SimilarToExpression result = new SimilarToExpression();
    Expression rightExpression = null;
}
{
    [<K_NOT> { result.setNot(true); } ]
    <K_SIMILAR> <K_TO>
    rightExpression=SimpleExpression()
    [ LOOKAHEAD(2) <K_ESCAPE> token=<S_CHAR_LITERAL> { result.setEscape((new StringValue(token.image)).getValue()); }]
    {
        result.setLeftExpression(leftExpression);
        result.setRightExpression(rightExpression);
        linkAST(result,jjtThis);
        return result;
    }
}

Expression IsDistinctExpression(Expression leftExpression) #IsDistinctExpression:
{
    IsDistinctExpression result = new IsDistinctExpression();
    Expression rightExpression = null;
}
{
    <K_IS> [<K_NOT> { result.setNot(true); } ] <K_DISTINCT> <K_FROM>
    rightExpression=SimpleExpression()
    {
        result.setLeftExpression(leftExpression);
        result.setRightExpression(rightExpression);
        linkAST(result,jjtThis);
        return result;
    }
}

Expression IsNullExpression(Expression leftExpression):
{
    IsNullExpression result = new IsNullExpression();
}
{
    (
        [ <K_NOT> { result.setNot(true); } ] <K_ISNULL> { result.setUseIsNull(true); }
        | <K_NOTNULL> { result.setUseIsNull(true); result.setUseNotNull(true); }
        | <K_IS> [<K_NOT> { result.setNot(true); } ] <K_NULL>
    )
    {
        result.setLeftExpression(leftExpression);
        return result;
    }
}

Expression IsBooleanExpression(Expression leftExpression):
{
    IsBooleanExpression result = new IsBooleanExpression();
}
{
        (
          <K_IS> [<K_NOT> { result.setNot(true); } ] (<K_TRUE> { result.setIsTrue(true); } | <K_FALSE> { result.setIsTrue(false); })
        )

    {
        result.setLeftExpression(leftExpression);
        return result;
    }
}

Expression IsUnknownExpression(Expression leftExpression):
{
    IsUnknownExpression result = new IsUnknownExpression();
}
{
        (
          <K_IS> [<K_NOT> { result.setNot(true); } ] <K_UNKNOWN>
        )

    {
        result.setLeftExpression(leftExpression);
        return result;
    }
}

Expression ExistsExpression():
{
    ExistsExpression result = new ExistsExpression();
    Expression rightExpression = null;
}
{
    <K_EXISTS> rightExpression=SimpleExpression()
    {
        result.setRightExpression(rightExpression);
        return result;
    }
}

Expression MemberOfExpression(Expression leftExpression):
{
    MemberOfExpression result;
    Expression rightExpression = null;
}
{
    <K_MEMBER> <K_OF> rightExpression=Expression()
    {
        return new MemberOfExpression(leftExpression, rightExpression );
    }
}

ExpressionList ExpressionList() #ExpressionList:
{
    ExpressionList expressionList;
}
{
    (
        LOOKAHEAD(3, { getAsBoolean(Feature.allowComplexParsing) && !interrupted}) expressionList = ComplexExpressionList()
        |
        LOOKAHEAD(3) expressionList = SimpleExpressionList()
        |
        LOOKAHEAD(3) expressionList = ParenthesedExpressionList()
    )
    {
        // Avoid redundant ExpressionLists containing only one ParenthesedExpressionList
        // return the Parenthesed Sub ExpressionList instead
        // Same for ParenthesedExpressionList containing only 1 ExpressionList

        if ( expressionList.size() == 1 && expressionList.get(0) instanceof ExpressionList ) {
            ExpressionList subList = (ExpressionList) expressionList.get(0);
            if (expressionList instanceof ParenthesedExpressionList) {
                if (subList instanceof ParenthesedExpressionList) {
                    return expressionList;
                } else {
                    return new ParenthesedExpressionList(subList);
                }
            } else {
                if (subList instanceof ParenthesedExpressionList) {
                    return new ParenthesedExpressionList(subList);
                } else {
                    return subList;
                }
            }
        }
        return expressionList;
    }
}

ParenthesedExpressionList ParenthesedExpressionList():
{
    ExpressionList expressions=new ExpressionList();
}
{
    "("
    (
        LOOKAHEAD({ getAsBoolean(Feature.allowComplexParsing) && !interrupted}) expressions = ComplexExpressionList()
        |
        expressions = SimpleExpressionList()
    )?
    ")"
    {
        return new ParenthesedExpressionList(expressions);
    }
}

ExpressionList SimpleExpressionList():
{
    ExpressionList<Column> columns;
    ExpressionList expressions = new ExpressionList();
    Expression expr;
}
{
    expr=SimpleExpression() { expressions.add(expr); }
    (
        LOOKAHEAD(2, {!interrupted} ) ","
        (
            LOOKAHEAD( 7 ) expr=LambdaExpression()
            |
            expr=SimpleExpression()
        )
        {
            expressions.add(expr);
        }
    )*
    {
        return expressions;
    }
}


ExpressionList<Column> ColumnList():
{
    ExpressionList<Column> expressions = new ExpressionList<Column>();
    Column expr;
}
{
    expr=Column() { expressions.add(expr); }
    ( LOOKAHEAD(2) "," expr=Column() { expressions.add(expr); } )*
    {
        return expressions;
    }
}

ParenthesedExpressionList<Column> ParenthesedColumnList():
{
    ExpressionList<Column> expressions;
}
{
    "(" expressions = ColumnList() ")"
    {
        return new ParenthesedExpressionList<Column>(expressions);
    }
}

ExpressionList ComplexExpressionList():
{
    ExpressionList<Column> columns;
    ExpressionList expressions = new ExpressionList();
    Expression expr;
}
{
    (
        LOOKAHEAD(2) expr=OracleNamedFunctionParameter()
        |
        expr=Expression()
    )
    {
        expressions.add(expr);
    }

    (
        LOOKAHEAD(2, {!interrupted}) ","
        (
            LOOKAHEAD(2) expr=OracleNamedFunctionParameter()
            |
            LOOKAHEAD(7) expr=LambdaExpression()
            |
            expr=Expression()
        ) { expressions.add(expr); }
    )*

    {
        return expressions;
    }
}

// @Todo: Refactor this with proper SQL:2016 functions according to https://manticore-projects.com/SQL2016Parser/syntax.html#character-value-function
// substring(expr1 from expr2)
// substring(expr1 from expr2 for expr3)
// trim(expr1 from expr2)   <-- Superceded by TrimFunction() below
// position(expr1 in expr2)
// overlay(expr1 placing expr2 from expr3)
// overlay(expr1 placing expr2 from expr3 for expr4)
// expr1 has already been consumed
NamedExpressionList NamedExpressionListExprFirst():
{
    NamedExpressionList retval = new NamedExpressionList();
    List<Expression> expressions = new ArrayList<Expression>();
    List<String> names = new ArrayList<String>();
    Expression expr1 = null;
    Expression expr2 = null;
    Expression expr3 = null;
    Expression expr4 = null;
    Token tk2 = null;
    Token tk3 = null;
    Token tk4 = null;
}
{
	expr1=SimpleExpression()
	(tk2=<K_FROM>|tk2=<K_IN>|tk2=<K_PLACING>)
	{
		names.add("");
		expressions.add(expr1);
		names.add(tk2.image);
	}
    (
        expr2=SimpleExpression() { expressions.add(expr2);}
		(
			(tk3=<K_FOR>|tk3=<K_FROM>)
			expr3=SimpleExpression() {names.add(tk3.image); expressions.add(expr3);}
			(
				(tk4=<K_FOR>)
				expr4=SimpleExpression() {names.add(tk4.image); expressions.add(expr4);}
			)?
		)?
    )

    {
        retval.setNames(names);
        retval.setExpressions(expressions);
        return retval;
    }
}

Expression ComparisonItem() :
{
    Expression retval = null;
}
{
  (
    LOOKAHEAD( 6 ) retval=AnyComparisonExpression()
    |
    LOOKAHEAD( 3 ) retval=SimpleExpression()
    |
    LOOKAHEAD( 3 ) retval=ParenthesedExpressionList()
    |
    LOOKAHEAD( 3 ) retval=RowConstructor()
    |
    retval=PrimaryExpression()
  )

   {
      return retval;
   }
}

Expression AnyComparisonExpression() :
{
    AnyType anyType;
    Select select;
}
{
    (
        <K_ANY> { anyType = AnyType.ANY; }
        |
        <K_SOME> { anyType = AnyType.SOME; }
        |
        <K_ALL> { anyType = AnyType.ALL; }
    )
    select = ParenthesedSelect()
    {
      return new AnyComparisonExpression(anyType, select);
    }
}

Expression SimpleExpression():
{
    Expression retval = null;
    UserVariable user = null;
    Token operation = null;
}
{
    [ LOOKAHEAD( 5 ) user = UserVariable() ( operation = "=" | operation = ":=" ) ]
    retval=ConcatExpression()
    {
        if (user != null) {
            VariableAssignment assignment = new VariableAssignment();
            assignment.setVariable(user);
            assignment.setOperation(operation.image);
            assignment.setExpression(retval);
            return assignment;
        } else
            return retval;
    }
}

Expression ConcatExpression():
{
    Expression result = null;
    Expression leftExpression = null;
    Expression rightExpression = null;
}
{
    leftExpression=BitwiseAndOr()  { result = leftExpression; }
    (LOOKAHEAD(3)
        <OP_CONCAT>  /* Oracle allows space between the bars. */
        rightExpression=BitwiseAndOr()
        {
            Concat binExp = new Concat();
            binExp.setLeftExpression(leftExpression);
            binExp.setRightExpression(rightExpression);
            result = binExp;
            leftExpression = result;
        }
    )*

    { return result; }
}

Expression BitwiseAndOr():
{
    Expression result = null;
    Expression leftExpression = null;
    Expression rightExpression = null;
}
{
    leftExpression=AdditiveExpression()  { result = leftExpression; }
    (
        LOOKAHEAD(2) (
            "|" { result = new BitwiseOr(); }
            |
            "&" { result = new BitwiseAnd(); }
			|
			"<<" { result = new BitwiseLeftShift(); }
			|
			">>" { result = new BitwiseRightShift(); }
        )

        rightExpression=AdditiveExpression()

        {
            BinaryExpression binExp = (BinaryExpression) result;
            binExp.setLeftExpression(leftExpression);
            binExp.setRightExpression(rightExpression);
            leftExpression = result;
        }
    )*

    { return result; }
}

Expression AdditiveExpression():
{
    Expression result = null;
    Expression leftExpression = null;
    Expression rightExpression = null;
}
{
    leftExpression=MultiplicativeExpression()  { result = leftExpression; }
    ( LOOKAHEAD(2)
        ("+" { result = new Addition(); }
                                    | "-" { result = new Subtraction(); } )

        rightExpression=MultiplicativeExpression()
        {
             BinaryExpression binExp = (BinaryExpression) result;
            binExp.setLeftExpression(leftExpression);
            binExp.setRightExpression(rightExpression);
            leftExpression = result;
        }
    )*

    { return result; }
}

Expression MultiplicativeExpression():
{
    Expression result = null;
    Expression leftExpression = null;
    Expression rightExpression = null;
}
{
    (
      leftExpression=BitwiseXor()
    )
      { result = leftExpression; }
    (
        LOOKAHEAD(2) ("*" { result = new Multiplication(); }
                                    | "/" { result = new Division(); }
                                    | <K_DIV> { result = new IntegerDivision(); }
                                    | "%" { result = new Modulo(); }
                    )

        rightExpression=BitwiseXor()

        {
             BinaryExpression binExp = (BinaryExpression) result;
            binExp.setLeftExpression(leftExpression);
            binExp.setRightExpression(rightExpression);
            leftExpression = result;
        }
    )*
    { return result; }
}

Expression BitwiseXor():
{
    Expression result = null;
    Expression leftExpression = null;
    Expression rightExpression = null;
}
{
    leftExpression=PrimaryExpression()  { result = leftExpression; }
    (  LOOKAHEAD(2)
        "^"
        rightExpression=PrimaryExpression()
        {
            BitwiseXor binExp = new BitwiseXor();
            binExp.setLeftExpression(leftExpression);
            binExp.setRightExpression(rightExpression);
            result = binExp;
            leftExpression = result;
        }
    )*

    { return result; }
}

Expression ArrayExpression(Expression obj): {
    Expression expr;
    Expression idxExpr = null;
    Expression startExpr = null;
    Expression stopExpr = null;
} {
    "["
        [LOOKAHEAD(3) idxExpr = SimpleExpression()]
        [
          (":" { startExpr=idxExpr; idxExpr=null; })
          [stopExpr = SimpleExpression()]
        ]
    "]"
    { expr =  new ArrayExpression(obj, idxExpr, startExpr, stopExpr); }
    (
        LOOKAHEAD(2) "["
            [LOOKAHEAD(3) idxExpr = SimpleExpression()]
            [
              (":" { startExpr=idxExpr; idxExpr=null; })
              [stopExpr = SimpleExpression()]
            ]
        "]"
        { expr =  new ArrayExpression(expr, idxExpr, startExpr, stopExpr); }
    )*
    { return expr; }
}

Expression PrimaryExpression() #PrimaryExpression:
{
    Expression retval = null;
    Expression expression = null;
    CastExpression castExpr = null;
    TimezoneExpression timezoneExpr = null;
    Expression timezoneRightExpr = null;
    Token token = null;
    Token sign = null;
    String tmp = "";
    ColDataType type = null;
    boolean not = false;
    boolean exclamationMarkNot = false;
    boolean dateExpressionAllowed = true;
    ExpressionList list;

    final List<Map.Entry<Expression, String>> jsonIdents = new ArrayList<Map.Entry<Expression, String>>();
}
{
    [ <K_NOT> { not=true; } | "!" { not=true; exclamationMarkNot=true; } ]
    [sign="+" | sign="-" | sign="~"]
    (
        <K_NULL> { retval = new NullValue(); }

        | LOOKAHEAD(3, {!interrupted}) retval=CaseWhenExpression()

        | LOOKAHEAD(2, {!interrupted}) retval=CharacterPrimary()

        | LOOKAHEAD(6, {!interrupted}) retval=ImplicitCast()

        | retval = JdbcParameter()

        | LOOKAHEAD(2) retval =JdbcNamedParameter()

        | LOOKAHEAD(3) retval=UserVariable()

        | LOOKAHEAD(2, {!interrupted}) retval=NumericBind()

        | LOOKAHEAD(4 , {!interrupted}) retval=ExtractExpression()

        | LOOKAHEAD(3) retval=MySQLGroupConcat()

        | retval=XMLSerializeExpr()

        | LOOKAHEAD(3, { !interrupted}) retval = JsonFunction()

        | LOOKAHEAD(3, { !interrupted}) retval = JsonAggregateFunction()

        | LOOKAHEAD(3, { !interrupted}) retval = FullTextSearch()

        | LOOKAHEAD(2, {!interrupted}) retval= CastExpression()

        | LOOKAHEAD(16) retval = Function() [ LOOKAHEAD(2) retval = AnalyticExpression( (Function) retval ) ]

        | LOOKAHEAD(2) retval = DateUnitExpression()

        | LOOKAHEAD(2, {!interrupted}) retval = IntervalExpression() { dateExpressionAllowed = false; }

        | token=<S_DOUBLE>  { retval = new DoubleValue(token.image); }

        | token=<S_LONG> { retval = new LongValue(token.image); }

        | token=<S_HEX>  { retval = new HexValue(token.image); }

        | LOOKAHEAD(3) retval=AllColumns(true)

        | LOOKAHEAD(16) retval=AllTableColumns(true)

        // See issue  #2207
        // there is a huge! performance deterioration from this production
        //| LOOKAHEAD(FunctionAllColumns()) retval=FunctionAllColumns()

        // support timestamp expressions
        | LOOKAHEAD(2, {!interrupted}) (token=<K_TIME_KEY_EXPR> | token=<K_CURRENT>) { retval = new TimeKeyExpression(token.image); }

        | LOOKAHEAD(2, {!interrupted}) retval=DateTimeLiteralExpression()

        | LOOKAHEAD(3 , {!interrupted}) retval=StructType()

        | LOOKAHEAD(3, {!interrupted}) <K_ARRAY_LITERAL> [ "<" type=ColDataType() ">" ] retval=ArrayConstructor(true) { if (type!=null) ((ArrayConstructor) retval).setDataType(type); }

        | LOOKAHEAD(3, {!interrupted}) retval=ArrayConstructor(false)

        | LOOKAHEAD(2, {!interrupted}) retval = NextValExpression()

        | retval=ConnectByRootOperator()

        | retval=ConnectByPriorOperator()

        | LOOKAHEAD(2, {!interrupted}) <K_ALL> { retval = new AllValue(); }

        | LOOKAHEAD(2, {!interrupted}) retval=Column()

        | LOOKAHEAD(2, {!interrupted}) (token=<K_TRUE> | token=<K_FALSE>) { retval = new BooleanValue(token.image); }

        | token=<S_CHAR_LITERAL> { retval = new StringValue(token.image); linkAST(retval,jjtThis); }

        | "{d" token=<S_CHAR_LITERAL> "}"  { retval = new DateValue(token.image); }

        | "{t" token=<S_CHAR_LITERAL> "}"  { retval = new TimeValue(token.image); }

        | "{ts" token=<S_CHAR_LITERAL> "}" { retval = new TimestampValue(token.image); }

        | LOOKAHEAD( Select() , { getAsBoolean(Feature.allowUnparenthesizedSubSelects) && !interrupted } ) retval=Select()

        | LOOKAHEAD( ParenthesedSelect() , { !getAsBoolean(Feature.allowUnparenthesizedSubSelects) && !interrupted } ) retval=ParenthesedSelect()

        |
        (
            list=ParenthesedExpressionList()
             // Mutli-Variable Lambda Expression, e. g.
            // SELECT map_filter(my_column, (k,v) -> v.my_inner_column = 'some_value')
            [ LOOKAHEAD(2) "->"
                  retval = Expression()
                  {
                      retval = LambdaExpression.from(list, retval);
                  }
            ]


            {
                if (list.size() == 1) {
                    retval = new ParenthesedExpressionList( (Expression) list.getExpressions().get(0));
                } else {
                    retval = list;
                }
            }


            // RowGet Expression
            [ LOOKAHEAD(2) "." tmp=RelObjectNameExt() { retval = new RowGetExpression(retval, tmp); }]
        )
    )

    [
        LOOKAHEAD(2) <K_COLLATE> (token=<S_CHAR_LITERAL> | token=<S_QUOTED_IDENTIFIER> | token=<S_IDENTIFIER>) { retval = new CollateExpression(retval, token.image); }
    ]

    [
        LOOKAHEAD(2, { dateExpressionAllowed } ) retval = IntervalExpressionWithoutInterval(retval)
    ]

    [ LOOKAHEAD(2) retval = ArrayExpression(retval) ]

    (  LOOKAHEAD(2) "::" type=ColDataType() {
            castExpr = new CastExpression();
            castExpr.setUseCastKeyword(false);
            castExpr.setLeftExpression(retval);
            castExpr.setColDataType(type);
            retval=castExpr;
        }
    )*

    // Check for JSON operands
    [
        LOOKAHEAD(2) (
            LOOKAHEAD(2) (
                token="->"
                |
                token=":"
                |
                token="->>"
                |
                token="#>"
                |
                token="#>>"
            )

            (
                LOOKAHEAD({getAsBoolean(Feature.allowComplexParsing) && !interrupted }) expression=Expression()
                |
                expression=SimpleExpression()
            )
            {
                jsonIdents.add(new AbstractMap.SimpleEntry<Expression, String>(expression, token.image ));
            }
        )+
        retval = JsonExpression(retval, jsonIdents)
    ]

    ( LOOKAHEAD(2) <K_AT> <K_DATETIMELITERAL> <K_ZONE> timezoneRightExpr=PrimaryExpression() {
        if (timezoneExpr == null)
            timezoneExpr = new TimezoneExpression();

        timezoneExpr.addTimezoneExpression(timezoneRightExpr);
        }
    )*

    {
        if (timezoneExpr != null && !timezoneExpr.getTimezoneExpressions().isEmpty()) {
            timezoneExpr.setLeftExpression(retval);
            retval=timezoneExpr;
        }
        if (sign != null) {
            retval = new SignedExpression(sign.image.charAt(0), retval);
        }
        if (not) {
            retval = new NotExpression(retval, exclamationMarkNot);
        }
        linkAST(retval, jjtThis);
        return retval;
    }
}

/* https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/img_text/hierarchical_query_clause.html

    { CONNECT BY [ NOCYCLE ] condition [ START WITH condition ]
    | START WITH condition CONNECT BY [ NOCYCLE ] condition
    }
 */

ConnectByRootOperator ConnectByRootOperator() #ConnectByRootOperator: {
    Expression expression;
}
{
    <K_CONNECT_BY_ROOT> expression = Expression()
    {
      return new ConnectByRootOperator(expression);
    }
}

ConnectByPriorOperator ConnectByPriorOperator() #ConnectByPriorOperator: {
    Expression expression;
}
{
    <K_PRIOR> expression = Expression()
    {
      return new ConnectByPriorOperator(expression);
    }
}


NextValExpression NextValExpression() : {
    ObjectNames data = null;
    Token token;
}
{
     token=<K_NEXTVAL>  data = RelObjectNames()
    {
        return new NextValExpression(data.getNames(), token.image);
    }
}

JdbcNamedParameter JdbcNamedParameter() : {
    JdbcNamedParameter parameter = new JdbcNamedParameter();
    String name;
    String namePart;
}
{
    (":" | "&" { parameter.setParameterCharacter("&"); } )
    name=IdentifierChain()
    {
        parameter.setName(name);
        return parameter;
    }
}

OracleNamedFunctionParameter OracleNamedFunctionParameter() : {
    Token token = null;
    String name = null;
    Expression expression;
}
{
    ( name=RelObjectNameExt2() | token=<K_OUTER> )
    <K_ORACLE_NAMED_PARAMETER_ASSIGNMENT>
    expression=Expression()
    {
        return new OracleNamedFunctionParameter(name != null ? name : token.image, expression);
    }
}

UserVariable UserVariable() : {
    Token tk;
    String varName;
}
{
    tk = <S_AT_IDENTIFIER> varName=IdentifierChain2(tk.image)
    {
        return new UserVariable(varName);
    }
}

NumericBind NumericBind() : {
    NumericBind var = new NumericBind();
    Token token;
}
{
    ":" token=<S_LONG>
    {
        var.setBindId(Integer.valueOf(token.image));
        return var;
    }
}

DateTimeLiteralExpression DateTimeLiteralExpression() : {
    DateTimeLiteralExpression expr = new DateTimeLiteralExpression();
    Token t;
}
{
    t=<K_DATETIMELITERAL>
    {
        expr.setType(DateTimeLiteralExpression.DateTime.from(t.image));
    }

    ( t=<S_CHAR_LITERAL> | t=<S_QUOTED_IDENTIFIER> )
    {
        expr.setValue(t.image);
        return expr;
    }
}

DateUnitExpression DateUnitExpression() : {
    Token t;
}
{
    t=<K_DATE_LITERAL>  { return new DateUnitExpression( t.image ); }
}

RangeExpression RangeExpression(Expression startExpression):
{
    Expression endExpression;
}
{
    ":" endExpression = Expression()
    {
        return new RangeExpression(startExpression, endExpression);
    }
}

ArrayConstructor ArrayConstructor(boolean arrayKeyword) : {
    ExpressionList expList = new ExpressionList();
    ArrayConstructor array = new ArrayConstructor(expList, arrayKeyword);
    Expression exp;
} {
    "["
    [
        (
            LOOKAHEAD(3) exp = Expression() [ exp=RangeExpression(exp) ]
            |
            exp = ArrayConstructor(false)
        ) { expList.add(exp); }

        (
            ","
            (
                LOOKAHEAD(3) exp = Expression() [ exp=RangeExpression(exp) ]
                |
                exp = ArrayConstructor(false)
            ){ expList.add(exp); }
        )*
    ]
    "]"
    { return array; }
}

List<Map.Entry<String, ColDataType>> StructParameters():
{
    String parameterName = "";
    ColDataType parameterType = null;
    AbstractMap.SimpleEntry<String, ColDataType> parameter = null;
    List<Map.Entry<String, ColDataType>> parameters = new ArrayList<Map.Entry<String, ColDataType>>();
}
{
    [ LOOKAHEAD(2) parameterName = RelObjectName() ]
    parameterType = ColDataType()
    {
        parameters.add( new AbstractMap.SimpleEntry<String, ColDataType>(parameterName, parameterType) );
    }

    (
        "," { parameterName=""; }

        [ LOOKAHEAD(2) parameterName = RelObjectName() ]
        parameterType = ColDataType()
        {
            parameters.add( new AbstractMap.SimpleEntry<String, ColDataType>(parameterName, parameterType) );
        }
    )*

    {
        return parameters;
    }
}

StructType StructType() #StruckType:
{
    StructType.Dialect dialect = StructType.Dialect.BIG_QUERY;
    Token tk1;
    String keyword = "";
    List<Map.Entry<String, ColDataType>> parameters = null;
    List<SelectItem<?>> arguments = null;
    String id = null;
    Expression expression = null;
    StructType type;
}
{
    (
        LOOKAHEAD(4) (
            tk1=<K_STRUCT> { keyword = tk1.image; }
            "<" parameters = StructParameters() ">"
            "(" arguments = SelectItemsList() ")"
        )
        |
        (
            tk1=<K_STRUCT> { keyword = tk1.image; }
            "(" arguments = SelectItemsList() ")"
        )
        |
        (
            <OPENING_CURLY_BRACKET> { arguments= new  ArrayList<SelectItem<?>>(); dialect = StructType.Dialect.DUCKDB;}
            ( id = RelObjectNameExt2() | tk1=<S_CHAR_LITERAL> { id = tk1.image; } )
            <DOUBLE_COLON> expression = Expression() { arguments.add( new SelectItem( expression, id) ); }

            (
                ","
                ( id = RelObjectNameExt2() | tk1=<S_CHAR_LITERAL> { id = tk1.image; } )
                <DOUBLE_COLON> expression = Expression() { arguments.add( new SelectItem( expression, id) ); }
            )*
            <CLOSING_CURLY_BRACKET>

            (
                LOOKAHEAD(2) "::" <K_STRUCT> "(" parameters = StructParameters() ")"
            )*
        )
    )
    {
        type = new StructType(dialect, keyword, parameters, arguments);
        linkAST(type,jjtThis);
        return type;
    }
}

JsonExpression JsonExpression(Expression expr, List<Map.Entry<Expression, String>> idents) : {
  JsonExpression result = new JsonExpression(expr, idents);
  Expression expression;
  Token token=null;
  ColDataType type = null;
  CastExpression castExpr = null;
}
{

    // chaining JSON Expressions, e.g.
    // '{"obj":{"field": "value"}}'::JSON -> 'obj'::TEXT ->> 'field'::TEXT
    (
        LOOKAHEAD(2, {!interrupted} ) (
            LOOKAHEAD(2) (
                "::" type=ColDataType()
                {
                    castExpr = new CastExpression();
                    castExpr.setUseCastKeyword(false);
                    castExpr.setLeftExpression(result);
                    castExpr.setColDataType(type);
                    expr=castExpr;
                }
            )
        )+
        {
            result = new JsonExpression(expr);
        }

        (
            LOOKAHEAD(2) (
                token="->"
                |
                token=":"
                |
                token="->>"
                |
                token="#>"
                |
                token="#>>"
            )

            (
                LOOKAHEAD({getAsBoolean(Feature.allowComplexParsing) && !interrupted}) expression=Expression()
                |
                expression=SimpleExpression()
            )
            {
                result.addIdent( expression, token.image );
            }
        )*
    )*

    {
        result.setExpression(expr);
        return result;
    }
}

JsonKeyValuePair JsonKeyValuePair(boolean isFirstEntry) : {
    Token keyToken;

    boolean usingKeyKeyword = false;
    boolean usingFormatJason = false;
    boolean isWildcard = false;

    Object key = null;
    Expression expression = null;
    JsonFunctionExpression functionExpression;

    JsonKeyValuePairSeparator kvSeparator = JsonKeyValuePairSeparator.NOT_USED;
}
{
    (
        // lookahead because key is a valid column name
        LOOKAHEAD(2) (
            <K_KEY> { usingKeyKeyword = true; }
            (
               keyToken = <S_CHAR_LITERAL> { key = keyToken.image; } |
               key = Column()
            )
        )
        |
        LOOKAHEAD(16) key = AllTableColumns(false) { isWildcard = true; }
        |
        LOOKAHEAD(2) key = AllColumns(false) { isWildcard = true; }
        |
        LOOKAHEAD(2) key = Column()
        |
        LOOKAHEAD({getAsBoolean(Feature.allowExpressionAsJsonObjectKey)}) key = Expression()
        |
        keyToken = <S_CHAR_LITERAL> { key = keyToken.image; }
    )

    // Optional Separator + Value - Is not allowed with * or t1.*
    [ LOOKAHEAD(1, { !isWildcard } )
       (
           <K_VALUE> { kvSeparator = JsonKeyValuePairSeparator.VALUE; }
           |
           <DOUBLE_COLON> { kvSeparator = JsonKeyValuePairSeparator.COLON; }
           |
           LOOKAHEAD({getAsBoolean(Feature.allowCommaAsKeyValueSeparator)}) <K_COMMA> { kvSeparator = JsonKeyValuePairSeparator.COMMA; }
       )
       expression = Expression()
    ]

    // Optional: FORMAT JSON - Is not allowed with * or t1.*
    [ LOOKAHEAD(1, { !isWildcard } ) <K_FORMAT> <K_JSON> { usingFormatJason = true; } ]
    {
        final JsonKeyValuePair keyValuePair = new JsonKeyValuePair( key, expression, usingKeyKeyword, kvSeparator );
        keyValuePair.setUsingFormatJson( usingFormatJason );
        return keyValuePair;
   }
}

JsonFunction JsonObjectBody() : {
    JsonFunction result = new JsonFunction(JsonFunctionType.OBJECT);

    JsonKeyValuePair keyValuePair;
}
{
    ( "("
        (
            // First Element
            LOOKAHEAD(2) keyValuePair = JsonKeyValuePair(true) { result.add(keyValuePair);}

            // Next Elements
            (
                <K_COMMA>  keyValuePair = JsonKeyValuePair(false) { result.add(keyValuePair); }
            )*
        )?
        [
          ( <K_NULL> <K_ON> <K_NULL>  { result.setOnNullType(  JsonAggregateOnNullType.NULL ); } )
          |
          ( <K_ABSENT> <K_ON> <K_NULL> { result.setOnNullType(  JsonAggregateOnNullType.ABSENT ); } )
        ]
        [ <K_STRICT> { result.setStrict(true); } ]
        [
          ( <K_WITH> <K_UNIQUE> <K_KEYS> { result.setUniqueKeysType( JsonAggregateUniqueKeysType.WITH ); } )
          |
          ( <K_WITHOUT> <K_UNIQUE> <K_KEYS> { result.setUniqueKeysType( JsonAggregateUniqueKeysType.WITHOUT ); } )
        ]
    ")" )
    {
        return result;
    }
}

JsonFunction JsonArrayBody() : {
    JsonFunction result = new JsonFunction(JsonFunctionType.ARRAY);

    Expression expression = null;
    JsonFunctionExpression functionExpression;
}
{
    ( "("
        (
            LOOKAHEAD(2) (
                <K_NULL> <K_ON> <K_NULL>  { result.setOnNullType(  JsonAggregateOnNullType.NULL ); }
            )
            |
            expression=Expression() { functionExpression = new JsonFunctionExpression( expression ); result.add( functionExpression ); }

            [ LOOKAHEAD(2) <K_FORMAT> <K_JSON> { functionExpression.setUsingFormatJson( true ); } ]
            (
                ","
                expression=Expression() { functionExpression = new JsonFunctionExpression( expression ); result.add( functionExpression ); }
                [ LOOKAHEAD(2) <K_FORMAT> <K_JSON> { functionExpression.setUsingFormatJson( true ); } ]
            )*
        )*

        [
          <K_ABSENT> <K_ON> <K_NULL> { result.setOnNullType(  JsonAggregateOnNullType.ABSENT ); }
        ]
    ")" )
    {
        return result;
    }
}

JsonFunction JsonFunction() : {
    JsonFunction result;
}
{
    (
      ( <K_JSON_OBJECT> result = JsonObjectBody() )
      |
      ( <K_JSON_ARRAY> result = JsonArrayBody() )
    )
    {
        return result;
    }
}

JsonAggregateFunction JsonAggregateFunction() : {
    JsonAggregateFunction result = new JsonAggregateFunction();
    Token token;
    Object key;
    Expression expression;
    List<OrderByElement> expressionOrderByList = null;

    Expression filter;
    ExpressionList expressionList = null;
    List<OrderByElement> olist = null;
    WindowElement windowElement = null;
    boolean partitionByBrackets = false;
}
{
    (
        (
          ( <K_JSON_OBJECTAGG>
            "(" { result.setType( JsonFunctionType.OBJECT ); }
            (
                LOOKAHEAD(2) (
                    "KEY" { result.setUsingKeyKeyword( true ); }
                    (
                        ( token = <DT_ZONE> | token = <S_DOUBLE> | token = <S_LONG> | token = <S_HEX> | token = <S_CHAR_LITERAL> )
                        {
                            key = token.image;
                        }
                        |
                        key = Column()
                    )
                )
                |
                ( token = <DT_ZONE> | token = <S_DOUBLE> | token = <S_LONG> | token = <S_HEX> | token = <S_CHAR_LITERAL> )
                {
                    key = token.image;
                }
                |
                key = Column()
            )
            {
                result.setKey( key );
            }

            ( ":" | ","  { result.setType( JsonFunctionType.MYSQL_OBJECT ); } | "VALUE" {result.setUsingValueKeyword( true ); } )
            expression = Expression() { result.setValue( expression ); }

            [ <K_FORMAT> <K_JSON> { result.setUsingFormatJson( true ); } ]

            [
              LOOKAHEAD(2) (
                  <K_NULL> <K_ON> <K_NULL>  { result.setOnNullType(  JsonAggregateOnNullType.NULL ); }
              )
              |
              (
                  <K_ABSENT> <K_ON> <K_NULL> { result.setOnNullType(  JsonAggregateOnNullType.ABSENT ); }
              )
            ]

            [
              (
                  <K_WITH> <K_UNIQUE> <K_KEYS> { result.setUniqueKeysType( JsonAggregateUniqueKeysType.WITH ); }
              )
              |
              (
                  <K_WITHOUT> <K_UNIQUE> <K_KEYS> { result.setUniqueKeysType( JsonAggregateUniqueKeysType.WITHOUT ); }
              )
            ]
            ")"
          )
          |
          (
            <K_JSON_ARRAYAGG>
            "(" { result.setType( JsonFunctionType.ARRAY ); }
            expression=Expression() { result.setExpression( expression ); }
            [ <K_FORMAT> <K_JSON> { result.setUsingFormatJson( true ); } ]
            [ expressionOrderByList = OrderByElements() { result.setExpressionOrderByElements( expressionOrderByList ); } ]

            [
              LOOKAHEAD(2) (
                  <K_NULL> <K_ON> <K_NULL>  { result.setOnNullType(  JsonAggregateOnNullType.NULL ); }
              )
              |
              (
                  <K_ABSENT> <K_ON> <K_NULL> { result.setOnNullType(  JsonAggregateOnNullType.ABSENT ); }
              )
            ]

            ")"
          )
        )

        // -- Filter
        [ LOOKAHEAD(2) <K_FILTER> "(" <K_WHERE> { result.setAnalyticType(AnalyticType.FILTER_ONLY); } filter = Expression() { result.setFilterExpression( filter ); } ")"  ]

        // -- OVER
        [   LOOKAHEAD(2)
            <K_OVER> {result.setAnalyticType(AnalyticType.OVER);}
            "("
            [<K_PARTITION> <K_BY>
                (LOOKAHEAD(3) expressionList=ComplexExpressionList()
                | "(" {partitionByBrackets = true;} expressionList=ComplexExpressionList() ")" )
            ]
            [olist=OrderByElements() ]
            [windowElement = WindowElement() ]
            {
                result.setPartitionExpressionList(expressionList, partitionByBrackets);
                result.setOrderByElements(olist);
                result.setWindowElement(windowElement);
            }
            ")"
        ]
    )

    {
        return result;
    }
}

IntervalExpression IntervalExpression() : {
    IntervalExpression interval = new IntervalExpression();
    Token token = null;
    Expression expr = null;
    boolean signed = false;
}
{

    <K_INTERVAL>
    (

        LOOKAHEAD(3) (
            [ "-" {signed=true;}]
            (token=<S_LONG> | token=<S_DOUBLE>)
        )
        |
        LOOKAHEAD(2) token=<S_CHAR_LITERAL>
        |
        expr = Expression()
    )
    {
        if (expr != null) {
            if (signed) expr = new SignedExpression('-', expr);
            interval.setExpression(expr);
        } else {
            interval.setParameter((signed?"-":"") + token.image);
        }
    }
    [ LOOKAHEAD(2) (token = <S_IDENTIFIER> | token = <K_DATE_LITERAL>) { interval.setIntervalType(token.image); } ]
    {
        return interval;
    }
}

IntervalExpression IntervalExpressionWithoutInterval(Expression expr) : {
    IntervalExpression interval;
    Token token;
    boolean signed = false;
}
{
    {
        interval = new IntervalExpression(false);
        interval.setExpression(expr);
    }
    token = <K_DATE_LITERAL>
    {
        interval.setIntervalType(token.image);
        return interval;
    }
}

KeepExpression KeepExpression() : {
    KeepExpression keep = new KeepExpression();
    Token token;
    List<OrderByElement> list;
}
{
    <K_KEEP> "(" token = <S_IDENTIFIER> (<K_FIRST> { keep.setFirst(true); } | <K_LAST> { keep.setFirst(false); })
      list = OrderByElements() ")"

    {
        keep.setName(token.image);
        keep.setOrderByElements(list);
        return keep;
    }
}


void windowFun(AnalyticExpression retval):{
     ExpressionList expressionList = null;
     boolean partitionByBrackets = false;
     String windowName = null;
     WindowDefinition winDef;
} {
    (
        <K_OVER> {retval.setType(AnalyticType.OVER);}
        |
        <K_WITHIN> <K_GROUP> {retval.setType(AnalyticType.WITHIN_GROUP);}
    )

    (
        windowName = RelObjectName() { retval.setWindowName(windowName); }
        |
        winDef = windowDefinition() { retval.setWindowDefinition(winDef); }

        [
            LOOKAHEAD(2) <K_OVER> "("
            [   <K_PARTITION> <K_BY>
                    (LOOKAHEAD(3) expressionList=ComplexExpressionList()
                    | "(" {partitionByBrackets = true;} expressionList=ComplexExpressionList() ")" )
            ]
            ")" { winDef.setPartitionExpressionList(expressionList, partitionByBrackets); retval.setType(AnalyticType.WITHIN_GROUP_OVER); }
        ]
    )
}

WindowDefinition windowDefinition() : {
    ExpressionList expressionList = null;
    List<OrderByElement> olist = null;
    WindowElement windowElement = null;
    boolean partitionByBrackets = false;
    WindowDefinition winDef = new WindowDefinition();
} {
    "("
    [<K_PARTITION> <K_BY>
        (LOOKAHEAD(3) expressionList=ComplexExpressionList()
        | "(" {partitionByBrackets = true;} expressionList=ComplexExpressionList() ")" )
    ]
    [olist=OrderByElements() ]
    [windowElement = WindowElement() ]
    {
        winDef.setPartitionExpressionList(expressionList, partitionByBrackets);
        winDef.setOrderByElements(olist);
        winDef.setWindowElement(windowElement);
    }
    ")"
    { return winDef; }
}

AnalyticExpression AnalyticExpression(Function function) :
{
    AnalyticExpression retval = new AnalyticExpression(function);
    Expression filter = null;
}
{
    (
        (
            <K_FILTER> "(" <K_WHERE> {retval.setType(AnalyticType.FILTER_ONLY);} filter = Expression() ")"
            [ LOOKAHEAD(2) windowFun(retval) ]
        )
        | windowFun(retval)
    )
    {
        retval.setFilterExpression(filter);
        return retval;
    }
}

WindowElement WindowElement():
{
    WindowElement windowElement = new WindowElement();
    WindowRange range = new WindowRange();
    WindowOffset offset = null;
}
{
    (<K_ROWS> { windowElement.setType(WindowElement.Type.ROWS); }  |  <K_RANGE> { windowElement.setType(WindowElement.Type.RANGE); } )
    ( (
      <K_BETWEEN> { windowElement.setRange(range); }
      offset = WindowOffset() { range.setStart(offset); }
      <K_AND> offset = WindowOffset() { range.setEnd(offset); }
      )
    |
      offset = WindowOffset() { windowElement.setOffset(offset); }
    )

    {
        return windowElement;
    }
}

WindowOffset WindowOffset():
{
    WindowOffset offset = new WindowOffset();
    Expression expr = null;
}
{
    (
		(
			<K_UNBOUNDED> (<K_PRECEDING> { offset.setType(WindowOffset.Type.PRECEDING); } |
											<K_FOLLOWING> { offset.setType(WindowOffset.Type.FOLLOWING); } )
		)
		|
		LOOKAHEAD(2) ( <K_CURRENT> <K_ROW> { offset.setType(WindowOffset.Type.CURRENT); } )
		|
		( expr = SimpleExpression() {
			offset.setType(WindowOffset.Type.EXPR);
			offset.setExpression(expr);
			}
			(<K_PRECEDING> { offset.setType(WindowOffset.Type.PRECEDING); } | <K_FOLLOWING> { offset.setType(WindowOffset.Type.FOLLOWING);  } )
		)
	)

    {
        return offset;
    }
}

ExtractExpression ExtractExpression() :
{
    ExtractExpression retval = new ExtractExpression();
    String fieldName = null;
    Token token = null;
    Expression expr = null;
}
{
    <K_EXTRACT>
    "("
        ( fieldName=RelObjectName() { retval.setName(fieldName); } | token=<S_CHAR_LITERAL> { retval.setName(token.image); } )
        <K_FROM>
        expr=SimpleExpression() { retval.setExpression(expr); }
    ")"
    {
        return retval;
    }
}

CastExpression ImplicitCast() #ImplicitCast:
{
    ColDataType colDataType;
    Token tk1;
    Token tk2;

    int precision = -1;
    int scale = -1;
}
{
    colDataType = DataType()
    (
        tk2 = <S_CHAR_LITERAL>
        |
        tk2 = <S_LONG>
        |
        tk2 = <S_DOUBLE>
    )
    {
        CastExpression castExpression = new CastExpression(colDataType, tk2.image);
        return castExpression;
    }
}

CastExpression CastExpression():
{
    Token keyword;
    CastExpression retval;
    ColumnDefinition columnDefinition;
    ColDataType type;
    Expression expression = null;
    boolean    useCastKeyword;
    Token formatCharLiteral;
}
{
    (
        keyword=<K_CAST>
        |
        keyword=<K_SAFE_CAST>
        |
        keyword=<K_TRY_CAST>
        |
        keyword=<K_INTERPRET>
    )
    {
        retval = new CastExpression(keyword.image);
    }
    "("
    expression=SimpleExpression()
    <K_AS> { retval.setUseCastKeyword(true); }
    (
        LOOKAHEAD(2) (
            <K_ROW>
            "("
            columnDefinition=ColumnDefinition() { retval.addColumnDefinition(columnDefinition); }
            ( "," columnDefinition=ColumnDefinition() { retval.addColumnDefinition(columnDefinition); } )*
            ")"
        )
        |
        type=ColDataType() { retval.setColDataType(type); }
    )

    // BigQuery FORMAT clause
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions#cast_as_date
    [ <K_FORMAT> formatCharLiteral=<S_CHAR_LITERAL> { retval.setFormat(formatCharLiteral.image); } ]

    ")"

    {
        retval.setLeftExpression(expression);
        return retval;
    }
}

Expression CaseWhenExpression() #CaseWhenExpression:
{
    CaseExpression caseExp = new CaseExpression();
    Expression switchExp = null;
    WhenClause clause;
    List<WhenClause> whenClauses = new ArrayList<WhenClause>();
    Expression elseExp = null;
}
{
    <K_CASE> { caseCounter++; }
    [ LOOKAHEAD(2) switchExp=Expression() ]
    ( clause=WhenThenSearchCondition() { whenClauses.add(clause); } )+
    [
        <K_ELSE>
        (
              LOOKAHEAD({getAsBoolean(Feature.allowComplexParsing) && !interrupted}) elseExp=Expression()
              | elseExp=SimpleExpression()
        )
    ]
    <K_END>  { caseCounter--; }
    {
        caseExp.setSwitchExpression(switchExp);
        caseExp.setWhenClauses(whenClauses);
        caseExp.setElseExpression(elseExp);
        return caseExp;
    }
}

WhenClause WhenThenSearchCondition():
{
    WhenClause whenThen = new WhenClause();
    Expression whenExp;
    Expression thenExp;
}
{
    <K_WHEN> whenExp=Expression()
    <K_THEN>
    (
        LOOKAHEAD({getAsBoolean(Feature.allowComplexParsing) && !interrupted}) thenExp=Expression()
        |
        thenExp=SimpleExpression()
    )
    {
       whenThen.setWhenExpression(whenExp);
       whenThen.setThenExpression(thenExp);
       return whenThen;
    }
}

RowConstructor RowConstructor(): {
    Token token;
    ParenthesedExpressionList expressions;
} {
    token=<K_ROW>
    expressions = ParenthesedExpressionList()
    {
        return new RowConstructor(token.image, expressions);
    }
}

/**
TODO: VariableExpression should be a standalone class with more operations available.
*/
EqualsTo VariableExpression(): {
    Expression left;
    Expression right;
} {
    left = UserVariable() "=" right = SimpleExpression()
    {
        EqualsTo equals = new EqualsTo();
        equals.setLeftExpression(left);
        equals.setRightExpression(right);
        return equals;
    }
}

Execute Execute(): {
    Token token;
    ObjectNames funcName;
    ExpressionList expressionList = null;
    Execute execute = new Execute();
    List<Expression> namedExprList;
    Expression expr;
}
{
    (<K_EXEC> { execute.setExecType(Execute.ExecType.EXEC); }
        | <K_EXECUTE> { execute.setExecType(Execute.ExecType.EXECUTE); }
        | <K_CALL> { execute.setExecType(Execute.ExecType.CALL); } )

    funcName=RelObjectNames() { execute.setName(funcName.getNames()); }

    (
        LOOKAHEAD(2)  expressionList=ExpressionList() { execute.setExprList(expressionList); }
    )?

    {
        return execute;
    }
}

FullTextSearch FullTextSearch() : {
    Token searchModifier;
    Token againstValue;
    JdbcParameter jdbcParameter;
    JdbcNamedParameter jdbcNamedParameter;
    FullTextSearch fs = new FullTextSearch();
    ExpressionList<Column> matchedColumns;
}
{
    <K_MATCH> "(" matchedColumns=ColumnList() ")" <K_AGAINST>
    "("
    (
      againstValue=<S_CHAR_LITERAL> { fs.setAgainstValue(new StringValue(againstValue.image)); }
      |
      jdbcParameter=JdbcParameter() { fs.setAgainstValue(  jdbcParameter ); }
      |
      jdbcNamedParameter=JdbcNamedParameter() { fs.setAgainstValue(  jdbcNamedParameter ); }
    )
    [
        (
            searchModifier="IN NATURAL LANGUAGE MODE"
            | searchModifier="IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION"
            | searchModifier="IN BOOLEAN MODE"
            | searchModifier="WITH QUERY EXPANSION"
        )
        { fs.setSearchModifier(searchModifier.image); }
    ]
    ")"
    {
        fs.setMatchColumns(matchedColumns);
        return fs;
    }
}

LambdaExpression LambdaExpression() #LambdaExpression:
{
    ExpressionList<Column> columns;
    String s;
    Expression expression;
    LambdaExpression lambdaExpression;
}
{
    (
        columns = ParenthesedColumnList()
        |
        s = RelObjectName() { columns = new ExpressionList<Column>(new Column(s)); }
    )

    "->"
    expression = Expression()
    {
        lambdaExpression = LambdaExpression.from(columns, expression);
        linkAST(lambdaExpression,jjtThis);
        return lambdaExpression;
    }
}

Function Function() #Function:
{
    Function function;
}
{
    (
        "{" <K_FN> function = InternalFunction(true) "}"
        | LOOKAHEAD(3) function = SpecialStringFunctionWithNamedParameters()
        | function = InternalFunction(false)
    )
    {
        linkAST(function,jjtThis);
        return function;
    }
}

Function SpecialStringFunctionWithNamedParameters() :
{
    Token funcName;
    NamedExpressionList namedExpressionList = null;
    ExpressionList expressionList = null;
    List<OrderByElement> orderByList;
}
{
        funcName = <K_STRING_FUNCTION_NAME>

        "("
        (
            LOOKAHEAD( NamedExpressionListExprFirst() , { getAsBoolean(Feature.allowComplexParsing) }) namedExpressionList = NamedExpressionListExprFirst()
            |
            expressionList=ExpressionList()
        )
        ")"

    {
        return new Function()
            .withName(funcName.image)
            .withNamedParameters(namedExpressionList)
            .withParameters(expressionList);
    }
}

Function InternalFunction(boolean escaped):
{
    Token prefixToken = null;
    Function retval = new Function();
    ObjectNames funcName;
    ExpressionList expressionList = null;
    KeepExpression keep = null;
    Expression expr = null;
    Expression attributeExpression = null;
    Column attributeColumn = null;
    List<OrderByElement> orderByList;
    String onOverflowTruncate = null;
    Token overflowToken = null;
    Limit limit;
    Token extraKeywordToken;
}
{
    [ LOOKAHEAD(2) prefixToken = <K_APPROXIMATE> ]
    funcName = RelObjectNames() { if (prefixToken!=null) funcName.getNames().add(0, prefixToken.image ); }

    "("
    [
        LOOKAHEAD(2) [
            LOOKAHEAD(2) (
                <K_DISTINCT> { retval.setDistinct(true); }
                | <K_ALL> { retval.setAllColumns(true); }
                | <K_UNIQUE> { retval.setUnique(true); }
            )
        ]
        (
            LOOKAHEAD(3) [ LOOKAHEAD(2) extraKeywordToken = <K_TABLE> { retval.setExtraKeyword(extraKeywordToken.image); } ]
            expressionList=ExpressionList()
            [ orderByList = OrderByElements() { retval.setOrderByElements(orderByList); } ]

            // https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/LISTAGG.html
            [
                <K_ON> <K_OVERFLOW> ( overflowToken=<K_TRUNCATE> | overflowToken=<K_ERROR> ) { onOverflowTruncate=overflowToken.image; }
                [
                    overflowToken = <S_CHAR_LITERAL> { onOverflowTruncate+= " " + overflowToken.image; }
                    [ ( overflowToken=<K_WITH> |  overflowToken=<K_WITHOUT> ) <K_COUNT> { onOverflowTruncate+=" " + overflowToken.image + " COUNT"; }]
                ]
            ] { retval.setOnOverflowTruncate(onOverflowTruncate); }

            |
            LOOKAHEAD({ !getAsBoolean(Feature.allowUnparenthesizedSubSelects) }) expr = Select() { expressionList = new ExpressionList(expr); }
        )
    ]

    [
        <K_HAVING> (
            <K_MIN> expr = Expression() { retval.setHavingClause( "MIN", expr ); }
            |
            <K_MAX> expr = Expression() { retval.setHavingClause( "MAX", expr ); }
        )
    ]

    [
        (
            <K_IGNORE> <K_NULLS> { retval.setNullHandling(Function.NullHandling.IGNORE_NULLS); }
        )
        |
        (
             <K_RESPECT> <K_NULLS> {  retval.setNullHandling(Function.NullHandling.RESPECT_NULLS); }
        )
    ]

    [
        limit = PlainLimit() { retval.setLimit(limit); }
    ]

    ")"


    [ LOOKAHEAD(2) "." (
            // tricky lookahead since we do need to support the following constructs
            // schema.f1().f2() - Function with Function Column
            // schema.f1().f2.f3 - Function with Attribute Column
            LOOKAHEAD( 6 ) attributeExpression=Function() { retval.setAttribute(attributeExpression); }
            |
            attributeColumn=Column() { retval.setAttribute(attributeColumn); }
          )
    ]

    [ LOOKAHEAD(2) (
            (
                <K_IGNORE> <K_NULLS>
                {
                    retval.setNullHandling(Function.NullHandling.IGNORE_NULLS);
                    retval.setIgnoreNullsOutside(true);
                }
            )
            |
            (
                 <K_RESPECT> <K_NULLS>
                 {
                    retval.setNullHandling(Function.NullHandling.RESPECT_NULLS);
                    retval.setIgnoreNullsOutside(true);
                 }
            )
        )
    ]

    [ LOOKAHEAD(2) keep = KeepExpression() ]

    {
        retval.setEscaped(escaped);
        retval.setParameters(expressionList);
        retval.setName(funcName.getNames());
        retval.setKeep(keep);
        return retval;
    }
}

XMLSerializeExpr XMLSerializeExpr(): {
   XMLSerializeExpr result;
   Expression expression;
   List<OrderByElement> orderByElements = null;
   ColDataType dataType;
}
{
    <K_XMLSERIALIZE>
        "(" <K_XMLAGG>
                "(" <K_XMLTEXT>
                        "(" expression=SimpleExpression() ")"
                [ orderByElements=OrderByElements() ]
        ")"
        <K_AS> dataType=ColDataType() ")"
    {
        result = new XMLSerializeExpr();
        result.setExpression(expression);
        result.setOrderByElements(orderByElements);
        result.setDataType(dataType);
        return result;
    }
}


MySQLGroupConcat MySQLGroupConcat():{
    MySQLGroupConcat retval = new MySQLGroupConcat();
    ExpressionList expressionList = null;
    List<OrderByElement> orderByList = null;
    Token t;
}
{
    <K_GROUP_CONCAT> "("
       [<K_DISTINCT>  { retval.setDistinct(true); } ]
       expressionList = ExpressionList()
       [ orderByList = OrderByElements() { retval.setOrderByElements(orderByList); } ]
       [ <K_SEPARATOR> t=<S_CHAR_LITERAL> { retval.setSeparator(t.image); } ]
    ")"
    {
        retval.setExpressionList(expressionList);
        return retval;
    }
}

TableFunction TableFunction():
{
    Token prefix = null;
    Function function;
    TableFunction functionItem;
    Token withClause = null;
}
{
    [ prefix = <K_LATERAL> ]
    function=Function()
    [ LOOKAHEAD(2) <K_WITH> ( withClause = <K_OFFSET> | withClause = <K_ORDINALITY> ) ]
    {
        return  prefix!=null
            ? withClause!=null
                ? new TableFunction(prefix.image, function, withClause.image)
                : new TableFunction(prefix.image, function)
            : withClause!=null
                ? new TableFunction(function, withClause.image)
                : new TableFunction(function);
    }
}

List<Index.ColumnParams> ColumnNamesWithParamsList() : {
    List<Index.ColumnParams> colNames = new ArrayList<Index.ColumnParams>();
    String columnName;
    List<String> parameter = null;
}
{
     "("
    columnName=RelObjectName()

    { parameter = null; }
    [ parameter = CreateParameter() ]
    {
        colNames.add(new Index.ColumnParams(columnName,parameter));
    }

    (
        ","
        columnName=RelObjectName()

        { parameter = null; }
        [ parameter = CreateParameter() ]
        {
            colNames.add(new Index.ColumnParams(columnName,parameter));
        }
    )*

    ")"

    { return colNames; }
}

Index Index(): {
    ObjectNames name;
}
{
    name= RelObjectNames() { return new Index().withName(name.getNames()).withType(""); }
}

CreateIndex CreateIndex():
{
    CreateIndex createIndex = new CreateIndex();
    Table table = null;
    List<Index.ColumnParams> colNames;
    String indexType;
    Index index = null;
    List<String> parameter = new ArrayList<String>();
    List<String> tailParameters = new ArrayList<String>();
    List<String> name;
}
{
    [ parameter=CreateParameter() ]

    <K_INDEX>
    [ LOOKAHEAD(2) <K_IF> <K_NOT> <K_EXISTS> { createIndex.setUsingIfNotExists(true);} ]
    index = Index() { index.setType(parameter.isEmpty() ? null : parameter.get(0)); }
    (
        LOOKAHEAD(3)(
            <K_ON> table=Table()
            [ indexType=UsingIndexType() { index.setUsing(indexType); } ]
        )
        |
        (
            [ indexType=UsingIndexType() {
                    index.setUsing(indexType);
                    createIndex.setIndexTypeBeforeOn(true);
                }
            ]
            <K_ON> table=Table()
        )
    )
    colNames = ColumnNamesWithParamsList()
    ( LOOKAHEAD(2)  parameter=CreateParameter() { tailParameters.addAll(parameter); } )*
    {
        index.setColumns(colNames);
        createIndex.setIndex(index);
        createIndex.setTable(table);
        createIndex.setTailParameters(tailParameters);
        return createIndex;
    }
}

ColumnDefinition ColumnDefinition(): {
    ColumnDefinition coldef;
    String columnName;
    ColDataType colDataType;
    List<String> columnSpecs = new ArrayList<String>();
    List<String> parameter;
} {
    columnName=RelObjectName()
    colDataType=ColDataType()
    ( LOOKAHEAD(2) parameter=CreateParameter() { columnSpecs.addAll(parameter); } )*
    {
        coldef = new ColumnDefinition();
        coldef.setColumnName(columnName);
        coldef.setColDataType(colDataType);
        if (columnSpecs.size() > 0)
            coldef.setColumnSpecs(columnSpecs);
        return coldef;
    }
}

CreateSchema CreateSchema():
{
    Token tk = null;
    CreateTable table = null;
    CreateView view = null;
    CreateSchema schema = new CreateSchema();
    List<String> schemaPath = null;
    List<Statement> statements = new ArrayList<Statement>();
}
{
    <K_SCHEMA>
    [ LOOKAHEAD(2) <K_IF> <K_NOT> <K_EXISTS> { schema.setIfNotExists(true); } ]
    [
        ( tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER>) { schema.setSchemaName(tk.image); }

        (
            "." { schema.setCatalogName(tk.image); }
            ( tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER>) { schema.setSchemaName(tk.image); }
        )?
    ]

    [ <K_AUTHORIZATION>
        (tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER>) { schema.setAuthorization(tk.image); }
    ]

    [schemaPath=PathSpecification() { schema.setSchemaPath(schemaPath); }]

    (
        LOOKAHEAD(2) (
            <K_CREATE>

            table = CreateTable(false)
            {
                table.getTable().setSchemaName(schema.getSchemaName());
                schema.addStatement(table);
            }
            |
            view = CreateView(false)
            {
                view.getView().setSchemaName(schema.getSchemaName());
                schema.addStatement(view);
            }
        )
    )*
    {
        return schema;
    }
}

List<String> PathSpecification():
{
    Token tk;
    List<String> pathList = new ArrayList<String>();
}
{
    <K_PATH> (tk=<S_IDENTIFIER>|tk=<S_QUOTED_IDENTIFIER>) { pathList.add(tk.image); }
        ("," (tk=<S_IDENTIFIER>|tk=<S_QUOTED_IDENTIFIER>) { pathList.add(tk.image); })*
    {
        return pathList;
    }
}

CreateTable CreateTable(boolean isUsingOrReplace):
{
    CreateTable createTable = new CreateTable();
    Table table = null;
    List<ColumnDefinition> columnDefinitions = new ArrayList<ColumnDefinition>();
    List<String> columnSpecs = null;
    List<String> tableOptions = new ArrayList<String>();
    List<String> createOptions = new ArrayList<String>();
    String columnName;
    Token tk = null;
    Token tk2 = null;
    Token tk3 = null;
    String sk3 = null;
    ColDataType colDataType = null;
    String stringList = null;
    ColumnDefinition coldef = null;
    List<Index> indexes = new ArrayList<Index>();
    List<Index.ColumnParams> colNames = null;
    List<String> colNames2 = null;
    Index index = null;
    ForeignKeyIndex fkIndex = null;
    List<String> parameter = new ArrayList<String>();
    List<String> idxSpec = new ArrayList<String>();
    Table fkTable = null;
    SpannerInterleaveIn interleaveIn = null;
    Select select = null;
    Table likeTable = null;
    CheckConstraint checkCs = null;
    ExcludeConstraint excludeC = null;
    RowMovement rowMovement = null;
    ReferentialAction.Action action = null;
    String tableColumn = null;
    List<String> columns = new ArrayList<String>();
}
{
    { createTable.setOrReplace(isUsingOrReplace);}
    [ <K_UNLOGGED> { createTable.setUnlogged(true); } ]

    // table options, not required but 1 or none
    [ tk=<K_GLOBAL> { createOptions.add(tk.image);} ]
    /* [ [ (tk=<K_GLOBAL> | tk=<K_LOCAL>) {createOptions.add(tk.image);} ]
       ( tk=<K_TEMPORARY> | tk=<K_TEMP> ) {createOptions.add(tk.image);}] */

    (parameter = CreateParameter() { createOptions.addAll(parameter); })*

    <K_TABLE>
    [ LOOKAHEAD(2) <K_IF> <K_NOT> <K_EXISTS> { createTable.setIfNotExists(true); }]
    table=Table()
    [ LOOKAHEAD(2) (
        LOOKAHEAD(3) (
            "(" tableColumn=RelObjectName() { columns.add(tableColumn); } ("," tableColumn=RelObjectName() { columns.add(tableColumn); } )* ")"
        )
        |
            (
                "("
                coldef = ColumnDefinition() { columnDefinitions.add(coldef); }

                (
                    ","
                    (
                        LOOKAHEAD(3) (
                            {
                                idxSpec.clear();
                            }
                            tk=<K_INDEX>
                            sk3=RelObjectName()
                            colNames = ColumnNamesWithParamsList()
                            ( parameter=CreateParameter() { idxSpec.addAll(parameter); } )*
                            {
                                index = new Index().withType(tk.image).withName(sk3).withColumns(colNames).withIndexSpec(new ArrayList<String>(idxSpec));
                                indexes.add(index);
                            }
                        )
                        |
                        LOOKAHEAD(3) (
                            {
                                index = new NamedConstraint();
                                tk2=null;
                                idxSpec.clear();
                            }
                            [ <K_CONSTRAINT> sk3=RelObjectName() {index.setName(sk3);} ]

                            (
                                tk=<K_PRIMARY> tk2=<K_KEY>
                                |
                                tk=<K_UNIQUE> [ tk2=<K_KEY> ]
                            )
                            {
                                index.setType( tk.image + ( tk2!=null ? " " + tk2.image : "" ));
                                tk2=null;
                            }

                            colNames = ColumnNamesWithParamsList()
                            ( parameter=CreateParameter() { idxSpec.addAll(parameter); } )*
                            {
                                index.withColumns(colNames).withIndexSpec(new ArrayList<String>(idxSpec));
                                indexes.add(index);
                            }
                        )
                        |
                        LOOKAHEAD(3) (
                            {
                                tk=null;
                                idxSpec.clear();
                            }
                            [ tk=<K_UNIQUE> ]
                            [ tk3=<K_FULLTEXT> ] tk2=<K_KEY>
                            sk3=RelObjectName()
                            colNames = ColumnNamesWithParamsList()
                            ( parameter=CreateParameter() { idxSpec.addAll(parameter); } )*
                            {
                                index = new Index()
                                    .withType( ( tk!=null ? tk.image + " " : "") + ( tk3!=null ? tk3.image + " ":"" ) + tk2.image)
                                    .withName(sk3)
                                    .withColumns(colNames)
                                    .withIndexSpec(new ArrayList<String>(idxSpec));
                                indexes.add(index);
                            }
                        )
                        |
                        LOOKAHEAD(3)(
                            {
                                fkIndex = new ForeignKeyIndex();
                                sk3=null;

                            }
                            [ <K_CONSTRAINT> sk3=RelObjectName() { fkIndex.setName(sk3); } ]
                            tk=<K_FOREIGN> tk2=<K_KEY>
                            colNames = ColumnNamesWithParamsList()
                            {
                                fkIndex.withType(tk.image + " " + tk2.image).withColumns(colNames);
                            }
                            <K_REFERENCES> fkTable=Table() colNames2=ColumnsNamesList()
                            {
                                fkIndex.setTable(fkTable);
                                fkIndex.setReferencedColumnNames(colNames2);
                                indexes.add(fkIndex);
                            }
                            [ LOOKAHEAD(2) (
                                <K_ON>
                                ( tk=<K_DELETE> | tk=<K_UPDATE> ) action = Action()
                                { fkIndex.setReferentialAction(ReferentialAction.Type.from(tk.image), action); }
                              )
                            ]
                            [ LOOKAHEAD(2) (
                                <K_ON>
                                ( tk=<K_DELETE> | tk=<K_UPDATE>) action = Action()
                                { fkIndex.setReferentialAction(ReferentialAction.Type.from(tk.image), action); }
                                )
                            ]
                        )
                        |
                         LOOKAHEAD(3)(
                            {
                                sk3 = null;
                                Expression exp = null;
                            }
                            [ <K_CONSTRAINT>  sk3 = RelObjectName() ]
                            <K_CHECK>  ( "(" exp = Expression() ")" )*
                            {
                               checkCs = new CheckConstraint().withName(sk3).withExpression(exp);
                               indexes.add(checkCs);
                            }
                        )
                        |
                            LOOKAHEAD(2) tk=<K_EXCLUDE> {excludeC = new ExcludeConstraint(); Expression exp = null;}
                            (tk2=<K_WHERE>
                                ("(" exp = Expression() ")")* {excludeC.setExpression(exp);})
                            {
                                indexes.add(excludeC);
                            }
                        |
                        (
                            coldef = ColumnDefinition()
                            { columnDefinitions.add(coldef); }
                        )
                    )
                )*

                ")"
            )
        )
    ]
    ( LOOKAHEAD(2, { getToken(1).kind != K_AS }) parameter=CreateParameter() { tableOptions.addAll(parameter); } )*

    // see https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_7002.htm#i2126725
    // table properties , all these are optional
    [ rowMovement = RowMovement() { createTable.setRowMovement(rowMovement); }]
    [ <K_AS> select = Select() { createTable.setSelect(select, false); }]
    [
    <K_LIKE> ( LOOKAHEAD("(" Table() ")") "(" likeTable=Table() { createTable.setLikeTable(likeTable, true); } ")"
                 | likeTable=Table() { createTable.setLikeTable(likeTable, false); } )
    ]
    [ <K_COMMA> interleaveIn = SpannerInterleaveIn( ) { createTable.setSpannerInterleaveIn(interleaveIn); } ]
    {
        createTable.setTable(table);
        if (indexes.size() > 0)
            createTable.setIndexes(indexes);
        if (createOptions.size() > 0)
            createTable.setCreateOptionsStrings(createOptions);
        if (tableOptions.size() > 0)
            createTable.setTableOptionsStrings(tableOptions);
        if (columnDefinitions.size() > 0)
            createTable.setColumnDefinitions(columnDefinitions);
        if (columns.size() > 0)
            createTable.setColumns(columns);
        return createTable;
    }
}

SpannerInterleaveIn SpannerInterleaveIn():
{
    Table table = null;
    SpannerInterleaveIn.OnDelete action = null;
}
{
    <K_INTERLEAVE> <K_IN> <K_PARENT> table = Table()
    [
        <K_ON> <K_DELETE>
            (
                    <K_NO> <K_ACTION> { action = SpannerInterleaveIn.OnDelete.NO_ACTION; }
                    | <K_CASCADE> { action = SpannerInterleaveIn.OnDelete.CASCADE; }
            )
    ]
    {
        return new SpannerInterleaveIn(table, action);
    }
}


ColDataType DataType():
{
    ColDataType colDataType = new ColDataType();
    Token prefix = null;
    Token tk = null;
    Token tk2 = null;
    String schema;
    String type="";
    List<String> argumentsStringList = new ArrayList<String>();
    List<Integer> array = new ArrayList<Integer>();
    List<String> name;
    ColDataType arrayType;

    int precision = -1;
    int scale = -1;
}
{
    (
        LOOKAHEAD(2) tk=<K_TEXT_LITERAL> {
            type = tk.image;
            return new ColDataType(type, precision, scale);
        }
        |
		LOOKAHEAD(2) tk=<K_ARRAY_LITERAL> (
            ("<" arrayType = ColDataType() ">") {
                 colDataType.setDataType("ARRAY<" + arrayType.getDataType() + ">");
            }
        )
        |
        (
            ( tk=<K_DATETIMELITERAL> | tk=<DT_ZONE> | tk = <DATA_TYPE>  | tk = <K_SIGNED>  | tk = <K_UNSIGNED>
                | tk=<K_CHARACTER>  |  tk=<K_BIT> | tk=<K_BYTES> | tk=<K_BINARY> | tk=<K_BOOLEAN>
                | tk=<K_CHAR> | tk=<K_JSON> | tk=<K_STRING> ) { type = tk.image; }
            [
                // MySQL seems to allow: INT UNSIGNED
                LOOKAHEAD(2) ( LOOKAHEAD(2) ( tk = <DATA_TYPE>  | tk = <K_SIGNED>  | tk = <K_UNSIGNED>
                                   | tk=<K_CHARACTER>  | tk=<K_BIT> | tk=<K_BYTES> | tk=<K_BINARY> | tk=<K_BOOLEAN>
                                   | tk=<K_CHAR> | tk=<K_JSON>  | tk=<K_STRING> ) { type += " " + tk.image; } )+
            ]
            [
                LOOKAHEAD(2) "(" ( tk=<S_LONG> { precision = Integer.valueOf(tk.image); } |  tk=<K_MAX> { precision = Integer.MAX_VALUE; } )
                [ "," tk = <S_LONG> { scale = Integer.valueOf(tk.image); } ]
                ")"
            ]
            {
                colDataType = new ColDataType(type, precision, scale);
            }
        )
    )

    {
        return colDataType;
    }
}

ColDataType ColDataType():
{
    ColDataType colDataType = new ColDataType();
    Token prefix = null;
    Token tk = null;
    Token tk2 = null;
    String schema;
    String type="";
    List<String> argumentsStringList = new ArrayList<String>();
    List<Integer> array = new ArrayList<Integer>();
    List<String> name;
    ColDataType arrayType;

    int precision = -1;
    int scale = -1;
}
{
    (
        (
            <K_STRUCT>
            "("
            type = RelObjectNameExt2()
            colDataType = ColDataType() { argumentsStringList.add( type + " " + colDataType.toString()); }
            (
                ","
                type = RelObjectNameExt2()
                colDataType = ColDataType() { argumentsStringList.add( type + " " + colDataType.toString()); }
            )*
            ")" { colDataType = new ColDataType("STRUCT"); }
        )
		|
		LOOKAHEAD(2) (
            colDataType = DataType()
        )
        |
		(
		    tk=<S_IDENTIFIER>
		    | tk=<S_QUOTED_IDENTIFIER>
		    | tk=<K_DATETIMELITERAL>
		    | tk=<K_DATE_LITERAL>
		    | tk=<K_XML>
		    | tk=<K_INTERVAL>
			| tk=<DT_ZONE>
			| tk=<K_CHAR>
			| tk=<K_SET>
			| tk=<K_BINARY>
			| tk=<K_JSON>
			| tk=<K_STRING>
			| tk=<K_PUBLIC>
			| tk=<K_DATA>
			| tk=<K_NAME>
        ) { schema = tk.image; }

        [ LOOKAHEAD(2) "."  arrayType = ColDataType()  { schema += "." + arrayType.toString(); } ]
        { colDataType.setDataType(schema); }
    )

    [
        LOOKAHEAD(2) "(" {tk2 =null;}
        (
            (
                (
                    ( tk=<S_LONG> | tk=<K_MAX> ) [ LOOKAHEAD(2) (tk2=<K_BYTE> | tk2=<K_CHAR>) ]
                )
                |
                tk=<S_CHAR_LITERAL>
                |
                tk=<S_IDENTIFIER>
                |
                tk=<K_CHAR>
            )
		    {
		        argumentsStringList.add(tk.image + (tk2!=null?" " + tk2.image:""));
            }

            [ "," ]
        )*
        ")"
    ]
    [ LOOKAHEAD(2) ( LOOKAHEAD(2) "[" {tk=null;} [ tk=<S_LONG> ] { array.add(tk!=null?Integer.valueOf(tk.image):null); } "]" )+ { colDataType.setArrayData(array); } ]
    [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> (tk=<S_IDENTIFIER> | tk=<K_BINARY>) { colDataType.setCharacterSet(tk.image); } ]

    {
        if (argumentsStringList.size() > 0)
            colDataType.setArgumentsStringList(argumentsStringList);
        return colDataType;
    }
}

Analyze Analyze():
{
    Analyze analyze = new Analyze();
    Table table = null;
}
{
    <K_ANALYZE>
    table=Table()

    {
    	analyze.setTable(table);
    	return analyze;
    }
}

ExpressionList<Column> ColumnWithCommentList():
{
    ExpressionList<Column> expressions = new ExpressionList<Column>();
    Column img = null;
}
{
    "("
         img=Column() { expressions.add(img); }
         ( "," img=Column() { expressions.add(img); } )*
    ")"
    {
        return expressions;
    }
}


CreateView CreateView(boolean isUsingOrReplace):
{
    CreateView createView = new CreateView();
    Table view = null;
    Select select = null;
    ExpressionList<Column> columnNames = null;
    Token tk = null;
    List<String> commentTokens = null;
}
{
    { createView.setOrReplace(isUsingOrReplace);}
    [
        <K_NO> <K_FORCE> { createView.setForce(ForceOption.NO_FORCE); }
        | <K_FORCE> { createView.setForce(ForceOption.FORCE); }
    ]
    [ <K_SECURE> { createView.setSecure(true);} ]
    [
        <K_TEMP> { createView.setTemporary(TemporaryOption.TEMP); }
        | <K_TEMPORARY> { createView.setTemporary(TemporaryOption.TEMPORARY); }
        | <K_VOLATILE> { createView.setTemporary(TemporaryOption.VOLATILE); }
    ]
    [ <K_MATERIALIZED> { createView.setMaterialized(true);} ]
    <K_VIEW> view=Table() { createView.setView(view); }
    [LOOKAHEAD(3) <K_AUTO> <K_REFRESH> (tk=<K_YES> | tk=<K_NO>) { createView.setAutoRefresh(AutoRefreshOption.from(tk.image)); } ]
    [LOOKAHEAD(3) <K_IF> <K_NOT> <K_EXISTS> {createView.setIfNotExists(true);}]
    [ columnNames=ColumnWithCommentList( ) { createView.setColumnNames(columnNames); } ]
    [ commentTokens=CreateViewTailComment( ) { createView.setViewCommentOptions(commentTokens); } ]
    <K_AS>
    select=Select( ) { createView.setSelect(select); }
    [ LOOKAHEAD(2)  <K_WITH> <K_READ> <K_ONLY> { createView.setWithReadOnly(true); } ]
    { return createView; }
}

List<String> CreateViewTailComment():
{
    Token tk = null;
    Token tk2 = null;
    String op = null;
    List<String> result = new ArrayList<String>();
}
{
    tk=<K_COMMENT>
    [ "=" { op = "="; } ]
    tk2 = <S_CHAR_LITERAL> {
         result.add("");
         result.add(tk.image);
         if (op != null) {
             result.add(op);
         }
         result.add(tk2.image);
    }
    { return result;}
}


ReferentialAction.Action Action():
{
    ReferentialAction.Action action = null;
}
{
    (<K_CASCADE> { action=ReferentialAction.Action.CASCADE;}
     |
     <K_RESTRICT> {action=ReferentialAction.Action.RESTRICT;}
     |
     <K_NO> <K_ACTION> {action=ReferentialAction.Action.NO_ACTION;}
     |
     <K_SET> (
	          <K_NULL> {action=ReferentialAction.Action.SET_NULL;}
              |
              <K_DEFAULT> {action=ReferentialAction.Action.SET_DEFAULT;}
             )
     )
    { return action; }
}

AlterView AlterView(boolean useReplace):
{
    AlterView alterView = new AlterView();
    Table view = null;
    Select select = null;
    List<String> columnNames = null;
}
{
    <K_VIEW> view=Table() { alterView.setView(view); alterView.setUseReplace(useReplace); }
    [ columnNames = ColumnsNamesList() { alterView.setColumnNames(columnNames); } ]
    <K_AS>
    select=Select()
    {
        alterView.setSelect(select);
        return alterView;
    }
}

List<String> CreateParameter():
{
    String retval = "";
    Token tk = null, tk2 = null;
    Expression exp = null;
    ColDataType colDataType;
    List<String> param = new ArrayList<String>();
}
{
    (
        // Postgres: nextval('public.actor_actor_id_seq'::regclass)
        ( <K_NEXTVAL> "("  tk=<S_CHAR_LITERAL> "::" colDataType = ColDataType() ")" )
        {
            param.add("NextVal( " + tk.image + "::" + colDataType + ")" );
        }
        |
        (
            //@todo: implement a proper identifier
            (tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> | tk=<K_NAME>)
            { retval+=tk.image; }

            [
                "."
                //@todo: implement a proper identifier
                (tk2=<S_IDENTIFIER> | tk2=<S_QUOTED_IDENTIFIER> | tk=<K_NAME>)
                { retval+="."+tk2.image; }
            ]
            { param.add(retval); }
        )
        |
        LOOKAHEAD(3) [<K_USING> <K_INDEX> { param.add("USING INDEX"); }] <K_TABLESPACE> retval=RelObjectName()
        { param.add("TABLESPACE " + retval); }
        |
        (
            tk=<S_CHAR_LITERAL> | tk=<K_NULL> | tk=<K_NOT> | tk=<K_AUTO_INCREMENT> | tk=<K_PRIMARY> | tk=<K_FOREIGN>
            | tk=<K_REFERENCES> | tk=<K_KEY> | tk=<K_STORED> | tk=<K_ON> | tk=<K_COMMIT> | tk=<K_DROP>
            | tk=<K_ROWS> | tk=<K_UNIQUE> | tk=<K_CASCADE> | tk=<K_DELETE> | tk=<K_UPDATE>
            | tk=<K_CONSTRAINT> | tk=<K_WITH> | tk=<K_EXCLUDE> | tk=<K_WHERE>
            | tk=<K_TEMP> | tk=<K_TEMPORARY> | tk=<K_PARTITION> | tk=<K_BY> | tk=<K_IN>
            | tk=<K_TYPE> | tk=<K_COMMENT> | tk=<K_USING> | tk=<K_COLLATE> | tk=<K_ASC>
            | tk=<K_DESC> | tk=<K_TRUE> | tk=<K_FALSE> | tk=<K_PARALLEL> | tk=<K_BINARY> | tk=<K_START> | tk=<K_ORDER>
            | tk=<K_TIME_KEY_EXPR> | tk=<K_RAW> | tk=<K_HASH> | tk=<K_FIRST> | tk=<K_LAST> | tk = <K_SIGNED>  | tk = <K_UNSIGNED>
            | tk=<K_ENGINE> | tk=<K_IDENTITY> | tk=<K_MATERIALIZED>
            | tk="="
        )
        { param.add(tk.image); }
        |
        ( tk=<K_DEFAULT> | tk=<K_AS> | tk=<K_CHECK> ) [ LOOKAHEAD(2) "(" exp = Expression() ")" ]
        {
            param.add(tk.image);
            if (exp!=null) {
                param.add("(" + exp + ")");
            }
        }
        |
        (
            [ ( tk="+" | tk="-" ) { retval = tk.image; } ]
            tk=<S_LONG> | tk=<S_DOUBLE>
        )
        { param.add( retval + tk.image ); }
        |
        retval=AList() { param.add(retval); }
        |
        (tk=<K_CHARACTER> tk2=<K_SET>) { param.add(tk.image); param.add(tk2.image);}
        |
        (<K_ARRAY_LITERAL> exp=ArrayConstructor(true)) { param.add(exp.toString()); }
        |
        tk="::" colDataType = ColDataType() { param.add(tk.image); param.add(colDataType.toString()); }
    )
    {return param;}
}

// row_movement_clause https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_7002.htm#i2204697
RowMovement RowMovement():
{
  RowMovement rowMovement = new RowMovement();
}
{
  (
    (<K_ENABLE> <K_ROW> <K_MOVEMENT>) { rowMovement.setMode(RowMovementMode.ENABLE); }
    |
    (<K_DISABLE> <K_ROW> <K_MOVEMENT>) { rowMovement.setMode(RowMovementMode.DISABLE); }
  )
  { return rowMovement;}
}

String AList():
{
    StringBuilder retval = new StringBuilder("(");
    Token tk = null;
    String name = null;
}
{
     "("

     (
       ( (tk=<S_LONG> | tk=<S_DOUBLE> | tk=<S_CHAR_LITERAL> | tk=<K_TRUE> | tk=<K_FALSE>) { retval.append(tk.image); }
         | (name=RelObjectNameWithoutValue()) { retval.append(name); })
       [("," {retval.append(",");} | "=" {retval.append("=");})] )*

    ")"
    {
        retval.append(")");
        return retval.toString();
    }
}

String ColumnsNamesListItem():
{
	Token tk = null;
    String item = null;
}
{
	( item = RelObjectName() )
	[ LOOKAHEAD(2)  "(" tk = <S_LONG>  ")" { item = item + "(" + tk.image + ")"; } ]
	{
		return item;
	}
}

List<String> ColumnsNamesList():
{
    List<String> retval = new ArrayList<String>();
    String img = null;
}
{
    "("
         img=ColumnsNamesListItem() { retval.add(img); }
         ( "," img=ColumnsNamesListItem() { retval.add(img); } )*

    ")"
    {
        return retval;
    }
}

String FuncArgsListItem():
{
	Token tk = null;
    String argName = null;
    String argType = null;
}
{
    (
        LOOKAHEAD(2) (
            argName = RelObjectName()
            argType = RelObjectName()
            [ "(" tk = <S_LONG>  ")" { argType = argType + "(" + tk.image + ")"; } ]
        )
        |
        (
            argType = RelObjectName()
            [ "(" tk = <S_LONG>  ")" { argType = argType + "(" + tk.image + ")"; } ]
        )
    )
	{
	    return argName != null ? String.format("%s %s", argName, argType) : argType;
	}
}

List<String> FuncArgsList():
{
    List<String> retval = null;
    String img = null;
}
{
    "("
         { retval = new ArrayList<String>(); }
         [
            img=FuncArgsListItem() { retval.add(img); }
            ( "," img=FuncArgsListItem() { retval.add(img); } )*
         ]
    ")"
    {
        return retval;
    }
}

Drop Drop():
{
    Drop drop = new Drop();
    Token tk = null;
    Table name;
    List<String> dropArgs = new ArrayList<String>();
    List<String> funcArgs = null;
    boolean useTemporary = false;
}
{
    <K_DROP>
    [ <K_MATERIALIZED> { drop.setMaterialized(true);} ]
    (
        tk=<S_IDENTIFIER>
        |
        (
            [ <K_TEMPORARY> {useTemporary=true;} ] tk=<K_TABLE>
        )
        |
        tk=<K_INDEX>
        |
        tk=<K_VIEW>
        |
        tk=<K_SCHEMA>
        |
        tk=<K_SEQUENCE>
        |
        tk=<K_FUNCTION>
    )
    { drop.setType(tk.image); }

    [ LOOKAHEAD(2) <K_IF> <K_EXISTS> {drop.setIfExists(true);} ]

    name = Table() { drop.setName(name); }
    [ LOOKAHEAD(2)  funcArgs = FuncArgsList() ]
    (
        (
            tk=<S_IDENTIFIER> | tk=<K_CASCADE> | tk=<K_RESTRICT>
        ) { dropArgs.add(tk.image); }
        |
        (
            <K_ON> name = Table() { dropArgs.add("ON"); dropArgs.add(name.toString()); }
        )
    )*
    {
        if (dropArgs.size() > 0) {
            drop.setParameters(dropArgs);
        }
        if (drop.getType().equals("FUNCTION")) {
            drop.getTypeToParameters().put("FUNCTION", funcArgs);
        }

        drop.setUsingTemporary(useTemporary);

        return drop;
    }
}

Truncate Truncate():
{
    Truncate truncate = new Truncate();
    Table table;
    List<Table> tables = new ArrayList<Table>();
    boolean only = false;
    boolean cascade = false;
}
{
/**
* TRUNCATE can be followed directly by the table name in Postgresql
* See: https://www.postgresql.org/docs/current/sql-truncate.html
*
* TRUNCATE [ TABLE ] [ ONLY ] name [ * ] [, ... ]
*      [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
*
*/
    <K_TRUNCATE>
    [LOOKAHEAD(2) <K_TABLE>  {truncate.setTableToken(true);}]
    [<K_ONLY>  { only = true; }]
    table=Table() { tables.add(table); } (LOOKAHEAD(2) "," table=Table() { tables.add(table); } )*
    [<K_CASCADE> { cascade = true; }]
    {
       if (only && tables.size() > 1 ) {
          throw new ParseException("Cannot TRUNCATE ONLY with multiple tables");
       } else {
          return truncate
             .withTables(tables)
             .withTable(table)
             .withOnly(only)
             .withCascade(cascade);
       }
    }
}

AlterExpression.ColumnDataType AlterExpressionColumnDataType():
{
    String columnName = null;
    boolean withType = false;
    ColDataType dataType = null;
    List<String> columnSpecs = null;
    List<String> parameter = null;
}
{
    columnName = RelObjectName() { columnSpecs = new ArrayList<String>(); }
    ( LOOKAHEAD(2) <K_TYPE> { withType = true; } )?
    ( LOOKAHEAD(2) dataType = ColDataType() )?
    ( LOOKAHEAD(2) parameter = CreateParameter() { columnSpecs.addAll(parameter); } )*
    {
        return new AlterExpression.ColumnDataType(columnName, withType, dataType, columnSpecs);
    }
}

AlterExpression.ColumnDropNotNull AlterExpressionColumnDropNotNull():
{
    String columnName = null;
    boolean withNot = false;
    ColDataType dataType = null;
    List<String> columnSpecs = null;
    List<String> parameter = null;
}
{
    columnName = RelObjectName()
    <K_DROP>
    (<K_NOT> { withNot = true; } )?
    <K_NULL>
    {
        return new AlterExpression.ColumnDropNotNull(columnName, withNot);
    }
}

AlterExpression.ColumnDropDefault AlterExpressionColumnDropDefault():
{
    String columnName = null;
    boolean withNot = false;
    ColDataType dataType = null;
    List<String> columnSpecs = null;
    List<String> parameter = null;
}
{
    columnName = RelObjectName() <K_DROP> <K_DEFAULT>
    {
        return new AlterExpression.ColumnDropDefault(columnName);
    }
}

AlterExpression.ColumnSetDefault AlterExpressionColumnSetDefault():
{
    String columnName = null;
    Expression defaultValue = null;
}
{
    columnName = RelObjectName() <K_SET> <K_DEFAULT> defaultValue = Expression()
    {
        return new AlterExpression.ColumnSetDefault(columnName, defaultValue.toString());
    }
}

AlterExpression.ColumnSetVisibility AlterExpressionColumnSetVisibility():
{
    String columnName = null;
    boolean visible = true;
}
{
    columnName = RelObjectName() <K_SET>
    (
        <K_VISIBLE> { visible = true; } |
        <K_INVISIBLE> { visible = false; }
    )
    {
        return new AlterExpression.ColumnSetVisibility(columnName, visible);
    }
}

List<ConstraintState> AlterExpressionConstraintState():
{
    List<ConstraintState> retval = new ArrayList<ConstraintState>();
}
{
    (
        (
          <K_DEFERRABLE> {retval.add(new DeferrableConstraint(false));}
        )
        |
        (
          <K_NOT> <K_DEFERRABLE> {retval.add(new DeferrableConstraint(true));}
        )
        |
        (
          <K_VALIDATE> {retval.add(new ValidateConstraint(false));}
        )
        |
        (
          <K_NOVALIDATE> {retval.add(new ValidateConstraint(true));}
        )
        |
        (
          <K_ENABLE> {retval.add(new EnableConstraint(false));}
        )
        |
        (
          <K_DISABLE> {retval.add(new EnableConstraint(true));}
        )
    )*
    {
        return retval;
    }
}

Index IndexWithComment(Index index):
{
    Token tk = null;
}
{
    <K_COMMENT> tk=<S_CHAR_LITERAL> {
        index.setCommentText(tk.image);
    }
    {
        return index;
    }
}

void IndexOptionList(List<String> list) :
{}
{
    (
       LOOKAHEAD(2) IndexOption(list)
    )*
}

String UsingIndexType() :
{
    String sk = null;
}
{
    <K_USING> ( sk = RelObjectName() )
    {
        return sk;
    }
}

void IndexOption(List<String> list) :
{
    Token tk1 = null;
    Token tk2 = null;
    String sk1 = null;
    boolean useEqual = false;
}
{
    (
      tk1=<K_KEY_BLOCK_SIZE> ["=" { useEqual = true; } ] tk2=<S_LONG>
      {
        list.add("KEY_BLOCK_SIZE" +  (useEqual ? " = " : "") + tk2.image);
      }
    |
      tk1=<K_WITH> <K_PARSER> tk2=<S_IDENTIFIER>
      {
        list.add("WITH PARSER " + tk2.image);
      }
    |
      tk1=<K_COMMENT> tk2=<S_CHAR_LITERAL>
      {
        list.add("COMMENT " + tk2.image);
      }
    |
      tk1=<K_VISIBLE>
      {
        list.add("VISIBLE");
      }
    |
      tk1=<K_INVISIBLE>
      {
        list.add("INVISIBLE");
      }
    |
      sk1 = UsingIndexType(){
        list.add("USING " + sk1);
      }
    )
}

List<PartitionDefinition> PartitionDefinitions():
{
    Token tk;
    List<PartitionDefinition> partitionDefinitions = new ArrayList<PartitionDefinition>();
    PartitionDefinition partitionDef = null;
    String partitionName = null;
    String partitionOperation = null;
    String storageEngine = null;
    Expression exp = null;
}
{
    "("
        (
            <K_PARTITION>
            partitionName=RelObjectName()
            {
                List<String> values = new ArrayList<String>();
            }
            <K_VALUES>
            (
                <K_LESS> <K_THAN>
                (
                    "(" exp = Expression() ")"{
                        values.add(exp.toString());
                    }
                    | <K_MAXVALUE> { values.add("MAXVALUE"); }
                ) {
                    partitionOperation = "VALUES LESS THAN";
                }
            )
            [ "ENGINE" "=" tk=<S_IDENTIFIER> { storageEngine = tk.image; } ]
            {
                partitionDef = new PartitionDefinition(partitionName, partitionOperation, values, storageEngine);
                partitionDefinitions.add(partitionDef);
            }
            [ "," ]
        )*
    ")"
    {
        return partitionDefinitions;
    }
}

List<String> PartitionNamesList() :
{
    Token tk;
    List<String> partitionNames = new ArrayList<String>();
}
{
    (
        tk = <K_ALL> {
            partitionNames.add(tk.image);
        }
        |
        tk = <S_IDENTIFIER> {
            partitionNames.add(tk.image);
        }
        (
            LOOKAHEAD(2) "," tk = <S_IDENTIFIER> {
                partitionNames.add(tk.image);
            }
        )*
    )
    {
        return partitionNames;
    }
}

/**
* This production needs refactoring to multiple smaller productions. The target class should
* be splitted as well.
*/
AlterExpression AlterExpression():
{
    AlterExpression alterExp = new AlterExpression();
    Token tk;
    Token tk2 = null;
    String sk3 = null;
    String sk4 = null;
    ColDataType dataType;
    List<String> columnNames = null;
    List<ConstraintState> constraints = null;
    ForeignKeyIndex fkIndex = null;
    Index index = null;
    Table fkTable = null;
    AlterExpression.ColumnDataType alterExpressionColumnDataType = null;
    AlterExpression.ColumnDropNotNull alterExpressionColumnDropNotNull = null;
    AlterExpression.ColumnDropDefault alterExpressionColumnDropDefault = null;
    AlterExpression.ColumnSetDefault alterExpressionColumnSetDefault = null;
    AlterExpression.ColumnSetVisibility alterExpressionColumnSetVisibility = null;
    ReferentialAction.Action action = null;
    List<String> partitions = null;
    List<PartitionDefinition> partitionDefinition = null;
    String truncatePartitionName = null;

    String identifier = null;
    List<String> indexSpec = new ArrayList<String>();

    // for captureRest()
    List<String> tokens = new LinkedList<String>();
}
{

    (
        (
            (
                <K_ADD> { alterExp.setOperation(AlterOperation.ADD);
                }
                |
                <K_ALTER> { alterExp.setOperation(AlterOperation.ALTER); }
                |
                <K_MODIFY> { alterExp.setOperation(AlterOperation.MODIFY); }
            )

            (
                LOOKAHEAD(2) (<K_PRIMARY> <K_KEY> columnNames=ColumnsNamesList() { alterExp.setPkColumns(columnNames); })

                constraints=AlterExpressionConstraintState() { alterExp.setConstraints(constraints); }
                [<K_USING> sk4=RelObjectName() { alterExp.addParameters("USING", sk4); }]
                |
                LOOKAHEAD(2) (
                  (tk=<K_KEY> { alterExp.setUk(true); } | tk=<K_INDEX>)
                  (
                      LOOKAHEAD(3)
                      sk3 = RelObjectName()
                      [ LOOKAHEAD(2) sk4 = UsingIndexType() ]
                      [ LOOKAHEAD(2) columnNames = ColumnsNamesList() ]
                      |
                      [ LOOKAHEAD(2) sk4 = UsingIndexType() ]
                      [ LOOKAHEAD(2) columnNames = ColumnsNamesList() ]
                  )
                  IndexOptionList(indexSpec = new ArrayList<String>())
                  {
                    index = new Index()
                            .withIndexKeyword(tk.image)
                            .withName(sk3)
                            .withUsing(sk4)
                            .withColumnsNames(columnNames)
                            .withIndexSpec(indexSpec);

                    alterExp.setIndex(index);
                  }
                  constraints=AlterExpressionConstraintState() { alterExp.setConstraints(constraints); }
                )
                |
                LOOKAHEAD(4)
                (
                  ( tk=<K_SPATIAL> | tk=<K_FULLTEXT> )
                  [ LOOKAHEAD(2) ( tk2=<K_INDEX> | tk2=<K_KEY> ) ]
                  (
                      sk3 = RelObjectName()
                      columnNames = ColumnsNamesList()
                      |
                      columnNames = ColumnsNamesList()
                  )
                  IndexOptionList(indexSpec = new ArrayList<String>())
                  {
                      String type = tk.image;
                      String keyword = tk2 != null ? tk2.image : null;
                      index = new Index()
                          .withType(type)
                          .withIndexKeyword(keyword)
                          .withColumnsNames(columnNames)
                          .withIndexSpec(indexSpec);

                      if (sk3 != null) {
                          index.setName(sk3);
                      }

                      alterExp.setIndex(index);
                  }
                )
                |
                LOOKAHEAD(2) (
                  sk3=RelObjectName() <K_COMMENT> tk=<S_CHAR_LITERAL> { alterExp.withColumnName(sk3).withCommentText(tk.image); }
                )
                |
                LOOKAHEAD(3) (
                    <K_PARTITION> {
                        alterExp.setOperation(AlterOperation.ADD_PARTITION);
                    }
                    partitionDefinition=PartitionDefinitions() {
                        alterExp.setPartitionDefinitions(partitionDefinition);
                    }
                )
                |
                LOOKAHEAD(3) (
                    ( LOOKAHEAD(2)
                        (
                            <K_COLUMN> { alterExp.hasColumn(true); }
                            |
                            <K_COLUMNS> { alterExp.hasColumns(true); }
                        )
                    )?
                    [ <K_IF> <K_NOT> <K_EXISTS> { alterExp.setUseIfNotExists(true); } ]
                    (
                        LOOKAHEAD(3) alterExpressionColumnDropDefault = AlterExpressionColumnDropDefault()
                            { alterExp.addColDropDefault(alterExpressionColumnDropDefault); }
                        |
                        LOOKAHEAD(3) alterExpressionColumnSetDefault = AlterExpressionColumnSetDefault()
                            { alterExp.addColSetDefault(alterExpressionColumnSetDefault); }
                        |
                        LOOKAHEAD(3) alterExpressionColumnSetVisibility = AlterExpressionColumnSetVisibility()
                            { alterExp.addColSetVisibility(alterExpressionColumnSetVisibility); }
                        |
                        LOOKAHEAD(4) (
                            "("
                                { alterExp.useBrackets(true);}
                                alterExpressionColumnDataType = AlterExpressionColumnDataType() {
                                    alterExp.addColDataType(alterExpressionColumnDataType);
                                }
                                (
                                    ","
                                    alterExpressionColumnDataType = AlterExpressionColumnDataType() {
                                        alterExp.addColDataType(alterExpressionColumnDataType);
                                    }
                                )*
                            ")"
                        )
                        |
                        LOOKAHEAD(2) alterExpressionColumnDataType = AlterExpressionColumnDataType()
                            { alterExp.addColDataType(alterExpressionColumnDataType); }
                        |
                        LOOKAHEAD(3) alterExpressionColumnDropNotNull = AlterExpressionColumnDropNotNull()
                            { alterExp.addColDropNotNull( alterExpressionColumnDropNotNull);}
                    )
                )
                |
                LOOKAHEAD(3) alterExpressionColumnDropDefault = AlterExpressionColumnDropDefault()
                    { alterExp.addColDropDefault(alterExpressionColumnDropDefault); }
                |
                LOOKAHEAD(3) alterExpressionColumnSetDefault = AlterExpressionColumnSetDefault()
                    { alterExp.addColSetDefault(alterExpressionColumnSetDefault); }
                |
                LOOKAHEAD(3) alterExpressionColumnSetVisibility = AlterExpressionColumnSetVisibility()
                    { alterExp.addColSetVisibility(alterExpressionColumnSetVisibility); }
                |
                (
                    "(" alterExpressionColumnDataType = AlterExpressionColumnDataType() { alterExp.addColDataType(alterExpressionColumnDataType); }
                        (","
                            alterExpressionColumnDataType = AlterExpressionColumnDataType() { alterExp.addColDataType(alterExpressionColumnDataType); }
                        )*
                    ")"
                )
                |
                ( <K_UNIQUE> ((<K_KEY> { alterExp.setUk(true); } | <K_INDEX>) (tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER>) { alterExp.setUkName(tk.image); } )?
                    columnNames=ColumnsNamesList() { alterExp.setUkColumns(columnNames); }
                    [ <K_USING> sk4=RelObjectName() { alterExp.addParameters("USING", sk4); }]
                    [ LOOKAHEAD(2) index = IndexWithComment(index) { alterExp.setIndex(index); } ]
                )
                |
                //following two choices regarding foreign keys should be merged
                ( <K_FOREIGN> <K_KEY> columnNames=ColumnsNamesList() { alterExp.setFkColumns(columnNames); columnNames = null; }
                     /*
                        <K_REFERENCES> tk=<S_IDENTIFIER> [ columnNames=ColumnsNamesList() ]
                        { alterExp.setFkSourceTable(tk.image); alterExp.setFkSourceColumns(columnNames); }
                     */
                     <K_REFERENCES> fkTable=Table() [ LOOKAHEAD(2) columnNames=ColumnsNamesList() ]
                        {
                            alterExp.setFkSourceSchema(fkTable.getSchemaName());
                            alterExp.setFkSourceTable(fkTable.getName());
                            alterExp.setFkSourceColumns(columnNames);
                        }

                    [LOOKAHEAD(2) (<K_ON> (tk=<K_DELETE> | tk=<K_UPDATE>) action = Action()
                        { alterExp.setReferentialAction(ReferentialAction.Type.from(tk.image), action); }
                    )]
                    [LOOKAHEAD(2) (<K_ON> (tk=<K_DELETE> | tk=<K_UPDATE>) action = Action()
                        { alterExp.setReferentialAction(ReferentialAction.Type.from(tk.image), action); }
                    )]
                )
                |
                LOOKAHEAD(3) (
                    <K_CHECK> sk3=RelObjectName()
                    { boolean enforced = true; }
                    [ tk = <K_NOT> { enforced = false; } ]
                    <K_ENFORCED> {
                        alterExp.setEnforced(enforced);
                        alterExp.setConstraintType("CHECK");
                        alterExp.setConstraintSymbol(sk3);
                    }
                )
                |
                (
                    <K_CONSTRAINT>
                    (
                        LOOKAHEAD(2)
                        (
                            <K_UNIQUE> (<K_KEY> { alterExp.setConstraintType("UNIQUE KEY"); }
                            | <K_INDEX> { alterExp.setConstraintType("UNIQUE INDEX"); }
                            | { alterExp.setConstraintType("UNIQUE"); } )
                            sk3=RelObjectName() {
                              alterExp.setConstraintSymbol(sk3);
                              index = new Index();
                            }
                            columnNames=ColumnsNamesList() {
                              index.setColumnsNames(columnNames);
                              alterExp.setIndex(index);
                            }
                        )
                        |
                        sk3=RelObjectName()
                        (
                             ( tk=<K_FOREIGN> tk2=<K_KEY>
                                columnNames=ColumnsNamesList()
                                {
                                    fkIndex = new ForeignKeyIndex()
                                    .withName(sk3)
                                    .withType(tk.image + " " + tk2.image)
                                    .withColumnsNames(columnNames);
                                                        columnNames = null;
                                }
                                <K_REFERENCES> fkTable=Table() [ LOOKAHEAD(2) columnNames=ColumnsNamesList() ]
                                {
                                    fkIndex.withTable(fkTable).withReferencedColumnNames(columnNames);
                                    alterExp.setIndex(fkIndex);
                                }

                                [LOOKAHEAD(2) (<K_ON> (tk=<K_DELETE> | tk=<K_UPDATE>) action = Action()
                                    {  fkIndex.setReferentialAction(ReferentialAction.Type.from(tk.image), action); }
                                )]
                                [LOOKAHEAD(2) (<K_ON> (tk=<K_DELETE> | tk=<K_UPDATE>) action = Action()
                                    { fkIndex.setReferentialAction(ReferentialAction.Type.from(tk.image), action); }
                                )]
                                constraints=AlterExpressionConstraintState() { alterExp.setConstraints(constraints); }
                            )
                            |
                            ( tk=<K_PRIMARY> tk2=<K_KEY>
                                columnNames=ColumnsNamesList()
                                {
                                    index = new NamedConstraint()
                                    .withName(sk3)
                                    .withType(tk.image + " " + tk2.image)
                                    .withColumnsNames(columnNames);
                                    alterExp.setIndex(index);
                                }
                                constraints=AlterExpressionConstraintState() { alterExp.setConstraints(constraints); }
                                [ <K_USING> sk4=RelObjectName() { alterExp.addParameters("USING", sk4); }]
                                [ LOOKAHEAD(2) index = IndexWithComment(index) { alterExp.setIndex(index); } ]
                            )
                            |
                            LOOKAHEAD(2) (
                                { boolean enforced = true; }
                                [ tk = <K_NOT> { enforced = false; } ]
                                <K_ENFORCED> {
                                    alterExp.setEnforced(enforced);
                                    alterExp.setConstraintType("CONSTRAINT");
                                    alterExp.setConstraintSymbol(sk3);
                                }
                            )
                            |
                            (
                                <K_CHECK>  {Expression exp = null;} (LOOKAHEAD(2) "(" exp = Expression() ")")* {
                                    CheckConstraint checkCs = new CheckConstraint().withName(sk3).withExpression(exp);
                                    alterExp.setIndex(checkCs);
                                }
                            )
                            |
                            (
                                tk=<K_UNIQUE> (tk2=<K_KEY> { alterExp.setUk(true); } | tk2=<K_INDEX>)?
                                  columnNames=ColumnsNamesList()
                                  {
                                      index = new NamedConstraint()
                                        .withName(sk3)
                                        .withType(tk.image + (tk2!=null?" " + tk2.image:""))
                                        .withColumnsNames(columnNames);
                                      alterExp.setIndex(index);
                                  }
                                  constraints=AlterExpressionConstraintState() { alterExp.setConstraints(constraints); }
                                  [ <K_USING> sk4=RelObjectName() { alterExp.addParameters("USING", sk4); }]
                                  [ LOOKAHEAD(2) index = IndexWithComment(index) { alterExp.setIndex(index); } ]
                            )
                            |
                            (
                                tk=<K_KEY>
                                columnNames=ColumnsNamesList()
                                {
                                    index = new NamedConstraint()
                                      .withName(sk3)
                                      .withType(tk.image)
                                      .withColumnsNames(columnNames);
                                    alterExp.setIndex(index);
                                }
                                constraints=AlterExpressionConstraintState() { alterExp.setConstraints(constraints); }
                            )
                        )
                    )
                )
            )
      )
      |
      (
        <K_CHANGE> { alterExp.setOperation(AlterOperation.CHANGE); }
        [ <K_COLUMN> { alterExp.hasColumn(true); alterExp.setOptionalSpecifier("COLUMN"); } ]
        (
          (tk=KeywordOrIdentifier())
          alterExpressionColumnDataType = AlterExpressionColumnDataType() {  alterExp.withColumnOldName(tk.image).addColDataType(alterExpressionColumnDataType); }
        )
      )
      |
        <K_DROP> { alterExp.setOperation(AlterOperation.DROP); }
        (
            (
                <K_PARTITION> {
                    alterExp.setOperation(AlterOperation.DROP_PARTITION);
                }
                partitions=PartitionNamesList() {
                    alterExp.setPartitions(partitions);
                }
            )
            |
            (
                (
                    // we use the PK Columns Field instead of the Column Field
                    // for holding multiple DROP Columns
                    columnNames=ColumnsNamesList() { alterExp.setPkColumns(columnNames); columnNames = null; }

                    [ "INVALIDATE" { alterExp.addParameters("INVALIDATE"); } ]

                    [
                        "CASCADE" { alterExp.addParameters("CASCADE"); }
                        [ "CONSTRAINTS" { alterExp.addParameters("CONSTRAINTS"); } ]
                    ]
                )
                |
                (
                    ( LOOKAHEAD(2) <K_COLUMN> { alterExp.hasColumn(true); } )?
                    [<K_IF> <K_EXISTS> { alterExp.setUsingIfExists(true); } ]
                    // @todo: replace with a proper identifier
                    (tk=KeywordOrIdentifier() ) { alterExp.setColumnName(tk.image); }

                    [ "INVALIDATE" { alterExp.addParameters("INVALIDATE"); } ]

                    [
                        "CASCADE" { alterExp.addParameters("CASCADE"); }
                        [ "CONSTRAINTS" { alterExp.addParameters("CONSTRAINTS"); } ]
                    ]
                )
            )
            |
            (
               ( tk=<K_INDEX> | tk=<K_KEY> )
               ( tk2=<S_IDENTIFIER> | tk2=<S_QUOTED_IDENTIFIER> ) {
                   index = new Index().withType(tk.image).withName(tk2.image);
                   alterExp.setIndex(index);
               }
            )
            |
            (
               tk=<K_UNIQUE>  { alterExp.setOperation(AlterOperation.DROP_UNIQUE); }
               columnNames=ColumnsNamesList() { alterExp.setPkColumns(columnNames); columnNames = null; }
               [ ( tk=<K_CASCADE> | tk=<K_RESTRICT> ) { alterExp.addParameters(tk.image); } ]
            )
            |
            (
               tk=<K_PRIMARY> tk2=<K_KEY> { alterExp.setOperation(AlterOperation.DROP_PRIMARY_KEY); }
               [ ( tk=<K_CASCADE> | tk=<K_RESTRICT> ) { alterExp.addParameters(tk.image); } ]
            )
            |
            (
               tk=<K_FOREIGN> tk2=<K_KEY> { alterExp.setOperation(AlterOperation.DROP_FOREIGN_KEY); }
               columnNames=ColumnsNamesList() { alterExp.setPkColumns(columnNames); columnNames = null; }
               [ ( tk=<K_CASCADE> | tk=<K_RESTRICT> ) { alterExp.addParameters(tk.image); } ]
            )
            |
            (
                <K_CONSTRAINT> [<K_IF> <K_EXISTS> { alterExp.setUsingIfExists(true); } ]
                ( tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER>) { alterExp.setConstraintName(tk.image); }
                [ ( tk=<K_CASCADE> | tk=<K_RESTRICT> ) { alterExp.addParameters(tk.image); } ]
            )
        )
        |
        LOOKAHEAD(5) (
            <K_FORCE> <K_ROW> <K_LEVEL> <K_SECURITY> {
                alterExp.setOperation(AlterOperation.FORCE_ROW_LEVEL_SECURITY);
            }
        )
        |
        LOOKAHEAD(5) (
            <K_NO> <K_FORCE> <K_ROW> <K_LEVEL> <K_SECURITY> {
                alterExp.setOperation(AlterOperation.NO_FORCE_ROW_LEVEL_SECURITY);
            }
        )
        |
        LOOKAHEAD(1) (
        <K_FORCE>{ alterExp.setOperation(AlterOperation.FORCE); }
        )
        |
        (
         <K_ALGORITHM> {
            alterExp.setOperation(AlterOperation.ALGORITHM);
         }
         ["=" { alterExp.setUseEqual(true);} ]
         sk3 = RelObjectName() {alterExp.setAlgorithmOption(sk3); }
        )
        |
        (
        <K_KEY_BLOCK_SIZE>{
            alterExp.setOperation(AlterOperation.KEY_BLOCK_SIZE);
        }
         ["=" { alterExp.setUseEqual(true);} ]
         tk=<S_LONG> { alterExp.setKeyBlockSize(Integer.parseInt(tk.image)); }
        )
        |
        (
        <K_LOCK> {
            alterExp.setOperation(AlterOperation.LOCK);
        }
        ["=" { alterExp.setUseEqual(true);} ]
        sk3 = RelObjectName() {alterExp.setLockOption(sk3); }
        )
        |
        (<K_ENGINE> {alterExp.setOperation(AlterOperation.ENGINE);}
        ["=" { alterExp.setUseEqual(true);} ]
        sk3 = RelObjectName() {alterExp.setEngineOption(sk3); }
        )
      |
      LOOKAHEAD(2)  <K_RENAME> { alterExp.setOperation(AlterOperation.RENAME); } [ <K_COLUMN> {  alterExp.hasColumn(true);} ]
                    ( tk=KeywordOrIdentifier() ) { alterExp.setColOldName(tk.image); }
                    <K_TO>
                    ( tk2=KeywordOrIdentifier() ) { alterExp.setColumnName(tk2.image); }
      |
      LOOKAHEAD(2)(
        <K_RENAME> <K_TO> {alterExp.setOperation(AlterOperation.RENAME_TABLE);}
        (tk2=<S_IDENTIFIER> | tk2=<S_QUOTED_IDENTIFIER>) { alterExp.setNewTableName(tk2.image);}
      )
      | (<K_CONVERT> {
          alterExp.setOperation(AlterOperation.CONVERT);
          alterExp.setConvertType(AlterExpression.ConvertType.CONVERT_TO);
        }
        <K_TO> <K_CHARACTER> <K_SET> tk=<S_IDENTIFIER> { alterExp.setCharacterSet(tk.image); }
        [<K_COLLATE> tk2=<S_IDENTIFIER> { alterExp.setCollation(tk2.image); }]
      )
      |
      LOOKAHEAD(3)
      (
          <K_DEFAULT>
          (
              <K_CHARACTER> <K_SET> [ "=" { alterExp.setHasEqualForCharacterSet(true); } ]
              tk=<S_IDENTIFIER> {
                  alterExp.setOperation(AlterOperation.CONVERT);
                  alterExp.setConvertType(AlterExpression.ConvertType.DEFAULT_CHARACTER_SET);
                  alterExp.setCharacterSet(tk.image);
              }
              [<K_COLLATE> [ "=" { alterExp.setHasEqualForCollate(true); } ]
                  tk2=<S_IDENTIFIER> { alterExp.setCollation(tk2.image); }]
          |
              <K_COLLATE>
              [ "=" { alterExp.setHasEqualForCollate(true); } ]
              tk=<S_IDENTIFIER> {
                  alterExp.setOperation(AlterOperation.COLLATE);
                  alterExp.setCollation(tk.image);
                  alterExp.setDefaultCollateSpecified(true);
              }
          )
      )
      | (<K_CHARACTER> <K_SET> [ "=" { alterExp.setHasEqualForCharacterSet(true); } ]
        tk=<S_IDENTIFIER> {
          alterExp.setOperation(AlterOperation.CONVERT);
          alterExp.setConvertType(AlterExpression.ConvertType.CHARACTER_SET);
          alterExp.setCharacterSet(tk.image);
        }
        [<K_COLLATE> [ "=" { alterExp.setHasEqualForCollate(true); } ]
            tk2=<S_IDENTIFIER> { alterExp.setCollation(tk2.image); }]
      )
      | (<K_COLLATE> { alterExp.setOperation(AlterOperation.COLLATE); }
      [ "=" { alterExp.setHasEqualForCollate(true); } ]
        tk=<S_IDENTIFIER> {
          alterExp.setCollation(tk.image);
        }
      )
      |
      (<K_COMMENT> {alterExp.setOperation(AlterOperation.COMMENT);}
          ["=" {alterExp.setOperation(AlterOperation.COMMENT_WITH_EQUAL_SIGN);} ]
          tk=<S_CHAR_LITERAL> { alterExp.setCommentText(tk.image); }
      )
      |
      (<K_ENCRYPTION> {alterExp.setOperation(AlterOperation.SET_TABLE_OPTION);}
            ["=" { alterExp.setUseEqual(true);} ]
            tk=<S_CHAR_LITERAL> {
                if (alterExp.getUseEqual()) {
                    alterExp.setTableOption("ENCRYPTION = " + tk.image);
                } else {
                    alterExp.setTableOption("ENCRYPTION " + tk.image);
                }
            }
      )
      |
      (
          <K_DISCARD>
          (
              <K_PARTITION>
              {
                  alterExp.setOperation(AlterOperation.DISCARD_PARTITION);
              }
              partitions = PartitionNamesList()
              {
                  alterExp.setPartitions(partitions);
              }
              <K_TABLESPACE>
              {
                  alterExp.setTableOption("TABLESPACE");
              }
              |
              <K_TABLESPACE>
              {
                  alterExp.setOperation(AlterOperation.DISCARD_TABLESPACE);
              }
          )
      )
      |
            (
                <K_IMPORT>
                (
                    <K_PARTITION>
                    {
                        alterExp.setOperation(AlterOperation.IMPORT_PARTITION);
                    }
                    partitions = PartitionNamesList()
                    {
                        alterExp.setPartitions(partitions);
                    }
                    <K_TABLESPACE>
                    {
                        alterExp.setTableOption("TABLESPACE");
                    }
                    |
                    <K_TABLESPACE>
                    {
                        alterExp.setOperation(AlterOperation.IMPORT_TABLESPACE);
                    }
                )
            )
      |

      LOOKAHEAD(4) (
          <K_DISABLE> <K_ROW> <K_LEVEL> <K_SECURITY> {
              alterExp.setOperation(AlterOperation.DISABLE_ROW_LEVEL_SECURITY);
          }
      )
      |
      LOOKAHEAD(2) (
          <K_DISABLE> <K_KEYS> {
              alterExp.setOperation(AlterOperation.DISABLE_KEYS);
          }
      )

      |
      LOOKAHEAD(4) (
          <K_ENABLE> <K_ROW> <K_LEVEL> <K_SECURITY> {
              alterExp.setOperation(AlterOperation.ENABLE_ROW_LEVEL_SECURITY);
          }
      )
      |
      LOOKAHEAD(2) (
          <K_ENABLE> <K_KEYS> {
              alterExp.setOperation(AlterOperation.ENABLE_KEYS);
          }
      )
      |
      (<K_AUTO_INCREMENT> {alterExp.setOperation(AlterOperation.SET_TABLE_OPTION);}
              ["=" { alterExp.setUseEqual(true);} ]
              tk=<S_LONG> {
                  if (alterExp.getUseEqual()) {
                      alterExp.setTableOption("AUTO_INCREMENT = " + tk.image);
                  } else {
                      alterExp.setTableOption("AUTO_INCREMENT " + tk.image);
                  }
            }
      )
      |
        LOOKAHEAD(2) (
            <K_PARTITION> <K_BY> {
                alterExp.setOperation(AlterOperation.PARTITION_BY);
            }
            <K_RANGE> {
                alterExp.setPartitionType("RANGE");
                Expression exp = null;
            }
            (
                "(" exp=Expression() ")" {
                    alterExp.setPartitionExpression(exp);
                }
                |
                <K_COLUMNS> columnNames=ColumnsNamesList() {
                    alterExp.setPartitionColumns(columnNames);
                }
            )
            partitionDefinition=PartitionDefinitions() {
                alterExp.setPartitionDefinitions(partitionDefinition);
            }
        )
      |
      LOOKAHEAD(2)
           (<K_RENAME> ((<K_INDEX> {alterExp.setOperation(AlterOperation.RENAME_INDEX);}
                    | <K_KEY> {alterExp.setOperation(AlterOperation.RENAME_KEY);})
                    | <K_CONSTRAINT> { alterExp.setOperation(AlterOperation.RENAME_CONSTRAINT); }
           )
           (tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER>){
              alterExp.setOldIndex(new Index().withName(tk.image));
           }
           <K_TO>
           (tk2=<S_IDENTIFIER> | tk2=<S_QUOTED_IDENTIFIER>){
              index = new Index().withName(tk2.image);
              alterExp.setIndex(index);
           }
          )
      |
      LOOKAHEAD(2) <K_TRUNCATE> <K_PARTITION> { alterExp.setOperation(AlterOperation.TRUNCATE_PARTITION); }
       partitions=PartitionNamesList() {
           alterExp.setPartitions(partitions);
       }
      |
      LOOKAHEAD(2) <K_COALESCE> <K_PARTITION> tk=<S_LONG> {
            alterExp.setOperation(AlterOperation.COALESCE_PARTITION);
            alterExp.setCoalescePartitionNumber(Integer.valueOf(tk.image));
      }
      | LOOKAHEAD(2) <K_REORGANIZE> <K_PARTITION>
        partitions=PartitionNamesList() <K_INTO> partitionDefinition=PartitionDefinitions() {
          alterExp.setOperation(AlterOperation.REORGANIZE_PARTITION);
          alterExp.setPartitions(partitions);
          alterExp.setPartitionDefinitions(partitionDefinition);
      }
      |
      LOOKAHEAD(2) <K_EXCHANGE> <K_PARTITION> partitions=PartitionNamesList()
        <K_WITH> <K_TABLE> tk=<S_IDENTIFIER>
        [
            LOOKAHEAD(2) (
                <K_WITH> <K_VALIDATION> { alterExp.setExchangePartitionWithValidation(true); }
                |
                <K_WITHOUT> <K_VALIDATION> { alterExp.setExchangePartitionWithoutValidation(false); }
            )
        ]
        {
          alterExp.setOperation(AlterOperation.EXCHANGE_PARTITION);
          alterExp.setPartitions(partitions);
          alterExp.setExchangePartitionTableName(tk.image);
        }
      |
      LOOKAHEAD(2) <K_ANALYZE> <K_PARTITION> {
          alterExp.setOperation(AlterOperation.ANALYZE_PARTITION);
      }
      partitions=PartitionNamesList() {
          alterExp.setPartitions(partitions);
      }
      |
      LOOKAHEAD(2) <K_CHECK> <K_PARTITION> {
          alterExp.setOperation(AlterOperation.CHECK_PARTITION);
      }
      partitions=PartitionNamesList() {
          alterExp.setPartitions(partitions);
      }
      |
      LOOKAHEAD(2) <K_OPTIMIZE> <K_PARTITION> {
          alterExp.setOperation(AlterOperation.OPTIMIZE_PARTITION);
      }
      partitions=PartitionNamesList() {
          alterExp.setPartitions(partitions);
      }
      |
      LOOKAHEAD(2) <K_REBUILD> <K_PARTITION> {
          alterExp.setOperation(AlterOperation.REBUILD_PARTITION);
      }
      partitions=PartitionNamesList() {
          alterExp.setPartitions(partitions);
      }
      |
      LOOKAHEAD(2) <K_REPAIR> <K_PARTITION> { alterExp.setOperation(AlterOperation.REPAIR_PARTITION); }
      partitions=PartitionNamesList() {
          alterExp.setPartitions(partitions);
      }
      |
      LOOKAHEAD(2) <K_REMOVE> <K_PARTITIONING> { alterExp.setOperation(AlterOperation.REMOVE_PARTITIONING); }
      |
      tokens = captureRest() {
                    alterExp.setOperation(AlterOperation.UNSPECIFIC);
                    StringBuilder optionalSpecifier = new StringBuilder();
                    int i=0;

                    for (String s: tokens)
                        if (! (s.equals(";") || s.equals("\n\n\n")) ) {
                            if (i>0)
                                optionalSpecifier.append( " " );
                            optionalSpecifier.append( s );
                            i++;
                        }

                    alterExp.setOptionalSpecifier( optionalSpecifier.toString() );
               }
    )

    {
        return alterExp;
    }
}

Statement Alter():
{
    Statement statement;
    List<String> captureRest;
}
{
    (
        (
            <K_ALTER>
            (
                statement = AlterTable()
                |
                statement = AlterSession()
                |
                statement = AlterView(false)
                |
                statement = AlterSystemStatement()
                |
                statement = AlterSequence()
                |
                captureRest = captureRest()
                {
                    statement = new UnsupportedStatement("ALTER", captureRest);
                }
            )
        )
        |
        (
            <K_REPLACE>
            (
                statement = AlterView(true)
                |
                captureRest = captureRest()
                {
                    statement = new UnsupportedStatement("REPLACE", captureRest);
                }
            )
        )
    )
    {
        return statement;
    }
}

Alter AlterTable():
{
    Alter alter = new Alter();
    Table table;
    AlterExpression alterExp;
    boolean usingIfExists = false;
}
{
    <K_TABLE>
    [ <K_ONLY> { alter.setUseOnly(true); } ]
    [ LOOKAHEAD(2) <K_IF> <K_EXISTS> { alter.setUseTableIfExists(true); } ]
    table=Table() { alter.setTable(table); }

    alterExp=AlterExpression() { alter.addAlterExpression(alterExp); }

    ("," alterExp=AlterExpression() { alter.addAlterExpression(alterExp); } )*

    {
        return alter;
    }
}

AlterSession AlterSession():
{
    AlterSessionOperation operation = null;
    List<String> parameters = new ArrayList<String>();
    Token token;
}
{
    <K_SESSION> (
        (
           <K_ADVISE>   ( <K_COMMIT> { operation = AlterSessionOperation.ADVISE_COMMIT; }
                        | <K_ROLLBACK> { operation = AlterSessionOperation.ADVISE_ROLLBACK; }
                        | <K_NOTHING> { operation = AlterSessionOperation.ADVISE_NOTHING; }
                        )
        )
        |
        (
            <K_CLOSE> <K_DATABASE> <K_LINK> { operation = AlterSessionOperation.CLOSE_DATABASE_LINK; }
        )
        |
        (
            <K_ENABLE>  ( <K_COMMIT> <K_IN> <K_PROCEDURE> { operation = AlterSessionOperation.ENABLE_COMMIT_IN_PROCEDURE; }
                        | <K_GUARD> { operation = AlterSessionOperation.ENABLE_GUARD; }
                        | <K_PARALLEL> ( <K_DML> { operation = AlterSessionOperation.ENABLE_PARALLEL_DML; }
                                       | <K_DDL> { operation = AlterSessionOperation.ENABLE_PARALLEL_DDL; }
                                       | <K_QUERY> { operation = AlterSessionOperation.ENABLE_PARALLEL_QUERY; }
                                       )
                        | <K_RESUMABLE> { operation = AlterSessionOperation.ENABLE_RESUMABLE; }
                        )
        )
        |
        (
            <K_DISABLE> ( <K_COMMIT> <K_IN> <K_PROCEDURE> { operation = AlterSessionOperation.DISABLE_COMMIT_IN_PROCEDURE; }
                        | <K_GUARD> { operation = AlterSessionOperation.DISABLE_GUARD; }
                        | <K_PARALLEL> ( <K_DML> { operation = AlterSessionOperation.DISABLE_PARALLEL_DML; }
                                        | <K_DDL> { operation = AlterSessionOperation.DISABLE_PARALLEL_DDL; }
                                        | <K_QUERY> { operation = AlterSessionOperation.DISABLE_PARALLEL_QUERY; }
                                        )
                        | <K_RESUMABLE> { operation = AlterSessionOperation.DISABLE_RESUMABLE; }
                        )
        )
        |
        (
            <K_FORCE> <K_PARALLEL> ( <K_DML> { operation = AlterSessionOperation.FORCE_PARALLEL_DML; }
                                   | <K_DDL> { operation = AlterSessionOperation.FORCE_PARALLEL_DDL; }
                                   | <K_QUERY> { operation = AlterSessionOperation.FORCE_PARALLEL_QUERY; }
                                   )
        )
        |
        (
            <K_SET> { operation = AlterSessionOperation.SET; }
        )
    )

    (   ( token = <S_CHAR_LITERAL>
            | token = <S_IDENTIFIER>
            | token = "="
            | token = <S_LONG>
            | token = <K_PARALLEL>
            ) { parameters.add( token.image ); }
    )*


    {
        return new AlterSession(operation, parameters);
    }
}

AlterSystemStatement AlterSystemStatement():
{
    AlterSystemOperation operation = null;
    List<String> parameters = new LinkedList<String>();
}
{
    <K_SYSTEM> (
        (
           <K_ARCHIVE> <K_LOG> { operation = AlterSystemOperation.ARCHIVE_LOG; }
        )
        |
        (
            <K_CHECKPOINT> { operation = AlterSystemOperation.CHECKPOINT; }
        )
        |
        (
            <K_DUMP> <K_ACTIVE> <K_SESSION> <K_HISTORY> { operation = AlterSystemOperation.DUMP_ACTIVE_SESSION_HISTORY; }
        )
        |
        (
            <K_ENABLE>  (
                            "DISTRIBUTED" "RECOVERY" { operation = AlterSystemOperation.ENABLE_DISTRIBUTED_RECOVERY; }
                            | <K_RESTRICTED> <K_SESSION> { operation = AlterSystemOperation.ENABLE_DISTRIBUTED_RECOVERY; }
                        )
        )
        |
        (
            <K_DISABLE> (
                            "DISTRIBUTED" "RECOVERY" { operation = AlterSystemOperation.DISABLE_DISTRIBUTED_RECOVERY; }
                            | <K_RESTRICTED> <K_SESSION> { operation = AlterSystemOperation.DISABLE_RESTRICTED_SESSION; }
                        )
        )
        |
        (
            <K_FLUSH> { operation = AlterSystemOperation.FLUSH; }
        )
        |
        (
            <K_DISCONNECT> <K_SESSION> { operation = AlterSystemOperation.DISCONNECT_SESSION; }
        )
        |
        (
            <K_KILL> <K_SESSION> { operation = AlterSystemOperation.KILL_SESSION; }
        )
        |
        (
            <K_SWITCH> { operation = AlterSystemOperation.SWITCH; }
        )
        |
        (
            <K_SUSPEND> { operation = AlterSystemOperation.SUSPEND; }
        )
        |
        (
            <K_RESUME> { operation = AlterSystemOperation.RESUME; }
        )
        |
        (
            <K_QUIESCE> <K_RESTRICTED> { operation = AlterSystemOperation.QUIESCE; }
        )
        |
        (
            <K_UNQIESCE> { operation = AlterSystemOperation.UNQUIESCE; }
        )
        |
        (
            <K_SHUTDOWN> { operation = AlterSystemOperation.SHUTDOWN; }
        )
        |
        (
            <K_REGISTER> { operation = AlterSystemOperation.REGISTER; }
        )
        |
        (
            <K_SET> { operation = AlterSystemOperation.SET; }
        )
        |
        (
            <K_RESET> { operation = AlterSystemOperation.RESET; }
        )
    )
    parameters = captureRest()

    {
        return new AlterSystemStatement(operation, parameters);
    }
}

Wait Wait():
{
    Wait wait = new Wait();
    Token token = null;
}
{
    // sqlserver-oracle-> WAIT (TIMEOUT)
    // https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_10002.htm#i2126016
    <K_WAIT> token=<S_LONG>
    {
        wait.setTimeout(Long.parseLong(token.image));
        return wait;
    }
}

SavepointStatement SavepointStatement():
{
  SavepointStatement savepointStatement;
}
{
    <K_SAVEPOINT> token=<S_IDENTIFIER>
    {
        savepointStatement = new SavepointStatement(token.image);
        return savepointStatement;
    }
}

RollbackStatement RollbackStatement():
{
    RollbackStatement rollbackStatement;
    boolean usingWorkKeyword=false;
    boolean usingSavepointKeyword=false;
    String savepointName=null;
    String forceDistributedTransactionIdentifier=null;
}
{
    <K_ROLLBACK> { rollbackStatement = new RollbackStatement(); }
    [ <K_WORK> { rollbackStatement.setUsingWorkKeyword(true); } ]
    [   (
            <K_TO> [ <K_SAVEPOINT> { rollbackStatement.setUsingSavepointKeyword(true); }]
                token=<S_IDENTIFIER> { rollbackStatement.setSavepointName(token.image); }
        )
        |
        (
            <K_FORCE> token=<S_CHAR_LITERAL> { rollbackStatement.setForceDistributedTransactionIdentifier(token.image); }
        ) ]

    {
        return rollbackStatement;
    }
}

Commit Commit():
{
  Commit commit=new Commit();
}
{
  <K_COMMIT>
  {
    return commit;
  }
}

Comment Comment():
{
    Comment result = new Comment();
    Table table;
    Table view;
    Column column;
    Token comment;
}
{
    <K_COMMENT> <K_ON>
    (
        (
            <K_TABLE> table = Table() { result.setTable(table); }
        )
        |
        (
            <K_COLUMN> column = Column() { result.setColumn(column); }
        )
        |
        (
            <K_VIEW> view = Table() { result.setView(view); }
        )
    )
    <K_IS> comment=<S_CHAR_LITERAL>
    {
        result.setComment(new StringValue(comment.image));
        return result;
    }
}

Grant Grant():
{
	Grant grant = new Grant();
	ArrayList<String> privileges = new ArrayList<String>();
	List<String> users;
	Token tk = null;
    ObjectNames objName;
}
{
	<K_GRANT>
	(
	    (
            [readGrantTypes(privileges) (<K_COMMA> readGrantTypes(privileges))*]
            <K_ON> objName=RelObjectNames()   { grant.setObjectName(objName.getNames()); }
        )
        |
        (
            tk=<S_IDENTIFIER> { grant.setRole(tk.image); }
        )
    )
	<K_TO> users = UsersList()
	{
        grant.setUsers(users);
        if(privileges.size() > 0) {
            grant.setPrivileges(privileges);
        }
	    return grant;
    }
}

List<String> UsersList():
{
    List<String> users = new ArrayList<String>();
    String user = null;
}
{
         user=RelObjectNameExt() { users.add(user); }
         ( "," user=ColumnsNamesListItem() { users.add(user); } )*
    {
        return users;
    }
}

void readGrantTypes(ArrayList<String> privileges):
{
}
{
    <K_SELECT> {privileges.add("SELECT");} |
    <K_INSERT> {privileges.add("INSERT");} |
    <K_UPDATE> {privileges.add("UPDATE");} |
    <K_DELETE> {privileges.add("DELETE");} |
    <K_EXECUTE> {privileges.add("EXECUTE");} |
    <K_ALTER> {privileges.add("ALTER");} |
    <K_DROP> {privileges.add("DROP");}
}

Sequence Sequence() #Sequence :
{
    ObjectNames data = null;
    String serverName = null, databaseName = null, schemaName = null, sequenceName = null;
}
{
    data = RelObjectNames()
    {
        Sequence sequence = new Sequence(data.getNames());
		linkAST(sequence,jjtThis);
        return sequence;
    }
}

List<Sequence.Parameter> SequenceParameters():
{
  List<Sequence.Parameter> sequenceParameters = new ArrayList<Sequence.Parameter>();
  Sequence.Parameter parameter = null;
  Token token = null;
  Token byToken = null;
  Token withToken = null;
}
{
    (
        LOOKAHEAD(2) (
            (
                <K_INCREMENT> [ byToken=<K_BY> ] token=<S_LONG>
                {
                    if (byToken != null) {
                      parameter = new Sequence.Parameter(Sequence.ParameterType.INCREMENT_BY);
                    } else {
                      parameter = new Sequence.Parameter(Sequence.ParameterType.INCREMENT);
                    }
                    parameter.setValue(Long.parseLong(token.image));
                    sequenceParameters.add(parameter);
                }
           )
           |
           (
                <K_START> [ withToken=<K_WITH> ] token=<S_LONG>
                {
                    if (withToken != null) {
                        parameter = new Sequence.Parameter(Sequence.ParameterType.START_WITH);
                    } else {
                        parameter = new Sequence.Parameter(Sequence.ParameterType.START);
                    }
                    parameter.setValue(Long.parseLong(token.image));
                    sequenceParameters.add(parameter);
                }
            )
            |
            (
                <K_RESTART> [ LOOKAHEAD(2) <K_WITH> token=<S_LONG>]
                {
                    parameter = new Sequence.Parameter(Sequence.ParameterType.RESTART_WITH);
                    if(token != null) {
                        parameter.setValue(Long.parseLong(token.image));
                    }
                    sequenceParameters.add(parameter);
                }
            )
            |
            <K_NOMAXVALUE>
            {
              parameter = new Sequence.Parameter(Sequence.ParameterType.NOMAXVALUE);
              sequenceParameters.add(parameter);
            }
            |
            <K_MAXVALUE> token=<S_LONG>
            {
              parameter = new Sequence.Parameter(Sequence.ParameterType.MAXVALUE);
              parameter.setValue(Long.parseLong(token.image));
              sequenceParameters.add(parameter);
            }
            |
            <K_NOMINVALUE>
            {
              parameter = new Sequence.Parameter(Sequence.ParameterType.NOMINVALUE);
              sequenceParameters.add(parameter);
            }
            |
            <K_MINVALUE> token=<S_LONG>
            {
              parameter = new Sequence.Parameter(Sequence.ParameterType.MINVALUE);
              parameter.setValue(Long.parseLong(token.image));
              sequenceParameters.add(parameter);
            }
            |
            <K_NOCYCLE> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.NOCYCLE)); }
            |
            <K_CYCLE> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.CYCLE)); }
            |
            <K_NOCACHE>
            {
              parameter = new Sequence.Parameter(Sequence.ParameterType.NOCACHE);
              sequenceParameters.add(parameter);
            }
            |
            <K_CACHE> token=<S_LONG>
            {
              parameter = new Sequence.Parameter(Sequence.ParameterType.CACHE);
              parameter.setValue(Long.parseLong(token.image));
              sequenceParameters.add(parameter);
            }
            |
            <K_ORDER> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.ORDER)); }
            |
            <K_NOORDER> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.NOORDER)); }
            |
            <K_KEEP> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.KEEP)); }
            |
            <K_NOKEEP> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.NOKEEP)); }
            |
            <K_SESSION> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.SESSION)); }
            |
            <K_GLOBAL> { sequenceParameters.add(new Sequence.Parameter(Sequence.ParameterType.GLOBAL)); }
        )
    )*
    {
        return sequenceParameters;
    }
}

CreateSequence CreateSequence():
{
  CreateSequence createSequence = new CreateSequence();
  Sequence sequence;
  List<Sequence.Parameter> sequenceParameters;
}
{
  <K_SEQUENCE> sequence=Sequence() { createSequence.setSequence(sequence); }
  sequenceParameters = SequenceParameters()
    {
        sequence.setParameters(sequenceParameters);
        return createSequence;
    }
}

AlterSequence AlterSequence():
{
  AlterSequence alterSequence = new AlterSequence();
  Sequence sequence;
  List<Sequence.Parameter> sequenceParameters;
}
{
    <K_SEQUENCE> sequence=Sequence() { alterSequence.setSequence(sequence); }
    sequenceParameters = SequenceParameters()
    {
        sequence.setParameters(sequenceParameters);
        return alterSequence;
    }
}

Statement Create():
{
    boolean isUsingOrReplace=false;
    Token tk;
    Statement statement;
    List<String> captureRest;
}
{
    <K_CREATE> [ <K_OR> <K_REPLACE> { isUsingOrReplace = true; } ]
    (
        statement = CreateFunctionStatement(isUsingOrReplace)
        |
        statement = CreateSchema()
        |
        statement = CreateSequence()
        |
        statement = CreateSynonym(isUsingOrReplace)
        |
        LOOKAHEAD(3) statement = CreateTable(isUsingOrReplace)
        |
        LOOKAHEAD(2) statement = CreateView(isUsingOrReplace)
        |
        statement = CreatePolicy()
        |
        // @fixme: must appear with TRIGGER before INDEX or it will collide with INDEX's CreateParameter() production
        ( tk=<K_TRIGGER> | tk=<K_DOMAIN> ) captureRest = captureRest()
        {
            statement = new UnsupportedStatement("CREATE " + tk.image, captureRest);
        }
        |
        /* @fixme
         *  Create Index uses CreateParameter() which allows all kind of tokens
         *  it can conflict with other statements and must be at the end right now
         */
        statement = CreateIndex()
        |
        captureRest = captureRest()
        {
            statement = new UnsupportedStatement("CREATE", captureRest);
        }
    )
    {
        return statement;
    }
}

CreateFunctionalStatement CreateFunctionStatement(boolean isUsingOrReplace):
{
  CreateFunctionalStatement type = null;
  List<String> tokens = new LinkedList<String>();
  String statementType = null;
}
{
  (
   <K_FUNCTION> { statementType = "FUNCTION"; }
   |
   <K_PROCEDURE> { statementType = "PROCEDURE"; }
  )
  tokens=captureFunctionBody()
  {
    if(statementType.equals("FUNCTION")) {
      type = new CreateFunction(isUsingOrReplace, tokens);
    }
    if(statementType.equals("PROCEDURE")) {
      type = new CreateProcedure(isUsingOrReplace, tokens);
    }

    return type;
  }
}

CreateSynonym CreateSynonym(boolean isUsingOrReplace):
{
  CreateSynonym createSynonym = new CreateSynonym();
  Synonym synonym;
  boolean publicSynonym = false;
  ObjectNames data = null;
}
{
  [<K_PUBLIC> { publicSynonym = true; } ]
  <K_SYNONYM> synonym=Synonym() { createSynonym.setSynonym(synonym); }
  <K_FOR> data = RelObjectNames()
  {
    createSynonym.setOrReplace(isUsingOrReplace);
    createSynonym.setPublicSynonym(publicSynonym);
    createSynonym.setForList(data.getNames());
    return createSynonym;
  }
}

Synonym Synonym() #Synonym :
{
    ObjectNames data = null;
    String serverName = null, databaseName = null, schemaName = null, sequenceName = null;
}
{
    data = RelObjectNames()
    {
        Synonym synonym = new Synonym(data.getNames());
		linkAST(synonym,jjtThis);
        return synonym;
    }
}

CreatePolicy CreatePolicy() #CreatePolicy:
{
    CreatePolicy createPolicy = new CreatePolicy();
    String policyName;
    Table table;
    Token commandToken = null;
    String roleName;
    Expression usingExpr = null;
    Expression checkExpr = null;
}
{
    <K_POLICY> policyName=RelObjectName() { createPolicy.setPolicyName(policyName); }
    <K_ON> table=Table() { createPolicy.setTable(table); }

    [ <K_FOR>
      ( commandToken=<K_ALL>
      | commandToken=<K_SELECT>
      | commandToken=<K_INSERT>
      | commandToken=<K_UPDATE>
      | commandToken=<K_DELETE>
      )
      { createPolicy.setCommand(commandToken.image); }
    ]

    [ <K_TO>
      roleName=RelObjectName() { createPolicy.addRole(roleName); }
      ( "," roleName=RelObjectName() { createPolicy.addRole(roleName); } )*
    ]

    [ <K_USING> "(" usingExpr=Expression() ")" { createPolicy.setUsingExpression(usingExpr); } ]

    [ LOOKAHEAD(2) <K_WITH> <K_CHECK> "(" checkExpr=Expression() ")" { createPolicy.setWithCheckExpression(checkExpr); } ]

    {
        
        return createPolicy;
    }
}

UnsupportedStatement UnsupportedStatement():
{
  List<String> tokens = new LinkedList<String>();
}
{
  tokens=captureUnsupportedStatementDeclaration()
  {
    return new UnsupportedStatement(tokens);
  }
}

JAVACODE
List<String> captureRest() {
  List<String> tokens = new LinkedList<String>();
  Token tok;
  while(true) {
    tok = getToken(1);
    int l = tokens.size();
    if( tok.kind == EOF || tok.kind == ST_SEMICOLON ) {
      break;
    } else if ( l>0 && ( tok.image.equals(".") ||  tokens.get(l-1).endsWith(".")) ) {
        tokens.set(l-1, tokens.get(l-1) + tok.image);
    } else {
        tokens.add(tok.image);
    }
    tok = getNextToken();
  }
  return tokens;
}

/**
* Reads the tokens of a function or procedure body.
* A function body can end in 2 ways:
* 1) BEGIN...END;
* 2) Postgres: $$...$$...;
*/

JAVACODE
List<String> captureFunctionBody() {
  List<String> tokens = new LinkedList<String>();
  Token tok;
  boolean foundEnd = false;
  while(true) {
    tok = getToken(1);
    int l = tokens.size();
    if( tok.kind == EOF || ( foundEnd && tok.kind == ST_SEMICOLON) ) {
      if (tok.kind == ST_SEMICOLON) {
        tokens.add(tok.image);
      }
      break;
    } else if ( l>0 && ( tok.image.equals(".") ||  tokens.get(l-1).endsWith(".")) ) {
        tokens.set(l-1, tokens.get(l-1) + tok.image);
    } else {
        tokens.add(tok.image);
    }
    foundEnd |= (tok.kind == K_END)
        || ( tok.image.trim().startsWith("$$") && tok.image.trim().endsWith("$$")) ;

    tok = getNextToken();
  }
  return tokens;
}

/**
* Reads the tokens of a Postgres dollar quoted string,
  rebuilding the white space of the text based on each token's position and length
    1) $$...$$
    2) $tag$...$tag$
*/

JAVACODE
String getQuotedString(String closingQuote, String escapeChar) {
    StringBuilder buffer = new StringBuilder();
    Deque<Character> windowQueue = new ArrayDeque<Character>();
    int delimiterLength = closingQuote.length();

    Token prevToken = null;
    Token token;

    while (true) {
        token = getNextToken();
        if (token.kind == 0) {
            throw new ParseException("Unterminated quoted string");
        }
        appendWhitespaceFromTokenGap(buffer, prevToken, token);
        appendTokenImageAndTrackDelimiter(buffer, windowQueue, delimiterLength, token.image, closingQuote);
        if (endsWithDelimiter(windowQueue, closingQuote)) {
            buffer.setLength(buffer.length() - delimiterLength);
            return buffer.toString();
        }
        prevToken = token;
    }
}

JAVACODE
String getQuotedIdentifier(String openingQuote, String closingQuote, String escapeChar) {
    return openingQuote + getQuotedString(closingQuote, escapeChar) + closingQuote;
}


JAVACODE
List<String> captureUnsupportedStatementDeclaration() {
  List<String> tokens = new LinkedList<String>();
  Token tok;

  while(true) {
    tok = getToken(1);
    if( tok.kind == EOF || tok.kind== ST_SEMICOLON || tok.kind== K_END ) {
      break;
    }
    tokens.add(tok.image);
    tok = getNextToken();
  }
  return tokens;
}

String IdentifierChain():
{
    String identifierChain;
    String part;
}
{
    identifierChain=RelObjectNameExt2()
    ( LOOKAHEAD(2) "." part=RelObjectNameExt2() { identifierChain += "." + part; }  )*

    {
        return identifierChain;
    }
}

String IdentifierChain2(String identifierChain):
{
    String part;
}
{
    ( LOOKAHEAD(2) "." part=RelObjectNameExt2() { identifierChain += "." + part; }  )*
    {
        return identifierChain;
    }
}

Expression CharacterPrimary():
{
    Expression expression;
}
{
    (
        expression = TranscodingFunction()
        |
        expression = TrimFunction()
    )
    // @todo
    // @see https://manticore-projects.com/SQL2016Parser/syntax.html#character-value-function
    //  | character_substring_function
    //  | regular_expression_substring_function
    //  | regex_substring_function
    //  | fold
    //  | character_transliteration
    //  | regex_transliteration
    //  | character_overlay_function
    //  | normalize_function
    //  | specific_type_method

    {
        return expression;
    }
}

TranscodingFunction TranscodingFunction() #TranscodingFunction :
{
    Token keywordToken;
    TranscodingFunction transcodingFunction;
    ColDataType colDataType;
    Expression expression;
    String transcodingName=null;
    Token style;
}
{
    ( keywordToken=<K_TRY_CONVERT> | keywordToken=<K_SAFE_CONVERT> | keywordToken=<K_CONVERT> )
    "("
    (
        LOOKAHEAD(4) colDataType = ColDataType()
        "," expression = Expression()
        [ "," style = <S_LONG> { transcodingName = style.image; } ]

        {
            transcodingFunction = new TranscodingFunction(keywordToken.image, colDataType, expression, transcodingName);
        }
        |
        (
            expression = Expression()
            <K_USING> transcodingName=IdentifierChain()

            {
                transcodingFunction = new TranscodingFunction(expression, transcodingName);
            }
        )
    )
    ")"
    {
        return transcodingFunction;
    }
}

TrimFunction TrimFunction():
{
    TrimFunction.TrimSpecification trimSpecification=null;
    Expression expression = null;
    boolean usesFrom = false;
    Expression fromExpression = null;
}
{
    <K_TRIM> "("
    [
        LOOKAHEAD(2) (
            <K_LEADING> { trimSpecification = TrimFunction.TrimSpecification.LEADING; }
            |
            <K_TRAILING> { trimSpecification = TrimFunction.TrimSpecification.TRAILING; }
            |
            <K_BOTH> { trimSpecification = TrimFunction.TrimSpecification.BOTH; }
        )
    ]

    // This is not SQL:2016 compliant, but Postgres supports it
    [ expression = Expression() ]

    [
        (
            ","
            |
            <K_FROM> { usesFrom = true; }
        )
        fromExpression = Expression()
    ]
    ")"

    {
        return new TrimFunction(trimSpecification, expression, fromExpression, usesFrom);
    }
}

void SnowflakeTimeTravelAt(StringBuilder builder):
{
    Expression expression;
    Token tk;
}
{
    // AT( { TIMESTAMP => <timestamp> | OFFSET => <time_difference> | STATEMENT => <id> | STREAM => '<name>' } )

    <K_AT> <OPENING_BRACKET> { builder.append("AT ("); }
    (
        //@fixme: this should be TIMESTAMP only but JavaCC-8 has issues with compound tokens!
        <K_DATETIMELITERAL> "=>" expression = Expression()
        { builder.append( "TIMESTAMP => ").append(expression.toString()); }
        |
        <K_OFFSET> "=>" expression = Expression()
        { builder.append( "OFFSET => ").append(expression.toString()); }
        |
        <K_STATEMENT> "=>" ( tk=<S_CHAR_LITERAL>| tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> )
        { builder.append( "STATEMENT => ").append(tk.image); }
        |
        <K_STREAM> "=>" tk=<S_CHAR_LITERAL>
        { builder.append( "STREAM => ").append(tk.image); }
    )
    <CLOSING_BRACKET> { builder.append(")"); }
}


void SnowflakeTimeTravelBefore(StringBuilder builder):
{
    Expression expression;
    Token tk;
}
{
    // BEFORE( STATEMENT => <id> )

    <K_BEFORE> <OPENING_BRACKET> { builder.append("BEFORE ("); }
    <K_STATEMENT> "=>" ( tk=<S_CHAR_LITERAL>| tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> )
    { builder.append( "STATEMENT => ").append(tk.image); }
    <CLOSING_BRACKET> { builder.append(")"); }
}

void SnowflakeTimeTravelChange(StringBuilder builder):
{
    Expression expression;
    Token tk;
}
{
    /*
    CHANGES ( INFORMATION => { DEFAULT | APPEND_ONLY } )
       AT ( { TIMESTAMP => <timestamp> | OFFSET => <time_difference> | STATEMENT => <id> | STREAM => '<name>' } )
       |
       BEFORE ( STATEMENT => <id> )
       [ END( { TIMESTAMP => <timestamp> | OFFSET => <time_difference> | STATEMENT => <id> } ) ]
     */

     <K_CHANGES> <OPENING_BRACKET> <K_INFORMATION> "=>"
     { builder.append("CHANGES (INFORMATION => ");}

     ( tk = <K_DEFAULT> | tk=<K_APPEND_ONLY>)
     { builder.append(tk.image); }

     <CLOSING_BRACKET> { builder.append(") "); }

     (
         SnowflakeTimeTravelAt(builder)
         |
         SnowflakeTimeTravelBefore(builder)
     )

     [
        LOOKAHEAD(2) <K_END> <OPENING_BRACKET>
        { builder.append(" END ("); }

        (
            //@fixme: this should be TIMESTAMP only but JavaCC-8 has issues with compound tokens!
            <K_DATETIMELITERAL> "=>" expression = Expression()
            { builder.append( "TIMESTAMP => ").append(expression.toString()); }
            |
            <K_OFFSET> "=>" expression = Expression()
            { builder.append( "OFFSET => ").append(expression.toString()); }
            |
            <K_STATEMENT> "=>" ( tk=<S_CHAR_LITERAL>| tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> )
            { builder.append( "STATEMENT => ").append(tk.image); }
        )

        <CLOSING_BRACKET> { builder.append(")"); }
     ]
}

void DataBricksTemporalSpec(StringBuilder builder):
{
    Token tk;
    Expression expression;
}
{
    /*
    temporal_spec https://docs.databricks.com/aws/en/sql/language-manual/sql-ref-names#syntax-3
    {
      @ timestamp_encoding |
      @V version |
      [ FOR ] { SYSTEM_TIMESTAMP | TIMESTAMP } AS OF timestamp_expression |
      [ FOR ] { SYSTEM_VERSION | VERSION } AS OF version
    }
     */
    (tk=<K_AT_SIGN> | tk=<K_AT_V>)  { builder.append(tk.image).append(" "); }
    (tk=<S_CHAR_LITERAL> | tk=<S_LONG>) { builder.append(tk.image); }
    |
    [ <K_FOR> { builder.append(" FOR"); } ]

    ( tk=<K_SYSTEM_TIMESTAMP> | tk=<K_DATETIMELITERAL> )
    <K_AS> <K_OF> expression=Expression()
    { builder.append(" ").append(tk.image).append(" AS OF ").append(expression.toString()); }
    |
    (
        ( tk=<K_SYSTEM_VERSION> | tk= <K_VERSION>) { builder.append(" ").append(tk.image); }
        <K_AS> <K_OF> (tk=<S_LONG> | tk=<S_CHAR_LITERAL> ) { builder.append(" AS OF ").append(tk.image); }
    )
}

void BigQueryHistoricalVersion(StringBuilder builder):
{
    Token tk;
    Expression expression;
}
{
    /*
    FOR SYSTEM_TIME AS OF timestamp_expression
     */
    <K_FOR> <K_SYSTEM_TIME> <K_AS> <K_OF> expression=Expression()
    { builder.append(" FOR SYSTEM_TIME AS OF ").append(expression.toString()); }
}

String TimeTravelBeforeAlias():
{
    StringBuilder builder = new StringBuilder();
}
{
    (
        SnowflakeTimeTravelAt(builder)
        |
        SnowflakeTimeTravelBefore(builder)
        |
        SnowflakeTimeTravelChange(builder)
        |
        DataBricksTemporalSpec(builder)
    )

    {
        return builder.toString();
    }
}

String TimeTravelAfterAlias():
{
    StringBuilder builder = new StringBuilder();
}
{
    BigQueryHistoricalVersion(builder)
    {
        return builder.toString();
    }
}
