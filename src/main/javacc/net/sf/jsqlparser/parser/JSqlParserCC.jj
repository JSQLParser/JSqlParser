/*
 * #%L
 * JSQLParser library
 * %%
 * Copyright (C) 2004 - 2013 JSQLParser
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as 
 * published by the Free Software Foundation, either version 2.1 of the 
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public 
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-2.1.html>.
 * #L%
 */
 
options{
    IGNORE_CASE=true ;
    STATIC=false;
//	DEBUG_PARSER=true;
//  DEBUG_LOOKAHEAD=true ;
//  FORCE_LA_CHECK=true;
//  DEBUG_TOKEN_MANAGER=true;
    UNICODE_INPUT=true;
}

PARSER_BEGIN(CCJSqlParser)
/*
 * #%L
 * JSQLParser library
 * %%
 * Copyright (C) 2004 - 2013 JSQLParser
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as 
 * published by the Free Software Foundation, either version 2.1 of the 
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public 
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-2.1.html>.
 * #L%
 */


package net.sf.jsqlparser.parser;

import java.util.ArrayList;
import java.util.List;

import net.sf.jsqlparser.expression.BinaryExpression;
import net.sf.jsqlparser.expression.DoubleValue;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.Function;
import net.sf.jsqlparser.expression.InverseExpression;
import net.sf.jsqlparser.expression.IntervalExpression;
import net.sf.jsqlparser.expression.JdbcParameter;
import net.sf.jsqlparser.expression.LongValue;
import net.sf.jsqlparser.expression.DateValue;
import net.sf.jsqlparser.expression.TimeValue;
import net.sf.jsqlparser.expression.TimestampValue;
import net.sf.jsqlparser.expression.NullValue;
import net.sf.jsqlparser.expression.Parenthesis;
import net.sf.jsqlparser.expression.StringValue;
import net.sf.jsqlparser.expression.CaseExpression;
import net.sf.jsqlparser.expression.CastExpression;
import net.sf.jsqlparser.expression.AnalyticExpression;
import net.sf.jsqlparser.expression.ExtractExpression;
import net.sf.jsqlparser.expression.WhenClause;
import net.sf.jsqlparser.expression.AnyComparisonExpression;
import net.sf.jsqlparser.expression.AllComparisonExpression;
import net.sf.jsqlparser.expression.operators.arithmetic.Addition;
import net.sf.jsqlparser.expression.operators.arithmetic.BitwiseAnd;
import net.sf.jsqlparser.expression.operators.arithmetic.BitwiseOr;
import net.sf.jsqlparser.expression.operators.arithmetic.BitwiseXor;
import net.sf.jsqlparser.expression.operators.arithmetic.Concat;
import net.sf.jsqlparser.expression.operators.arithmetic.Division;
import net.sf.jsqlparser.expression.operators.arithmetic.Multiplication;
import net.sf.jsqlparser.expression.operators.arithmetic.Modulo;
import net.sf.jsqlparser.expression.operators.arithmetic.Subtraction;
import net.sf.jsqlparser.expression.operators.conditional.AndExpression;
import net.sf.jsqlparser.expression.operators.conditional.OrExpression;
import net.sf.jsqlparser.expression.operators.relational.Between;
import net.sf.jsqlparser.expression.operators.relational.EqualsTo;
import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
import net.sf.jsqlparser.expression.operators.relational.GreaterThan;
import net.sf.jsqlparser.expression.operators.relational.GreaterThanEquals;
import net.sf.jsqlparser.expression.operators.relational.InExpression;
import net.sf.jsqlparser.expression.operators.relational.IsNullExpression;
import net.sf.jsqlparser.expression.operators.relational.ItemsList;
import net.sf.jsqlparser.expression.operators.relational.LikeExpression;
import net.sf.jsqlparser.expression.operators.relational.ExistsExpression;
import net.sf.jsqlparser.expression.operators.relational.Matches;
import net.sf.jsqlparser.expression.operators.relational.MinorThan;
import net.sf.jsqlparser.expression.operators.relational.MinorThanEquals;
import net.sf.jsqlparser.expression.operators.relational.NotEqualsTo;
import net.sf.jsqlparser.expression.operators.relational.MultiExpressionList;
import net.sf.jsqlparser.expression.operators.relational.SupportsOldOracleJoinSyntax;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.create.index.CreateIndex;
import net.sf.jsqlparser.statement.create.table.ColDataType;
import net.sf.jsqlparser.statement.create.table.ColumnDefinition;
import net.sf.jsqlparser.statement.create.table.CreateTable;
import net.sf.jsqlparser.statement.create.view.CreateView;
import net.sf.jsqlparser.statement.create.table.Index;
import net.sf.jsqlparser.statement.create.table.ForeignKeyIndex;
import net.sf.jsqlparser.statement.delete.Delete;
import net.sf.jsqlparser.statement.drop.Drop;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.replace.Replace;
import net.sf.jsqlparser.statement.select.AllColumns;
import net.sf.jsqlparser.statement.select.AllTableColumns;
import net.sf.jsqlparser.statement.select.Distinct;
import net.sf.jsqlparser.statement.select.FromItem;
import net.sf.jsqlparser.statement.select.Join;
import net.sf.jsqlparser.statement.select.SubJoin;
import net.sf.jsqlparser.statement.select.Limit;
import net.sf.jsqlparser.statement.select.OrderByElement;
import net.sf.jsqlparser.statement.select.PlainSelect;
import net.sf.jsqlparser.statement.select.Pivot;
import net.sf.jsqlparser.statement.select.PivotXml;
import net.sf.jsqlparser.statement.select.FunctionItem;
import net.sf.jsqlparser.statement.select.ExpressionListItem;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.select.SelectBody;
import net.sf.jsqlparser.statement.select.SelectExpressionItem;
import net.sf.jsqlparser.statement.select.SelectItem;
import net.sf.jsqlparser.statement.select.SubSelect;
import net.sf.jsqlparser.statement.select.LateralSubSelect;
import net.sf.jsqlparser.statement.select.Top;
import net.sf.jsqlparser.statement.select.SetOperationList;
import net.sf.jsqlparser.statement.select.SetOperation;
import net.sf.jsqlparser.statement.select.UnionOp;
import net.sf.jsqlparser.statement.select.MinusOp;
import net.sf.jsqlparser.statement.select.ExceptOp;
import net.sf.jsqlparser.statement.select.IntersectOp;
import net.sf.jsqlparser.statement.select.WithItem;
import net.sf.jsqlparser.statement.select.ValuesList;
import net.sf.jsqlparser.statement.truncate.Truncate;
import net.sf.jsqlparser.statement.update.Update;

/**
 * The parser generated by JavaCC
 */
public class CCJSqlParser {
} 


PARSER_END(CCJSqlParser)


SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}


TOKEN: /* SQL Keywords. prefixed with K_ to avoid name clashes */
{
<K_AS: "AS">
|   <K_BY:"BY">
|   <K_DO:"DO">
|   <K_IS:"IS">
|   <K_IN:"IN">
|   <K_OR:"OR">
|   <K_ON:"ON">
|   <K_ALL: "ALL">
|   <K_AND: "AND">
|   <K_ANY: "ANY">
|   <K_KEY: "KEY">
|   <K_NOT:"NOT">
|   <K_SET:"SET">
|   <K_ASC:"ASC">
|   <K_TOP:"TOP">
|   <K_END:"END">
|   <K_DESC:"DESC">
|   <K_INTO:"INTO">
|   <K_NULL:"NULL">
|   <K_LIKE:"LIKE">
|   <K_REGEXP:"REGEXP">
|   <K_REGEXP_LIKE:"REGEXP_LIKE">
|   <K_DROP:"DROP">
|   <K_JOIN:"JOIN">
|   <K_LEFT:"LEFT">
|   <K_CROSS:"CROSS">
|   <K_FROM:"FROM">
|   <K_OPEN:"OPEN">
|   <K_CASE:"CASE">
|   <K_WHEN:"WHEN">
|   <K_THEN:"THEN">
|   <K_ELSE:"ELSE">
|   <K_SOME:"SOME">
|   <K_FULL:"FULL">
|   <K_WITH:"WITH">
|   <K_TABLE:"TABLE">
|   <K_VIEW:"VIEW">
|   <K_WHERE:"WHERE">
|   <K_FOR:"FOR">
|   <K_PIVOT:"PIVOT">
|   <K_XML:"XML">
|   <K_USING:"USING">
|   <K_UNION:"UNION">
|   <K_GROUP:"GROUP">
|   <K_BEGIN:"BEGIN">
|   <K_INDEX: "INDEX">
|   <K_INNER:"INNER">
|   <K_LIMIT:"LIMIT"> 
|   <K_OUTER:"OUTER">
|   <K_ORDER:"ORDER">
|   <K_RIGHT:"RIGHT">
|   <K_VALUE:"VALUE">
|   <K_DELETE:"DELETE">
|   <K_CREATE:"CREATE">
|   <K_SELECT:"SELECT">
|   <K_OFFSET:"OFFSET">
|   <K_EXISTS:"EXISTS">
|   <K_HAVING:"HAVING">
|   <K_INSERT:"INSERT">
|   <K_UPDATE:"UPDATE">
|   <K_VALUES:"VALUES">
|   <K_ESCAPE:"ESCAPE">
|   <K_PRIMARY:"PRIMARY">
|   <K_NATURAL:"NATURAL">
|   <K_REPLACE:"REPLACE">
|   <K_BETWEEN:"BETWEEN">
|   <K_TRUNCATE:"TRUNCATE">
|   <K_DISTINCT:"DISTINCT">
|   <K_INTERSECT:"INTERSECT">
|   <K_CAST:"CAST">
|   <K_EXCEPT:"EXCEPT">
|   <K_MINUS:"MINUS">
|   <K_OVER:"OVER">
|   <K_PARTITION:"PARTITION">
|   <K_EXTRACT:"EXTRACT">
|	<K_LATERAL:"LATERAL">
|	<K_MATERIALIZED:"MATERIALIZED">
|   <K_INTERVAL:"INTERVAL">
|	<K_FOREIGN:"FOREIGN">
|	<K_CONSTRAINT:"CONSTRAINT">
|	<K_REFERENCES:"REFERENCES">
}


TOKEN : /* Numeric Constants */
{
	< S_DOUBLE: ((<S_INTEGER>)? "." <S_INTEGER> ( ["e","E"] ([ "-","+"])? <S_INTEGER> )? 
				|
				<S_INTEGER> "." (["e","E"] ([ "-","+"])? <S_INTEGER>)?
				|
				<S_INTEGER> ["e","E"] ([ "-","+"])? <S_INTEGER>
				)>
  | 	< S_INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >

}


SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">

}


TOKEN:
{
	< S_IDENTIFIER: ( <LETTER> | <ADDITIONAL_LETTERS> )+ ( <DIGIT> | <LETTER> | <ADDITIONAL_LETTERS> | <SPECIAL_CHARS>)* >
| 	< #LETTER: ["a"-"z", "A"-"Z", "_"] >
|   < #SPECIAL_CHARS: "$" | "_">
|   < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" | ("`" (~["\n","\r","`"])* "`") | ("[" (~["\n","\r","]"])* "]") >

/*
To deal with database names (columns, tables) using not only latin base characters, one
can expand the following rule to accept additional letters. Here is the
addition of german umlauts.

There seems to be no way to recognize letters by an external function to allow
a configurable addition. One must rebuild JSqlParser with this new "Letterset".
*/ 
|   < #ADDITIONAL_LETTERS: ["ä","ö","ü","Ä","Ö","Ü","ß"] >
}


Statement Statement() :
{ Statement stm;}
{
	(
    stm = Select()
    |
    stm =  Update()
    |
    stm = Insert()
    |
    stm = Delete()
    |
    stm =  Replace()
    |
    LOOKAHEAD(3)
    stm = CreateIndex()
    |
	LOOKAHEAD(2)
    stm = CreateTable()
    |
	LOOKAHEAD(2)
	stm = CreateView()
	|
    stm = Drop()
    |
    stm = Truncate()
    )
    [";"]
    <EOF>
    { return stm; }
}


Update Update():
{ 
	Update update = new Update(); 
	Table table = null;
	Expression where = null;
	Column tableColumn = null;
	List<Expression> expList = new ArrayList<Expression>();
	List<Column> columns = new ArrayList<Column>(); 
	Expression value = null;
	FromItem fromItem = null;
	List<Join> joins = null;
}
{
    <K_UPDATE> table=TableWithAlias()
    <K_SET> tableColumn=Column() "=" value=SimpleExpression() { columns.add(tableColumn); expList.add(value); }
		  ("," tableColumn=Column() "=" value=SimpleExpression()  { columns.add(tableColumn); expList.add(value); } )*

   [ <K_FROM>
      fromItem=FromItem()
      joins=JoinsList() ]

   [ where=WhereClause() { update.setWhere(where); } ]
   { 
   		update.setColumns(columns);
   		update.setExpressions(expList);
   		update.setTable(table);
		update.setFromItem(fromItem);
		update.setJoins(joins);
		return update;
   }
}

Replace Replace():
{ 
	Replace replace = new Replace(); 
	Table table = null;
	Column tableColumn = null;
	Expression value = null;
	
	List<Column> columns = new ArrayList<Column>(); 
	List<Expression> expList = new ArrayList<Expression>(); 
	ItemsList itemsList = null;
	Expression exp = null;
}
{
    <K_REPLACE> [<K_INTO>] table=Table()
    
    (
		(    
		    <K_SET> tableColumn=Column() "=" value=SimpleExpression() { columns.add(tableColumn); expList.add(value); }
			  ("," tableColumn=Column() "=" value=SimpleExpression() { columns.add(tableColumn); expList.add(value); } )*
			 {
		   		replace.setExpressions(expList);
			 }
		)
		|
	
		(
		     [LOOKAHEAD(2) "(" tableColumn=Column() { columns.add(tableColumn); } ("," tableColumn=Column() { columns.add(tableColumn); } )* ")"  ]
			
			( 
				LOOKAHEAD(2) [<K_VALUES> | <K_VALUE>] "(" exp=PrimaryExpression() { expList.add(exp); } 
						("," exp=PrimaryExpression()  { expList.add(exp); } )* ")" { itemsList = new ExpressionList(expList); }
				
				| 
					{ replace.setUseValues(false); }
				
				    itemsList=SubSelect()  
			)
		    { 
				replace.setItemsList(itemsList);
		    }
		)
	)
   { 
   		if (columns.size() > 0)
	   		replace.setColumns(columns);
   		replace.setTable(table);
		return replace;
   }
}


Insert Insert():
{ 
	Insert insert = new Insert(); 
	Table table = null;
	Column tableColumn = null;
 	List<Column> columns = new ArrayList<Column>(); 
	List<Expression> primaryExpList = new ArrayList<Expression>(); 
	ItemsList itemsList = null;
	Expression exp = null;
	MultiExpressionList multiExpr = null;
}
{
    <K_INSERT> [<K_INTO>] table=Table()
    
    
     [LOOKAHEAD(2) "(" tableColumn=Column() { columns.add(tableColumn); } ("," tableColumn=Column() { columns.add(tableColumn); } )* ")"  ]
	
	( 
		LOOKAHEAD(2) [<K_VALUES> | <K_VALUE>]  "(" exp=SimpleExpression() { primaryExpList.add(exp); } 
				("," exp=SimpleExpression()  { primaryExpList.add(exp); } )* ")" { itemsList = new ExpressionList(primaryExpList); }

			("," "(" exp=SimpleExpression() { 
					if (multiExpr==null) {
						multiExpr=new MultiExpressionList(); 
						multiExpr.addExpressionList((ExpressionList)itemsList); 
						itemsList = multiExpr;
					}
					primaryExpList = new ArrayList<Expression>(); 
					primaryExpList.add(exp); } 
				("," exp=SimpleExpression() { primaryExpList.add(exp); } )* ")" { multiExpr.addExpressionList(primaryExpList); } )*
		
		| 
		
		[LOOKAHEAD(2) "(" ]
		(
			{ insert.setUseValues(false); }
			itemsList=  SubSelect() 
		)
		[ ")" ]
	)
    
    { 
		insert.setItemsList(itemsList);
	    insert.setTable(table);
	    if (columns.size() > 0)
	    	insert.setColumns(columns);
    	return insert; 
    }
}



Delete Delete():
{ 
	Delete delete = new Delete();
	Table table = null;
	Expression where = null;
}
{
    <K_DELETE> [<K_FROM>] table=TableWithAlias() 
    [where=WhereClause() { delete.setWhere(where); } ]
    { 
    	delete.setTable(table);
    	return delete;
    }
}



Column Column():
{
	String name1 = null;
	String name2 = null;
	String name3 = null;
}
{
    // [schema.][tabella.]colonna
    name1=RelObjectName() [ "." name2=RelObjectName() ["." name3=RelObjectName()]]
    {
    	String colName = null;
    	Table table = null;
    	if (name3 != null) {
    		table = new Table(name1, name2);
    		colName = name3;
    	} else if (name2 != null) {
    		table = new Table(null, name1);
    		colName = name2;
    	} else {
    		table = new Table(null, null);
    		colName = name1;
    	}
    	
    	return new Column(table, colName); 
   	}
}

String RelObjectName()  :
{	Token tk = null; }
{
	(
	tk=<S_IDENTIFIER>
	|
	tk=<S_QUOTED_IDENTIFIER>
	)
	
    { return tk.image; }
}

Table TableWithAlias():
{
	Table table = null;
	String alias = null;
}
{
	table=Table() [alias=Alias() { table.setAlias(alias); }]
	{ return table; }
}


Table Table():
{ 
	Table table = null;
	String name1 = null;
	String name2 = null;
}
{
	(LOOKAHEAD(3) 
		name1=RelObjectName() "." name2=RelObjectName()  { table = new Table(name1, name2); }
		|
		name1=RelObjectName() { table = new Table(null, name1); } 
	)	
	{		
		return table; 
	}
	
}



Select Select():
{ 
	Select select = new Select();
	SelectBody selectBody = null;
	List<WithItem> with = null; 
}
{
	[ with=WithList() { select.setWithItemsList(with); } ]
    selectBody = SelectBody()
	{ 
		select.setSelectBody(selectBody);
		return select; 
	}
}

SelectBody SelectBody():
{ SelectBody selectBody = null; }
{
	(
		LOOKAHEAD(SetOperationList())
		    selectBody = SetOperationList() 
    	|
	    selectBody = PlainSelect()
	)
	{ return selectBody; }
}

PlainSelect PlainSelect():
{ 
	PlainSelect plainSelect = new PlainSelect(); 
	List<SelectItem> selectItems = null;
	FromItem fromItem = null;
	List<Join> joins = null;
	List<SelectItem> distinctOn = null;
	Expression where = null;
	List<OrderByElement> orderByElements;
	List<Expression> groupByColumnReferences = null;
	Expression having = null;
	Limit limit = null;
	Top top = null;
}
{
    <K_SELECT> 

    [ 
    	<K_ALL> 
    	| 
    		(
    			<K_DISTINCT> { Distinct distinct = new Distinct(); plainSelect.setDistinct(distinct); } 
    				[ "ON" "(" distinctOn=SelectItemsList()  { plainSelect.getDistinct().setOnSelectItems(distinctOn); } ")" ]
    		)
    ] 
    
    [top = Top() { plainSelect.setTop(top);	} ]

    
    selectItems=SelectItemsList()
    
    
     // TODO
    [IntoClause()]
    [ <K_FROM>
      fromItem=FromItem()
      joins=JoinsList() ]

    [ where=WhereClause() { plainSelect.setWhere(where); }]
    [ groupByColumnReferences=GroupByColumnReferences() { plainSelect.setGroupByColumnReferences(groupByColumnReferences); }]
    [ having=Having() { plainSelect.setHaving(having); }]
	[LOOKAHEAD(2) orderByElements = OrderByElements()	{ 		 plainSelect.setOrderByElements(orderByElements);	}   ]
    [LOOKAHEAD(2) limit = Limit() { plainSelect.setLimit(limit);	} ]
	
	{ 
		plainSelect.setSelectItems(selectItems);
		plainSelect.setFromItem(fromItem);
		if (joins != null && joins.size() > 0)
			plainSelect.setJoins(joins);
		return plainSelect; 
	}
}

SetOperationList SetOperationList():
{
	SetOperationList list = new SetOperationList();
	List<OrderByElement> orderByElements = null;
	Limit limit = null;
	PlainSelect select = null;
	List<PlainSelect> selects = new ArrayList<PlainSelect>();
	List<SetOperation> operations = new ArrayList<SetOperation>();
}
{
	(
	
		(
			(("(" select=PlainSelect() ")") | (select=PlainSelect() )) {selects.add(select);}
			(
				((<K_UNION> { UnionOp union = new UnionOp();operations.add(union); } [ <K_ALL> { union.setAll(true); } | <K_DISTINCT> { union.setDistinct(true); } ])
				| <K_INTERSECT> { operations.add(new IntersectOp()); }
				| <K_MINUS> { operations.add(new MinusOp()); }
				| <K_EXCEPT> { operations.add(new ExceptOp()); }
				)

				(("(" select=PlainSelect() ")") | (select=PlainSelect() )) {selects.add(select);} 
			)+
		)

		[orderByElements=OrderByElements() {list.setOrderByElements(orderByElements);} ]
		[limit=Limit() {list.setLimit(limit);} ]
	)

	{ 
		list.setOpsAndSelects(selects,operations);
		return list; 
	}
}


List<WithItem> WithList():
{
	List<WithItem> withItemsList = new ArrayList<WithItem>();
	WithItem with = null;
}
{
	<K_WITH> with=WithItem() { withItemsList.add(with); } ("," with=WithItem() { withItemsList.add(with); } )*
 
 	{ return withItemsList; }
}

WithItem WithItem():
{
	WithItem with = new WithItem();
	String name = null;
	List<SelectItem> selectItems = null;
	SelectBody selectBody = null;
}
{
	 name=RelObjectName() { with.setName(name); }
	 [ "(" selectItems=SelectItemsList() ")" { with.setWithItemList(selectItems); } ]
	 <K_AS> 
	 "(" selectBody = SelectBody() { with.setSelectBody(selectBody); } ")"
	 { return with; }
}

List<SelectItem> SelectItemsList():
{ 
	List<SelectItem> selectItemsList = new ArrayList<SelectItem>();
	SelectItem selectItem = null; 
}
{ 
    selectItem=SelectItem() { selectItemsList.add(selectItem); } ("," selectItem=SelectItem() { selectItemsList.add(selectItem); } )*
    
    { return selectItemsList; }
}

SelectExpressionItem SelectExpressionItem():
{
	SelectExpressionItem selectExpressionItem = null;
	Expression expression = null;
	String alias = null;
}
{
	 expression=SimpleExpression() { selectExpressionItem = new SelectExpressionItem(); selectExpressionItem.setExpression(expression); }
			 [alias=Alias() { selectExpressionItem.setAlias(alias); }] { return selectExpressionItem; }
}

SelectItem SelectItem():
{
	Function function = null;
	AllColumns allTableColumns = null;
	Column tableColumn = null;
	SelectItem selectItem = null;
	SelectExpressionItem selectExpressionItem = null;
	SubSelect subSelect = null;
}
{
	

    ("*" { selectItem = new AllColumns(); }
    |
	LOOKAHEAD(AllTableColumns()) selectItem=AllTableColumns()
	|
	 selectExpressionItem=SelectExpressionItem() {selectItem = selectExpressionItem; }
	)
	{
		return selectItem;
	}
	
}

AllTableColumns AllTableColumns():
{
	Table table = null;
}
{  
     table=Table() "." "*"
	{ 
		return new AllTableColumns(table); 
	}
	
}

String Alias():
{ String retval = null; }
{
	[<K_AS>] retval=RelObjectName()
   { return retval; }
}


FunctionItem FunctionItem():
{
    String alias = null;
    Function function;
    FunctionItem functionItem;
}
{
    function=Function() { functionItem = new FunctionItem(); functionItem.setFunction(function); }
			 [alias=Alias() { functionItem.setAlias(alias); }]
    { return functionItem; }
}



List<Column> PivotForColumn():
{
    List<Column> columns = new ArrayList<Column>();
    Column column;
}
{
    column = Column()
    {
        columns.add(column);
        return columns;
    }
}

List<Column> PivotForColumns():
{
    List<Column> columns = new ArrayList<Column>();
    Column column;
}
{
    "(" column = Column() { columns.add(column); }
    ("," column = Column() { columns.add(column); } )*
    ")"
    { return columns; }
}

List<FunctionItem> PivotFunctionItems():
{
    List<FunctionItem> functionItems = new ArrayList<FunctionItem>();
    FunctionItem item;
}
{
    item = FunctionItem() {functionItems.add(item);}
    ( "," item = FunctionItem() {functionItems.add(item);} )*
    { return functionItems; }
}

List<SelectExpressionItem> PivotSingleInItems():
{
   List<SelectExpressionItem> retval = new ArrayList<SelectExpressionItem>();
   SelectExpressionItem item;
}
{
   item = SelectExpressionItem() {retval.add(item);}
   ("," item = SelectExpressionItem() {retval.add(item);} )*
   { return retval; }
}


ExpressionListItem ExpressionListItem():
{
	ExpressionListItem expressionListItem = null;
	ExpressionList expressionList = null;
	String alias = null;
}
{
    "("
    expressionList=SimpleExpressionList() { expressionListItem = new ExpressionListItem(); expressionListItem.setExpressionList(expressionList); }
    ")"
	[alias=Alias() { expressionListItem.setAlias(alias); }]
    { return expressionListItem; }
}


List<ExpressionListItem> PivotMultiInItems():
{
   List<ExpressionListItem> retval = new ArrayList<ExpressionListItem>();
   ExpressionListItem item;
}
{
   item = ExpressionListItem() {retval.add(item);}
   ("," item = ExpressionListItem() {retval.add(item);} )*
   { return retval; }
}

Pivot Pivot():
{
    Pivot retval = new Pivot();
    List<FunctionItem> functionItems;
    List<Column> forColumns;
    List<SelectExpressionItem> singleInItems = null;
    List<ExpressionListItem> multiInItems = null;
}
{
	<K_PIVOT> "(" functionItems = PivotFunctionItems() <K_FOR>
	( forColumns = PivotForColumn() | forColumns = PivotForColumns() )
	<K_IN> "("
	(LOOKAHEAD(3) singleInItems = PivotSingleInItems() | multiInItems = PivotMultiInItems() )
	")"
	")"
    {
        retval.setFunctionItems(functionItems);
        retval.setForColumns(forColumns);
        retval.setSingleInItems(singleInItems);
        retval.setMultiInItems(multiInItems);
        return retval;
    }
}

PivotXml PivotXml():
{
    PivotXml retval = new PivotXml();
    List<FunctionItem> functionItems;
    List<Column> forColumns;
    List<SelectExpressionItem> singleInItems = null;
    List<ExpressionListItem> multiInItems = null;
    SelectBody inSelect = null;
}
{
	<K_PIVOT> <K_XML> "(" functionItems = PivotFunctionItems() <K_FOR>
	( forColumns = PivotForColumn() | forColumns = PivotForColumns() )
	<K_IN> "("
	(
	    <K_ANY> { retval.setInAny(true); } |
	    LOOKAHEAD(1) inSelect = SelectBody() |
	    LOOKAHEAD(2) singleInItems = PivotSingleInItems() |
	    multiInItems = PivotMultiInItems()
    )
	")"
	")"
    {
        retval.setFunctionItems(functionItems);
        retval.setForColumns(forColumns);
        retval.setSingleInItems(singleInItems);
        retval.setMultiInItems(multiInItems);
        retval.setInSelect(inSelect);
        return retval;
    }
}

void IntoClause():
{}
{
   <K_INTO> Table() ("," Table())*
}

FromItem FromItem():
{
	FromItem fromItem = null;
	Pivot pivot = null;
	String alias = null;
}
{
	(
		LOOKAHEAD(ValuesList()) fromItem=ValuesList()
		|
		(
			(
				(	
					"(" 	
						(
						LOOKAHEAD(SubJoin())
						fromItem=SubJoin()  
						|  
						fromItem=SubSelect()
						)
					")"
				)
				|
				fromItem=Table()
				|
				fromItem=LateralSubSelect()
			)
			[(LOOKAHEAD(2) pivot=PivotXml()|pivot=Pivot()) { fromItem.setPivot(pivot); } ]
			[alias=Alias() { fromItem.setAlias(alias); } ]
		)
	)
	{
		return fromItem;
	}
}

FromItem ValuesList(): 
{
	MultiExpressionList exprList = new MultiExpressionList();
	List<Expression> primaryExpList = new ArrayList<Expression>();
	ValuesList valuesList = new ValuesList();
	Expression exp = null;
	List<String> colNames = null;
	String colName;
	String alias;
}
{
	"("
	<K_VALUES>
	(LOOKAHEAD(3) ("(" exp=SimpleExpression() { primaryExpList.add(exp); } 
			("," exp=SimpleExpression()  { primaryExpList.add(exp); } )* ")" { exprList.addExpressionList(primaryExpList); }

			("," "(" exp=SimpleExpression() { 
					primaryExpList = new ArrayList<Expression>(); 
					primaryExpList.add(exp); } 
				("," exp=SimpleExpression() { primaryExpList.add(exp); } )* ")" { exprList.addExpressionList(primaryExpList); } )*)
	|
	( exp=SimpleExpression() { exprList.addExpressionList(exp); valuesList.setNoBrackets(true); } 
		("," exp=SimpleExpression()  { exprList.addExpressionList(exp);} )*
	))
	")"

	[alias=Alias() { valuesList.setAlias(alias); } 

		[ "("
			colName = RelObjectName() { colNames = new ArrayList<String>(); colNames.add(colName); }
			( "," colName = RelObjectName() { colNames.add(colName); } )*
			")" { valuesList.setColumnNames(colNames); } ]

	]

	{
		valuesList.setMultiExpressionList(exprList);
		return valuesList;
	}
}

LateralSubSelect LateralSubSelect():
{
	LateralSubSelect lateralSubSelect = new LateralSubSelect();
	SubSelect subSelect = null;
}
{
	<K_LATERAL>
	 "(" subSelect=SubSelect() ")"
	{
		lateralSubSelect.setSubSelect(subSelect);
		return lateralSubSelect;
	}
}

FromItem SubJoin():
{
	FromItem fromItem = null;
	Join join = null;
	SubJoin subJoin = new SubJoin();
}
{
	fromItem=FromItem() { subJoin.setLeft(fromItem); } 
	join=JoinerExpression() { subJoin.setJoin(join); }
	
	{
		return subJoin;
	}
}

List JoinsList():
{
	List<Join> joinsList = new ArrayList<Join>();
	Join join = null; 
}
{

    (join=JoinerExpression() { joinsList.add(join); })*
    
    { return joinsList; }
}

Join JoinerExpression():
{ 
	Join join = new Join(); 
	FromItem right = null;
	Expression onExpression = null;
	Column tableColumn;
	List<Column> columns = null;
}
{
	/*
		Refactor to be more restrictive.
			left [outer] join
			right [outer] join
			full [outer] join
			[inner] join
			cross join
			natural join
     */
	  [ (
	  	<K_LEFT> { join.setLeft(true); }
  		| <K_RIGHT> { join.setRight(true); } 
  		| <K_FULL> { join.setFull(true); } 
  		| <K_NATURAL> { join.setNatural(true); } 
		| <K_CROSS> { join.setCross(true); } 
  		)
  	   ]
  		
  	   [
  	    (
  		<K_OUTER> { join.setOuter(true); }
  		| <K_INNER> { join.setInner(true); }
  		)
  	   ]
  	  
  	    ( <K_JOIN> | "," { join.setSimple(true); } ) right=FromItem()  
	[
		( <K_ON> onExpression=Expression()  { join.setOnExpression(onExpression); } )
		|
		( <K_USING> "(" tableColumn=Column() { columns = new ArrayList(); columns.add(tableColumn); } 
				("," tableColumn=Column() { columns.add(tableColumn); } )* ")"  
		  { join.setUsingColumns(columns); }   )
  	]			
  {
  	join.setRightItem(right); 
  } 
  
  
  { return join; }
}


Expression WhereClause():
{
	Expression retval = null;
}
{
    <K_WHERE> retval=Expression()
    { return retval; }
}


List<Expression> GroupByColumnReferences():
{
	Expression columnReference = null;
	List<Expression> columnReferences = new ArrayList<Expression>();
}
{
    <K_GROUP> <K_BY> columnReference=SimpleExpression() {columnReferences.add(columnReference); }
    ("," columnReference=SimpleExpression()  {columnReferences.add(columnReference); } )*
	{
		return columnReferences;
	}
}

Expression Having():
{
	Expression having = null;
}
{
    <K_HAVING> having=Expression()
	{
		return having;
	}
}

List<OrderByElement> OrderByElements():
{ 
	List<OrderByElement> orderByList = new ArrayList<OrderByElement>();
	OrderByElement orderByElement = null;
}
{
    <K_ORDER> <K_BY> orderByElement=OrderByElement() { orderByList.add(orderByElement); }
        ("," orderByElement=OrderByElement() { orderByList.add(orderByElement); } )*
    {
    	return orderByList; 	
    }
}

OrderByElement OrderByElement():
{
	OrderByElement orderByElement = new OrderByElement(); 
	Expression columnReference = null;
}
{
	columnReference = SimpleExpression()
    [<K_ASC> | (<K_DESC> { orderByElement.setAsc(false); } )  ]
	{
    	orderByElement.setExpression(columnReference);
		return orderByElement;
	}
}

Limit Limit():
{
	Limit limit = new Limit(); 
	Token token = null;
}
{
	(
			LOOKAHEAD(3)
				// mysql-> LIMIT offset,row_count
				<K_LIMIT> 
					 (
					 	token=<S_INTEGER> { limit.setOffset(Long.parseLong(token.image)); } 
					 	|
					 	"?" { limit.setOffsetJdbcParameter(true);} 
					 ) 
					 ","  
				
				(
				token=<S_INTEGER> { limit.setRowCount(Long.parseLong(token.image)); } | "?" { limit.setRowCountJdbcParameter(true);}
				)
			| 
			// postgresql-> OFFSET offset
			 <K_OFFSET>
				 (token=<S_INTEGER> { limit.setOffset(Long.parseLong(token.image)); } | "?" { limit.setOffsetJdbcParameter(true);} )  
			|
				// mysql-postgresql-> LIMIT (row_count | ALL) [OFFSET offset]
				<K_LIMIT> 
				 (
				 	token=<S_INTEGER> { limit.setRowCount(Long.parseLong(token.image)); } 
				 	|
				 	"?" { limit.setRowCountJdbcParameter(true);}  
				 	|
				 	<K_ALL> { limit.setLimitAll(true);}  
				 )
				 
				 [LOOKAHEAD(2) <K_OFFSET>
					 (token=<S_INTEGER> { limit.setOffset(Long.parseLong(token.image)); } | "?" { limit.setOffsetJdbcParameter(true);} )  ]

		)
	{
		return limit;
	}
}

Top Top():
{
	Top top = new Top(); 
	Token token = null;
}
{
	<K_TOP>
	 (
	 	token=<S_INTEGER> { top.setRowCount(Long.parseLong(token.image)); } 
	 	|
	 	"?" { top.setRowCountJdbcParameter(true);} 
	 ) 
	{
		return top;
	}
}

	

Expression Expression():
{ 
	Expression retval = null;
}
{
	(
	LOOKAHEAD(OrExpression())
		retval=OrExpression() 
		|
		"(" retval=Expression() ")" {retval = new Parenthesis(retval); }
		
	)
	
    { return retval; }
}

Expression OrExpression()  :
{
	Expression left, right, result;
}
{
	left=AndExpression() { result = left; }
	(
		LOOKAHEAD(<K_OR>) 
			<K_OR>
			right=AndExpression()
			{
				result = new OrExpression(left, right);
				left = result;
	   		}
	 )*
	 {
	 	return result;
	 }
	   
}



Expression AndExpression() :
{
	Expression left, right, result;
	boolean not = false;
}
{

	(
	LOOKAHEAD(Condition())
	    left=Condition()
	    |
	    [ <K_NOT> { not = true; } ]
	    "(" left=OrExpression() ")" {left = new Parenthesis(left); if (not) { ((Parenthesis)left).setNot(); not = false; } }
	)
	{ result = left; }
	
	(
		LOOKAHEAD(<K_AND>)
 		<K_AND>
		(
		LOOKAHEAD(Condition())
		    right=Condition()
		    |
		    [ <K_NOT> { not = true; } ]
		    "(" right=OrExpression() ")" {right = new Parenthesis(right); if (not) { ((Parenthesis)right).setNot(); not = false; } }
		)
		{
			result = new AndExpression(left, right);
			left = result;
		}
	)*
	{
		return result;
	}
}

Expression Condition():
{
	Expression result;
}
{
	(LOOKAHEAD(SQLCondition()) result=SQLCondition()
	| result=FunctionCondition()
	| result=RegularCondition()
	)
	
	{ return result; }
}

Expression FunctionCondition():
{
	Function result;
	ExpressionList parameters;
}
{
    <K_REGEXP_LIKE> { result = new Function(); result.setName("REGEXP_LIKE"); }
    "("
    parameters=SimpleExpressionList() { result.setParameters(parameters); }
    ")"

	{ return result; }
}

Expression RegularCondition():
{
	Expression result = null;
	Expression leftExpression;
	Expression rightExpression;
	boolean not = false;
	int oracleJoin=EqualsTo.NO_ORACLE_JOIN;
}
{

	[ <K_NOT> { not = true; } ] 
	leftExpression=ComparisonItem() { result = leftExpression; }

	[ "(+)" { oracleJoin=EqualsTo.ORACLE_JOIN_RIGHT; } ]

	(
	">" { result = new GreaterThan(); }
	| "<" { result = new MinorThan(); }
	| "=" { result = new EqualsTo(); }
	| ">=" { result = new GreaterThanEquals(); }
	| "<=" { result = new MinorThanEquals(); }
	| ("<>" | "!=") { result = new NotEqualsTo(); }
	| "@@" { result = new Matches(); }
	)
	rightExpression=ComparisonItem()

	[ "(+)" { oracleJoin=EqualsTo.ORACLE_JOIN_LEFT; } ]

	{
		BinaryExpression regCond = (BinaryExpression) result;
		regCond.setLeftExpression(leftExpression);
		regCond.setRightExpression(rightExpression);
		if (not)
			regCond.setNot();

		if (oracleJoin>0)
			((SupportsOldOracleJoinSyntax)result).setOldOracleJoinSyntax(oracleJoin);
	}		
	
	{ return result; }
}


Expression SQLCondition():
{
	Expression result;
}
{
	(
	LOOKAHEAD(InExpression()) result=InExpression()
	| LOOKAHEAD(Between()) result=Between()
	| LOOKAHEAD(IsNullExpression()) result=IsNullExpression()
	| LOOKAHEAD(ExistsExpression()) result=ExistsExpression()
	|  result=LikeExpression()
	)
	{ return result; }
}

Expression InExpression() :
{
	InExpression result = new InExpression();
	ItemsList leftItemsList = null;
	ItemsList rightItemsList = null;
	Expression leftExpression = null;
}
{
	( LOOKAHEAD(1) "(" (
			LOOKAHEAD(SimpleExpressionList()) leftItemsList = SimpleExpressionList() { result.setLeftItemsList(leftItemsList); } 
			|
			leftExpression=SimpleExpression()
	        [ "(+)" { result.setOldOracleJoinSyntax(EqualsTo.ORACLE_JOIN_RIGHT); } ]
		  )
	  ")"
	|
		leftExpression=SimpleExpression() { result.setLeftExpression(leftExpression); }
        [ "(+)" { result.setOldOracleJoinSyntax(EqualsTo.ORACLE_JOIN_RIGHT); } ]
	)
    [<K_NOT> { result.setNot(true); } ] <K_IN> "(" (LOOKAHEAD(SubSelect()) rightItemsList=SubSelect() | rightItemsList=SimpleExpressionList() ) ")"
	{ 
		result.setRightItemsList(rightItemsList);
		return result; 
	}
}

Expression Between() :
{
	Between result = new Between();
	Expression leftExpression = null;
	Expression betweenExpressionStart = null;
	Expression betweenExpressionEnd = null;
}
{
	leftExpression=SimpleExpression()
	    [<K_NOT> { result.setNot(true); }] 
	    <K_BETWEEN> betweenExpressionStart=SimpleExpression() <K_AND> betweenExpressionEnd=SimpleExpression()
	
	{ 
		result.setLeftExpression(leftExpression);
		result.setBetweenExpressionStart(betweenExpressionStart);
		result.setBetweenExpressionEnd(betweenExpressionEnd);
		return result; 
	}
}

Expression LikeExpression() :
{
	LikeExpression result = new LikeExpression();
	Expression leftExpression = null;
	Expression rightExpression = null;
}
{
	leftExpression=SimpleExpression()
    [<K_NOT> { result.setNot(true); } ] <K_LIKE> rightExpression=SimpleExpression()
    [<K_ESCAPE> token=<S_CHAR_LITERAL> { result.setEscape((new StringValue(token.image)).getValue()); }]
	{ 
		result.setLeftExpression(leftExpression);
		result.setRightExpression(rightExpression);
		return result; 
	}
}

Expression IsNullExpression():
{
	IsNullExpression result = new IsNullExpression();
	Expression leftExpression = null;
}
{
	(
	<K_NOT> { result.setNot(true); } leftExpression=SimpleExpression() <K_IS> <K_NULL>
	| 
	leftExpression=SimpleExpression() <K_IS> [<K_NOT> { result.setNot(true); } ] <K_NULL>
	)

	{ 
		result.setLeftExpression(leftExpression);
		return result; 
	}
}


Expression ExistsExpression():
{
	ExistsExpression result = new ExistsExpression();
	Expression rightExpression = null;
}
{
    [<K_NOT> { result.setNot(true); } ] <K_EXISTS> rightExpression=SimpleExpression()
	{ 
		result.setRightExpression(rightExpression);
		return result; 
	}
}


ExpressionList SQLExpressionList():
{
	ExpressionList retval = new ExpressionList();
	List<Expression> expressions = new ArrayList<Expression>();
	Expression expr = null;
}
{
    expr=Expression() { expressions.add(expr); } ("," expr=Expression() { expressions.add(expr); })*
	{
		retval.setExpressions(expressions);
		return retval;
	}
}

ExpressionList SimpleExpressionList():
{
	ExpressionList retval = new ExpressionList();
	List<Expression> expressions = new ArrayList<Expression>();
	Expression expr = null;
}
{
    expr=SimpleExpression() { expressions.add(expr); } ("," expr=SimpleExpression() { expressions.add(expr); })*
	{
		retval.setExpressions(expressions);
		return retval;
	}
}

Expression ComparisonItem() :
{ 
	Expression retval = null; 
}
{
  (
    retval=AllComparisonExpression()
    | retval=AnyComparisonExpression()
    | retval=SimpleExpression()
  )

   {
      return retval;
   }
}

Expression AllComparisonExpression() :
{ 
	AllComparisonExpression retval = null; 
	SubSelect subselect = null; 
}
{
 <K_ALL> "(" subselect=SubSelect() ")" { retval = new AllComparisonExpression(subselect); }
   {
      return retval;
   }
}

Expression AnyComparisonExpression() :
{ 
	AnyComparisonExpression retval = null; 
	SubSelect subselect = null; 
}
{
 (<K_ANY> | <K_SOME>) "(" subselect=SubSelect() ")" { retval = new AnyComparisonExpression(subselect); }
   {
      return retval;
   }
}

Expression SimpleExpression():
{ 
	Expression retval = null; 
}
{
  (
		LOOKAHEAD(BitwiseAndOr())
		retval=BitwiseAndOr() 
		|
		"(" retval=BitwiseAndOr() ")" {retval = new Parenthesis(retval); }
  
  )

   {
      return retval;
   }
}

Expression ConcatExpression():
{
	Expression result = null;
	Expression leftExpression = null;
	Expression rightExpression = null;
}
{
    leftExpression=AdditiveExpression()  { result = leftExpression; }
    (
    	"||"
    	rightExpression=AdditiveExpression()
		{
			Concat binExp = new Concat();
			binExp.setLeftExpression(leftExpression);
			binExp.setRightExpression(rightExpression);
			result = binExp;
			leftExpression = result; 
		}								
    )*
    
    { return result; }
}

Expression BitwiseAndOr():
{
	Expression result = null;
	Expression leftExpression = null;
	Expression rightExpression = null;
}
{
    leftExpression=ConcatExpression()  { result = leftExpression; }
    (
    	LOOKAHEAD(2) (
    					"|" { result = new BitwiseOr(); }
    				  	| 
    				  	"&" { result = new BitwiseAnd(); } 
    				  ) 
    								
    						rightExpression=ConcatExpression()
    						
		{
			BinaryExpression binExp = (BinaryExpression) result;
			binExp.setLeftExpression(leftExpression);
			binExp.setRightExpression(rightExpression);
			leftExpression = result; 
		}								
    )*
    
    { return result; }
}

Expression AdditiveExpression():
{
	Expression result = null;
	Expression leftExpression = null;
	Expression rightExpression = null;
}
{
    leftExpression=MultiplicativeExpression()  { result = leftExpression; }
    (
    	LOOKAHEAD(2) ("+" { result = new Addition(); }
    								| "-" { result = new Subtraction(); } ) 
    								
    						rightExpression=MultiplicativeExpression()
    						
		{
			BinaryExpression binExp = (BinaryExpression) result;
			binExp.setLeftExpression(leftExpression);
			binExp.setRightExpression(rightExpression);
			leftExpression = result; 
		}								
    )*
    
    { return result; }
}


Expression MultiplicativeExpression():
{
	Expression result = null;
	Expression leftExpression = null;
	Expression rightExpression = null;
}
{
	(
	LOOKAHEAD(BitwiseXor())
	    leftExpression=BitwiseXor()
	    |
	    "(" leftExpression=ConcatExpression() ")" {leftExpression = new Parenthesis(leftExpression); }
	)
      { result = leftExpression; }
    (
    	LOOKAHEAD(2) ("*" { result = new Multiplication(); }
    								| "/" { result = new Division(); }
    								| "%" { result = new Modulo(); }
    				) 
    								
				(
				LOOKAHEAD(BitwiseXor())
    						rightExpression=BitwiseXor()
						    |
						    "(" rightExpression=ConcatExpression() ")" {rightExpression = new Parenthesis(rightExpression); }
				)
    						
		{
			BinaryExpression binExp = (BinaryExpression) result;
			binExp.setLeftExpression(leftExpression);
			binExp.setRightExpression(rightExpression);
			leftExpression = result; 
		}								
    )*
    { return result; }
}

Expression BitwiseXor():
{
	Expression result = null;
	Expression leftExpression = null;
	Expression rightExpression = null;
}
{
    leftExpression=PrimaryExpression()  { result = leftExpression; }
    (
    	"^"
    	rightExpression=PrimaryExpression()
		{
			BitwiseXor binExp = new BitwiseXor();
			binExp.setLeftExpression(leftExpression);
			binExp.setRightExpression(rightExpression);
			result = binExp;
			leftExpression = result; 
		}								
    )*
    
    { return result; }
}


Expression PrimaryExpression():
{ 
	Expression retval = null;
    CastExpression castExpr = null;
	Token token = null;
	boolean isInverse = false;
	String tmp = "";
	ColDataType type = null;
}
{

(

	<K_NULL> { retval = new NullValue(); }

	|	retval=CaseWhenExpression()
	
	| "?" { retval = new JdbcParameter(); }

	| LOOKAHEAD(AnalyticExpression()) retval=AnalyticExpression()

	| LOOKAHEAD(ExtractExpression()) retval=ExtractExpression()
	
	| LOOKAHEAD([ "+" | "-"] Function()) [ "+" | "-" { isInverse = true; }] retval=Function() 
	
	| LOOKAHEAD([	"+" | "-"] <S_DOUBLE>) 	[	"+" | "-" { tmp = "-"; }]  token=<S_DOUBLE> { retval = new DoubleValue(tmp+token.image); }
	
	| LOOKAHEAD([	"+" | "-"] <S_INTEGER>)  	[	"+" | "-" { tmp = "-"; }]  token=<S_INTEGER> { retval = new LongValue(tmp+token.image); }

	| LOOKAHEAD(CastExpression()) [ "+" | "-" { isInverse = true; }] retval=CastExpression()
	
	| LOOKAHEAD(Column()) 	[ "+" | "-" { isInverse = true; }] retval=Column() 

	| LOOKAHEAD(2) [ "+" | "-" { isInverse = true; }]  "(" retval=PrimaryExpression() ")" {retval = new Parenthesis(retval); }

	| token=<S_CHAR_LITERAL> { retval = new StringValue(token.image); }

	| [ "+" | "-" { isInverse = true; }] "(" retval=SubSelect() ")"
	
	| 	"{d" token=<S_CHAR_LITERAL> "}" { retval = new DateValue(token.image); }

	| 	"{t" token=<S_CHAR_LITERAL> "}" { retval = new TimeValue(token.image); }

	| 	"{ts" token=<S_CHAR_LITERAL> "}" { retval = new TimestampValue(token.image); }

	| retval = IntervalExpression()
)

[ "::" type=ColDataType() { 
		castExpr = new CastExpression(); 
		castExpr.setUseCastKeyword(false); 
		castExpr.setLeftExpression(retval);
		castExpr.setType(type);
		retval=castExpr;
} ]

    { 
		if (isInverse) { 
			retval = new InverseExpression(retval); 
		}
    	return retval; 
    }
}

IntervalExpression IntervalExpression() : {
	IntervalExpression interval = new IntervalExpression();
	Token token;
}
{
	<K_INTERVAL> token=<S_CHAR_LITERAL> { interval.setParameter(token.image); }
	{
		return interval;
	}
}

AnalyticExpression AnalyticExpression() :
{
	AnalyticExpression retval = new AnalyticExpression();
	List<Column> plist = new ArrayList<Column>();
	List<OrderByElement> olist = null;
	Token token = null;
	Column column = null;
	Expression expr = null;
	Expression offset = null;
	Expression defaultValue = null;
}
{
	token=<S_IDENTIFIER> { retval.setName(token.image); }
	    "(" [ expr=SimpleExpression() ["," offset=SimpleExpression() ["," defaultValue=SimpleExpression() ]] | "*" { retval.setAllColumns(true); } ] ")" <K_OVER> "("
        [<K_PARTITION> <K_BY> column=Column() {plist.add(column);}  ("," column=Column() {plist.add(column);} )* ] 
        [olist=OrderByElements() ]
	{
		retval.setExpression(expr);
		retval.setOffset(offset);
		retval.setDefaultValue(defaultValue);
		retval.setPartitionByColumns(plist);
		retval.setOrderByElements(olist);
	} 
	")"
	{
		return retval;
	}
}

ExtractExpression ExtractExpression() :
{
	ExtractExpression retval = new ExtractExpression();
	Token token = null;
	Expression expr = null;
}
{
	<K_EXTRACT> 
	"(" 
		token=<S_IDENTIFIER> { retval.setName(token.image); } 
		<K_FROM> 
		expr=SimpleExpression() { retval.setExpression(expr); }
	")"
	{
		return retval;
	}
}

CastExpression CastExpression():
{
	CastExpression retval = new CastExpression();
	ColDataType type = null;
	Expression expression = null;
	boolean	useCastKeyword;
}
{
	<K_CAST> "(" expression=SimpleExpression() <K_AS> type=ColDataType() ")" { retval.setUseCastKeyword(true); }

    {
	    retval.setLeftExpression(expression);
	    retval.setType(type);
    	return retval;
    }
}

Expression CaseWhenExpression():
{
	CaseExpression caseExp = new CaseExpression();
	Expression switchExp = null;
	WhenClause clause;
	List whenClauses = new ArrayList();
	Expression elseExp = null;
}
{
	<K_CASE> 
	(
    	    ( clause=WhenThenSearchCondition() { whenClauses.add(clause); } )+
             [<K_ELSE> elseExp=SimpleExpression()]
		|
		    switchExp=PrimaryExpression()
             ( clause=WhenThenValue() { whenClauses.add(clause); } )*
             [<K_ELSE> elseExp=SimpleExpression()]
	)             
    <K_END>
    { 
    	caseExp.setSwitchExpression(switchExp);
        caseExp.setWhenClauses(whenClauses);
		caseExp.setElseExpression(elseExp);
    	return caseExp;
    }
}

WhenClause WhenThenSearchCondition():
{
	WhenClause whenThen = new WhenClause();
	Expression whenExp = null;
	Expression thenExp = null;
}
{
	<K_WHEN> whenExp=Expression() <K_THEN> thenExp=SimpleExpression()
	{
	   whenThen.setWhenExpression(whenExp);
	   whenThen.setThenExpression(thenExp);
	   return whenThen;
	}
}

WhenClause WhenThenValue():
{
	WhenClause whenThen = new WhenClause();
	Expression whenExp = null;
	Expression thenExp = null;
}
{
	<K_WHEN> whenExp=PrimaryExpression() <K_THEN> thenExp=SimpleExpression()
	{
	   whenThen.setWhenExpression(whenExp);
	   whenThen.setThenExpression(thenExp);
	   return whenThen;
	}
}


Function Function():
{
	Function retval = new Function();
	String funcName = null;
	String tmp = null;
	ExpressionList expressionList = null;  
}
{
	["{fn" { retval.setEscaped(true); } ]
	(
	    funcName=RelObjectName()
    	| 
    	// workaround for replace(string) function (name clash with mysql REPLACE expression)
	    <K_REPLACE> { funcName = "REPLACE"; }
    ) [ "." tmp=RelObjectName() { funcName+= "." + tmp; } ["." tmp=RelObjectName() { funcName+= "." + tmp; }]]
    "(" [ [<K_DISTINCT> { retval.setDistinct(true); } | <K_ALL> { retval.setAllColumns(true); }] (expressionList=SimpleExpressionList() | "*" { retval.setAllColumns(true); }) ] ")"
    
    ["}"]
    { 
	    retval.setParameters(expressionList);
	    retval.setName(funcName);
    	return retval; 
    }
}



SubSelect SubSelect():
{
	SelectBody selectBody = null;
}
{
    selectBody=SelectBody()
    {
    	SubSelect subSelect = new SubSelect();
    	subSelect.setSelectBody(selectBody);
    	return subSelect;
    }
}

CreateIndex CreateIndex():
{
	CreateIndex createIndex = new CreateIndex();
	Table table = null;
	List<String> colNames = new ArrayList<String>();
	Token columnName;
	Index index = null;
	String name = null;
	String parameter = null;
}
{
	<K_CREATE>
	( parameter=CreateParameter() )*

	<K_INDEX> name=RelObjectName()
	{
		index = new Index();
		index.setName(name);
		index.setType(parameter);
	}

	<K_ON> table=Table()

	"("
	(columnName=<S_IDENTIFIER>
	|
	columnName=<S_QUOTED_IDENTIFIER>)

	(CreateParameter() | <K_ASC> | <K_DESC>)*
	{
		colNames.add(columnName.image);
	}

	(
		","
		(columnName=<S_IDENTIFIER>
		|
		columnName=<S_QUOTED_IDENTIFIER>)

		(CreateParameter() | <K_ASC> | <K_DESC>)*
		{
			colNames.add(columnName.image);
		}
	)*

	")"
	(CreateParameter() {})*

	{
		index.setColumnsNames(colNames);
		createIndex.setIndex(index);
		createIndex.setTable(table);
		return createIndex;
	}
}

CreateTable CreateTable():
{
	CreateTable createTable = new CreateTable();
	Table table = null;
	List columnDefinitions = new ArrayList();
	List columnSpecs = null;
	List tableOptions = new ArrayList();
	Token columnName;
	Token tk = null;
	Token tk2 = null;
	Token tk3 = null;
	ColDataType colDataType = null;
	String stringList = null;
	ColumnDefinition coldef = null;
	List indexes = new ArrayList();
	List colNames = null;
	Index index = null;
	ForeignKeyIndex fkIndex = null;
	String parameter = null;
	Table fkTable = null;
}
{
	<K_CREATE> 
	// TODO:
//	[ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] 
	(CreateParameter())*

	<K_TABLE> table=Table() 
	[
		"("
		(columnName=<S_IDENTIFIER>
		|
		columnName=<S_QUOTED_IDENTIFIER>)

		colDataType = ColDataType()
		{
			columnSpecs = new ArrayList();
		}
	
		( parameter=CreateParameter() { columnSpecs.add(parameter); } )*
	
		{ 
			coldef = new ColumnDefinition();
			coldef.setColumnName(columnName.image);
			coldef.setColDataType(colDataType);
			if (columnSpecs.size() > 0)
				coldef.setColumnSpecStrings(columnSpecs);
			columnDefinitions.add(coldef);
		}
		
		(
			","
			
			(
				(
					tk=<K_INDEX>
						tk3=<S_IDENTIFIER>		
						colNames=ColumnsNamesList()
						{ 
							index = new Index(); 
							index.setType(tk.image);
							index.setName(tk3.image);
							index.setColumnsNames(colNames);
							indexes.add(index);
						}
				)
				|
				(
					tk=<K_PRIMARY> tk2=<K_KEY> 
						colNames=ColumnsNamesList()
						{ 
							index = new Index(); 
							index.setType(tk.image + " "+ tk2.image);
							index.setColumnsNames(colNames);
							indexes.add(index);
						}
				)
				|
				(
					tk=<K_KEY>
						tk3=<S_IDENTIFIER>		
						colNames=ColumnsNamesList()
						{ 
							index = new Index(); 
							index.setType(tk.image);
							index.setName(tk3.image);
							index.setColumnsNames(colNames);
							indexes.add(index);
						}
				)
				|
				(	
					{ 
						fkIndex = new ForeignKeyIndex(); 
					}
					[<K_CONSTRAINT> tk3=<S_IDENTIFIER> {fkIndex.setName(tk3.image);} ]
					tk=<K_FOREIGN> tk2=<K_KEY>		
						colNames=ColumnsNamesList()
						{ 
							fkIndex.setType(tk.image + " " + tk2.image);
							fkIndex.setColumnsNames(colNames);
						}
						<K_REFERENCES> fkTable=Table() colNames=ColumnsNamesList()
						{
							fkIndex.setTable(fkTable);
							fkIndex.setReferencedColumnNames(colNames);
							indexes.add(fkIndex);
						}
				)
				|
				(
					(columnName=<S_IDENTIFIER>
					|
					columnName=<S_QUOTED_IDENTIFIER>)
					colDataType = ColDataType()
					{
						columnSpecs = new ArrayList();
					}
				
					( 	parameter=CreateParameter() { columnSpecs.add(parameter); } 	)*
		
					{ 
						coldef = new ColumnDefinition();
						coldef.setColumnName(columnName.image);
						coldef.setColDataType(colDataType);
						if (columnSpecs.size() > 0)
							coldef.setColumnSpecStrings(columnSpecs);
						columnDefinitions.add(coldef);
					}
				)
			)
		)* 
		
		")"
		( 	parameter=CreateParameter() { tableOptions.add(parameter); } )*
	
	]
	
	
	{
		createTable.setTable(table);
		if (indexes.size() > 0)
			createTable.setIndexes(indexes);
		if (tableOptions.size() > 0)
			createTable.setTableOptionsStrings(tableOptions);
		if (columnDefinitions.size() > 0)
			createTable.setColumnDefinitions(columnDefinitions);
		return createTable;
	}
	
}

ColDataType ColDataType():
{
	ColDataType colDataType = new ColDataType();
	Token tk = null;
	ArrayList argumentsStringList = new ArrayList();
}
{
	( tk=<S_IDENTIFIER> { colDataType.setDataType(tk.image); } )
		
	
	[LOOKAHEAD(2) "(" ( (tk=<S_INTEGER> | tk=<S_CHAR_LITERAL>) { argumentsStringList.add(tk.image); } ["," {/*argumentsStringList.add(",");*/}] )*    ")"]
	{
		if (argumentsStringList.size() > 0)
			colDataType.setArgumentsStringList(argumentsStringList);
		return colDataType;
	}
}

CreateView CreateView():
{
	CreateView createView = new CreateView();
	Table view = null;
	SelectBody select = null;
	List<String> columnNames = null;
}
{
	<K_CREATE>
	[ <K_OR> <K_REPLACE> { createView.setOrReplace(true);} ]
	[ <K_MATERIALIZED> { createView.setMaterialized(true);} ]
	<K_VIEW> view=Table() { createView.setView(view); }
	[ columnNames = ColumnsNamesList() { createView.setColumnNames(columnNames); } ]
	<K_AS>
	(
      LOOKAHEAD(SelectBody()) select=SelectBody() { createView.setSelectBody(select); }
	  |
	  "(" select=SelectBody() ")" { createView.setSelectBody(select); }
    )
	{ return createView; }
}

String CreateParameter():
{
	String retval = null;
	Token tk = null;
}
{
		(
			tk=<S_IDENTIFIER> { retval = tk.image; } 
			|
			tk=<K_NULL> { retval = tk.image; } 
			|
			tk=<K_NOT> { retval = tk.image; } 
			|
			tk=<K_PRIMARY> { retval = tk.image; } 
			|
			tk=<K_KEY> { retval = tk.image; } 
			|
			tk=<S_CHAR_LITERAL> { retval = tk.image; } 
			|
			tk=<S_INTEGER> { retval = tk.image; } 
			|
			tk=<S_DOUBLE> { retval = tk.image; } 
			|
			"=" { retval = "="; } 
			| 
			retval=AList()
		)
	{return retval;}
}

String AList():
{
	StringBuilder retval = new StringBuilder("(");
	Token tk = null;
}
{
	 "(" 
	 
	 ( (tk=<S_INTEGER> | tk=<S_DOUBLE> | tk=<S_CHAR_LITERAL> | tk=<S_IDENTIFIER>) { retval.append(tk.image); } ["," {retval.append(",");}] )*    
	 
	")"
	{
		retval.append(")");
		return retval.toString();
	}
}

List<String> ColumnsNamesList():
{
	List<String> retval = new ArrayList<String>();
	Token tk = null;
}
{
	 "(" 
	 
	 	tk=<S_IDENTIFIER> { retval.add(tk.image); } 
	 	( "," tk=<S_IDENTIFIER> { retval.add(tk.image); } )*
	 
	")"
	{
		return retval;
	}
}


Drop Drop():
{
	Drop drop = new Drop();
	Token tk = null;
	List<String> dropArgs = new ArrayList<String>();
}
{
	<K_DROP>
	(
		tk=<S_IDENTIFIER>
		| 
		tk=<K_TABLE>
		|
		tk=<K_INDEX>
	)
    { drop.setType(tk.image); }
	tk=<S_IDENTIFIER> { drop.setName(tk.image); }
	(tk=<S_IDENTIFIER> { dropArgs.add(tk.image); })*
	
	{
		if (dropArgs.size() > 0)
			drop.setParameters(dropArgs);
		return drop;
	}
}

Truncate Truncate():
{
	Truncate truncate = new Truncate();
	Table table;
}
{
	<K_TRUNCATE> <K_TABLE>
	table=Table() { truncate.setTable(table); }
	
	{
		return truncate;
	}
}
